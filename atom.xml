<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员Barnes的博客</title>
  
  <subtitle>逍遥于天地之间，而心意自得。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kinegratii.github.io/"/>
  <updated>2020-11-08T06:32:52.265Z</updated>
  <id>http://kinegratii.github.io/</id>
  
  <author>
    <name>程序员Barnes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Borax-3.4.0发布日志</title>
    <link href="http://kinegratii.github.io/2020/11/08/borax-release-note-340/"/>
    <id>http://kinegratii.github.io/2020/11/08/borax-release-note-340/</id>
    <published>2020-11-08T06:14:14.000Z</published>
    <updated>2020-11-08T06:32:52.265Z</updated>
    
    <content type="html"><![CDATA[<p>2020年11月15日，也就是 v3.0.0 版本发布一周年之际，我们很高兴地宣布，Borax v3.4.0 正式发布。</p><a id="more"></a><h1 id="1-项目开发SOP"><a href="#1-项目开发SOP" class="headerlink" title="1 项目开发SOP"></a>1 项目开发SOP</h1><h2 id="1-1-全新的项目组织形式"><a href="#1-1-全新的项目组织形式" class="headerlink" title="1.1 全新的项目组织形式"></a>1.1 全新的项目组织形式</h2><p>Borax定位于一个由众多实用性功能组成的工具集合库。自v3.4开始，引入“话题/主题，Topic” 的概念，并使用“Borax.Foo” 的字符串标识每一个主题。</p><p>每个主题的代码形式可以是模块或包。目前已经被定义的主题如下表：</p><table><thead><tr><th>主题</th><th>描述</th></tr></thead><tbody><tr><td>Borax.Calendars</td><td>农历日期库。由 Borax.LunarDate 、Borax.Festivals 和 Borax.Birthday 三部分组成</td></tr><tr><td>Borax.Choices</td><td>基于类定义的选项数据结构</td></tr><tr><td>Borax.Datasets</td><td>记录型数据的操作库</td></tr><tr><td>Borax.DataStructures</td><td>常用的数据结构</td></tr><tr><td>Borax.Numbers</td><td>数字处理库，包括中文数字、财务数字。</td></tr><tr><td>Borax.Pattern</td><td>基于Python实现的设计模式</td></tr><tr><td>Borax.UI</td><td>基于tkinter的封装</td></tr><tr><td>Borax.Utils</td><td>基础数据类型（字典、列表、对象）操作库。</td></tr></tbody></table><p>基于主题的项目组织形式，我们还做了下列的工作：</p><ul><li>按照主题重新组织Borax文档的编排</li><li>按照主题的方式重新调整部分模块的归属</li></ul><h2 id="1-2-发布周期和API废弃策略"><a href="#1-2-发布周期和API废弃策略" class="headerlink" title="1.2 发布周期和API废弃策略"></a>1.2 发布周期和API废弃策略</h2><p>Borax 将继续遵循 “<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本2.0</a>” 的版本管理策略，即由“&lt;主版本号&gt;.&lt;次版本号&gt;.&lt;修正版本号&gt;”组成。并结合相关情况制定相应的发布策略：</p><ul><li>其中 <em>次版本号</em> 不大于9</li><li>一年发布两个“次版本系列”，时间是5月和11月。以“2020年11月-v3.4” 为起始点。</li><li>使用 “主版本废弃策略”，延长废弃进程。即 3.x 被标记为废弃的接口将在 v4.0 移除。</li></ul><p>Borax 预计的发布日程表如下：</p><table><thead><tr><th>版本</th><th>发布日期</th></tr></thead><tbody><tr><td>v3.4.0</td><td>2020年11月15日</td></tr><tr><td>v3.5.0</td><td>2021年5月15日（预计）</td></tr><tr><td>v3.6.0</td><td>2021年11月15日（预计）</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h2 id="1-3-新的CI工具：Github-Action"><a href="#1-3-新的CI工具：Github-Action" class="headerlink" title="1.3 新的CI工具：Github Action"></a>1.3 新的CI工具：Github Action</h2><p>Borax 3.4开始使用 <a href="https://github.com/kinegratii/borax/actions" target="_blank" rel="noopener">Github Action</a> 代替原有的 <a href>Travis CI</a> ，主要原因在于：</p><ul><li>跟 Github 结合的很好，使用 方便。</li><li>生态发展很好，支持 step 共享。</li></ul><p>新增基于 Codecov 的代码覆盖率显示。</p><h2 id="1-4-Python版本支持：新增python3-9支持"><a href="#1-4-Python版本支持：新增python3-9支持" class="headerlink" title="1.4 Python版本支持：新增python3.9支持"></a>1.4 Python版本支持：新增python3.9支持</h2><p>Borax 新增了对python3.9的构建支持。目前 Borax 支持以下的 python 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.5 ~ 3.9</span><br></pre></td></tr></table></figure><h1 id="2-Borax-Numbers-中文数字的四种形式"><a href="#2-Borax-Numbers-中文数字的四种形式" class="headerlink" title="2 Borax.Numbers: 中文数字的四种形式"></a>2 Borax.Numbers: 中文数字的四种形式</h1><h2 id="2-1-四种表示形式"><a href="#2-1-四种表示形式" class="headerlink" title="2.1 四种表示形式"></a>2.1 四种表示形式</h2><p>根据大小写和使用场景，中文数字可分为不同的形式：</p><p>小写所使用的汉字如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一二三四五六七八九  十百千万亿</span><br></pre></td></tr></table></figure><p>大写使用的汉字如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">壹贰叁肆伍陆柒捌玖 拾佰仟万亿</span><br></pre></td></tr></table></figure><p>使用场景指的是数字“0”的表示形式。根据《出版物上数字用法(GB T 15835-2011)》的规定，汉字 “零” 和 “〇” 是有严格的使用场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">阿拉伯数字“0”有“零”和“〇”两种汉字书写形式。一个数字用作计量时，其中“0”的汉字书写形式为“零”，用作编号时，“0”的汉字书写形式为“〇”。</span><br><span class="line"></span><br><span class="line">　示例：“3052（个）”的汉字数字形式为“三千零五十二”（不写为“三千〇五十二”）</span><br><span class="line"></span><br><span class="line">“95.06”的汉字数字形式为“九十五点零六”（不写为“九十五点〇六”）</span><br><span class="line"></span><br><span class="line">“公元2012（年）”的汉字数字形式为“二〇一二”（不写为“二零一二”）</span><br><span class="line"></span><br><span class="line">---- 出版物上数字用法(GB T 15835-2011)</span><br></pre></td></tr></table></figure><p>综上所述，数字204共有4种表示形式。</p><table><thead><tr><th></th><th>大写(Upper)</th><th>小写(Lower)</th></tr></thead><tbody><tr><td>计量(Measure)</td><td>贰佰零肆</td><td>二百零四</td></tr><tr><td>编号(Order)</td><td>贰佰〇肆</td><td>二百〇四</td></tr></tbody></table><p>财务金额使用的 大写，计量 的表示形式。法律条文中“第XXX条” 使用的是 小写，编号 的表示形式。</p><h2 id="2-2-ChineseNumber类方法"><a href="#2-2-ChineseNumber类方法" class="headerlink" title="2.2 ChineseNumber类方法"></a>2.2 ChineseNumber类方法</h2><p>Borax v3.4 引入了中文数字的计量和编号两种不同用法，对于数字 “0” 使用不同的中文汉字描述。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ChineseNumbers.to_chinese_number(num:Union[int, str], upper:bool=False, order:bool=False)  -&gt; str</td><td>使用upper控制大小写，使用order控制计量/编号</td></tr><tr><td>ChineseNumbers.measure_number(num:Union[int, str])  -&gt; str</td><td>小写，计量</td></tr><tr><td>ChineseNumbers.order_number(num:Union[int, str])  -&gt; str</td><td>小写，编号</td></tr></tbody></table><h1 id="3-Borax-Choices-整合Django-Choices"><a href="#3-Borax-Choices-整合Django-Choices" class="headerlink" title="3 Borax.Choices: 整合Django.Choices"></a>3 Borax.Choices: 整合Django.Choices</h1><p>主要变化如下</p><ul><li>整合ConstChoices和django choices</li></ul><h1 id="4-Borax-Calendars"><a href="#4-Borax-Calendars" class="headerlink" title="4 Borax.Calendars"></a>4 Borax.Calendars</h1><h2 id="4-1-农历日期格式化"><a href="#4-1-农历日期格式化" class="headerlink" title="4.1 农历日期格式化"></a>4.1 农历日期格式化</h2><p>strftime函数变化：</p><table><thead><tr><th>描述符</th><th>变更</th></tr></thead><tbody><tr><td>%t</td><td>当节气不存在时显示为 <code>-</code> 而不是空字符串</td></tr><tr><td>%X</td><td>[新增]月份的另一种形式，将“冬”、“腊”显示为“十一”、“十二”</td></tr><tr><td></td><td></td></tr></tbody></table><p>描述符的文档，使用 年月日闰及其变种 的形式描述。</p><h2 id="4-2-获取闰月的年份"><a href="#4-2-获取闰月的年份" class="headerlink" title="4.2 获取闰月的年份"></a>4.2 获取闰月的年份</h2><p>函数签名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LCalendars</span>.<span class="title">get_leap_years</span><span class="params">(month:int=<span class="number">0</span>)</span> -&gt; tuple</span></span><br></pre></td></tr></table></figure><p>函数返回 含有给定闰月的年份列表。当 month=0时，返回所有闰月的年份。当month大于12时，返回空元组。</p><h2 id="4-3-节气日期"><a href="#4-3-节气日期" class="headerlink" title="4.3 节气日期"></a>4.3 节气日期</h2><p>在Borax v3.3可使用 <code>LCalendars.create_solar_date</code> 获取公历年特定节气的日期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LCalendars</span>.<span class="title">create_solar_date</span><span class="params">(year: int, term_index: Optional[int] = None, term_name: Optional[str] = None)</span> -&gt; datetime.date</span></span><br></pre></td></tr></table></figure><p>由于该方法的 year 参数和所在 <code>LCalendars</code> 类的意义有所冲突。Borax v3.4 该方法已废弃，新增 <code>SCalendars.term2date</code> ，签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SCalendars</span>.<span class="title">term2date</span><span class="params">(year: int, term_name: Optional[str] = None)</span> -&gt; datetime.date</span></span><br></pre></td></tr></table></figure><p>主要变化：</p><ul><li>移除了 <code>term_index</code> 参数</li><li>参数 <code>term_name</code> 支持 <code>&#39;ChunFeng&#39;</code> 和 <code>&#39;春分&#39;</code> 两种形式</li></ul><h2 id="4-4-import路径"><a href="#4-4-import路径" class="headerlink" title="4.4 import路径"></a>4.4 import路径</h2><p>在Borax v3.4版本中，对开放的类提供了shortcut import path，完整的信息如下：</p><table><thead><tr><th>实际引用</th><th>Shortcut引用</th></tr></thead><tbody><tr><td>borax.calendars.lundardate.LunarDate</td><td>borax.calendars.LunarDate</td></tr><tr><td>borax.calendars.lunardate.LCalendars</td><td>borax.calendars.LCalendars</td></tr><tr><td>borax.calendars.utils.SCalendars</td><td>borax.calendars.SCalendars</td></tr></tbody></table><h1 id="5-Borax-JSON-JSON序列化"><a href="#5-Borax-JSON-JSON序列化" class="headerlink" title="5 Borax.JSON: JSON序列化"></a>5 Borax.JSON: JSON序列化</h1><h2 id="5-1-模块组织"><a href="#5-1-模块组织" class="headerlink" title="5.1 模块组织"></a>5.1 模块组织</h2><p>Borax V3.4版本将 <code>bjson</code> 和 <code>cjson</code> 两个模块整合合并，形成全新的 <code>borax.cjson</code> 模块。原有的 <code>bjson</code> 将被标记为 Deprecated ，并在V4.0中移除。</p><table><thead><tr><th>V3.3.x</th><th>V3.4.x</th><th>描述</th></tr></thead><tbody><tr><td>borax.seriaize.bjson</td><td></td><td>实现基于类的 JSON Encoder</td></tr><tr><td>borax.serialize.cjson</td><td>borax.cjson</td><td>实现基于函数的 JSON Encoder</td></tr></tbody></table><blockquote><p>最终保留 cjson 意味着完全采用基于函数的实现方式。</p></blockquote><p>新的 <code>borax.serialize.cjson</code> 的变化如下：</p><ul><li>默认使用目标类 <code>__json__</code> 的编码函数</li><li>新增 <code>datetime</code> / <code>date</code> 等常用类JSON编码</li><li>使用 <code>cjson.encoder.register</code> 添加新的编码函数</li></ul><h2 id="5-2-使用示例"><a href="#5-2-使用示例" class="headerlink" title="5.2 使用示例"></a>5.2 使用示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"><span class="keyword">from</span> borax.calendars <span class="keyword">import</span> LunarDate</span><br><span class="line"><span class="keyword">from</span> borax.serialize <span class="keyword">import</span> cjson</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cjson.encoder.register(LunarDate)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_ld</span><span class="params">(ld)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ld.strftime(<span class="string">'%Y年%L%M月%D日'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'current_time'</span>: datetime.now()&#125;</span><br><span class="line">print(cjson.dumps(data))</span><br><span class="line"></span><br><span class="line">data2 = &#123;</span><br><span class="line">    <span class="string">'solar_day'</span>: date.today(),</span><br><span class="line">    <span class="string">'lunar_day'</span>: LunarDate.today()</span><br><span class="line">&#125;</span><br><span class="line">print(cjson.dumps(data2, ensure_ascii=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;current_time&quot;: &quot;2020-10-10 10:42:25&quot;&#125;</span><br><span class="line">&#123;&quot;solar_day&quot;: &quot;2020-10-10&quot;, &quot;lunar_day&quot;: &quot;二〇二〇年八月廿四日&quot;&#125;</span><br></pre></td></tr></table></figure><h1 id="6-Borax-SerialNo-基于-Pool-的生成器"><a href="#6-Borax-SerialNo-基于-Pool-的生成器" class="headerlink" title="6 Borax.SerialNo 基于 Pool 的生成器"></a>6 Borax.SerialNo 基于 Pool 的生成器</h1><p><code>borax.counters.serial_pool</code> 模块使用新的方式实现序列号生成器。包括以下函数和类：</p><ul><li>serial_no_generator 序列号生成器</li><li>SerialElement 序列号实体类</li><li>SerialNoPool 生成池</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> borax.counters.serial_pool <span class="keyword">import</span> SerialNoPool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 'LC00000000' ~ 'LC99999999' 的迭代器</span></span><br><span class="line">pool = SerialNoPool(label_fmt=<span class="string">'LC&#123;no&#125;'</span>, dights=<span class="number">8</span>)</span><br><span class="line">data = pool.generate_labels(num=<span class="number">3</span>)</span><br><span class="line">print(data) <span class="comment"># ['LC00000000', 'LC0000001', 'LC00000002']</span></span><br><span class="line"></span><br><span class="line">pool.add_elements(data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年11月15日，也就是 v3.0.0 版本发布一周年之际，我们很高兴地宣布，Borax v3.4.0 正式发布。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="项目" scheme="http://kinegratii.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>ArgonRobot-V3.0.0 发布计划</title>
    <link href="http://kinegratii.github.io/2020/08/05/argon-robot-v300-plan/"/>
    <id>http://kinegratii.github.io/2020/08/05/argon-robot-v300-plan/</id>
    <published>2020-08-05T13:14:14.000Z</published>
    <updated>2020-11-08T06:32:52.265Z</updated>
    
    <content type="html"><![CDATA[<p>ArgonRobot-V3.0.0 发布计划</p><p>ArgonRobot是一个数据爬取和分析的综合管理平台。平台基于 Python3 + Flask + Peewee + Redis 开发。</p><a id="more"></a><p>主要功能如下：</p><ul><li>数据抓取（包括定时和手动两种方式）</li><li>配置数据执行器</li><li>社交平台发布</li><li>平台月度/年度运营报告</li></ul><p>发布进程如下：</p><table><thead><tr><th>日期</th><th>事项</th></tr></thead><tbody><tr><td>2020.08.10</td><td>V3.0.0Beta1 发布 ，冻结新功能</td></tr><tr><td>2020.08.16</td><td>完善文档</td></tr><tr><td>2020.08.21</td><td>V3.0.0RC1发布</td></tr><tr><td>2020.08.25</td><td>V3.0.0 发布</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArgonRobot-V3.0.0 发布计划&lt;/p&gt;
&lt;p&gt;ArgonRobot是一个数据爬取和分析的综合管理平台。平台基于 Python3 + Flask + Peewee + Redis 开发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="项目" scheme="http://kinegratii.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>docx和docxtpl库的基本使用</title>
    <link href="http://kinegratii.github.io/2020/03/22/the-usage-of-docx-and-docxtpl/"/>
    <id>http://kinegratii.github.io/2020/03/22/the-usage-of-docx-and-docxtpl/</id>
    <published>2020-03-22T00:42:43.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>在web开发过程中，经常需要导出一些word文档，比如运营月报、进货单、收据等。它们的特点是格式都是一致的，只是需要不同的数据进行填充。</p><p>docx 和 docxtpl 是比较常见的处理 word 文件的python库。其中前者用于创建一个包含段落、图片、表格、页眉等元素文档，后者使用类似 jinja2 的方式从模板文档生成新的文档。</p><blockquote><p>docx是一种压缩文档格式，使用XML形式定义了样式、段落等内容。详情可以查看 <a href="https://www.toptal.com/xml/an-informal-introduction-to-docx" target="_blank" rel="noopener">《An Informal Introduction to DOCX》</a>。</p></blockquote><a id="more"></a><h1 id="文档构建"><a href="#文档构建" class="headerlink" title="文档构建"></a>文档构建</h1><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>使用 pip 安装这两个库即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install python-docx</span><br><span class="line">pip install docxtpl</span><br></pre></td></tr></table></figure><p>其中 docxtpl 还依赖 jinja2 库。</p><h2 id="创建-word"><a href="#创建-word" class="headerlink" title="创建 word"></a>创建 word</h2><p>使用以下的方式创建一个 Document 对象，之后的操作都是基于该对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">document = Document()</span><br></pre></td></tr></table></figure><p>使用 <code>add_*</code> 函数添加到该文档对象，包括：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>add_paragraph</td><td>段落</td></tr><tr><td>add_heading</td><td>标题</td></tr><tr><td>add_page_break</td><td>换页符</td></tr><tr><td>add_table(rows, cols)</td><td>表格</td></tr><tr><td>add_picture</td><td>图片</td></tr><tr><td>add_run</td><td>字符片段</td></tr></tbody></table><p>run 是word中包含相同样式的字符片段，通常它的级别比 paragraph 更低。</p><p>这是正常的文字。<strong>这是粗体文字。</strong> 这是正常的文字。</p><p> 比如上述的一段文字。依次由3个 run 组成。</p><p>待文档构建完成后，可以使用 save 函数保存到文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.save(<span class="string">'demo.docx'</span>)</span><br></pre></td></tr></table></figure><h1 id="文档模板"><a href="#文档模板" class="headerlink" title="文档模板"></a>文档模板</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>docxtpl 的使用方法和 jinja2 类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docxtpl <span class="keyword">import</span> DocxTemplate</span><br><span class="line"></span><br><span class="line">doc = DocxTemplate(<span class="string">"my_word_template.docx"</span>)</span><br><span class="line">context = &#123; <span class="string">'company_name'</span> : <span class="string">"World company"</span> &#125;</span><br><span class="line">doc.render(context)</span><br><span class="line">doc.save(<span class="string">"generated_doc.docx"</span>)</span><br></pre></td></tr></table></figure><p>docxtpl 的核心在于前端标签定义。</p><h2 id="变量渲染"><a href="#变量渲染" class="headerlink" title="变量渲染"></a>变量渲染</h2><p>就像 jinja2 中一样，使用两个大括号即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &lt;var&gt; &#125;&#125;</span><br></pre></td></tr></table></figure><p>当 var 是 RichText 对象时，必须使用以下的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;r &lt;var&gt; &#125;&#125;</span><br></pre></td></tr></table></figure><p>为了能够准确的区分以上两种情况，建议变量名称不要单独命名为 r ，。</p><h1 id="存储和输出"><a href="#存储和输出" class="headerlink" title="存储和输出"></a>存储和输出</h1><h2 id="整合Flask"><a href="#整合Flask" class="headerlink" title="整合Flask"></a>整合Flask</h2><p>将文档对象保存到新建的 <code>BytesIO()</code> 实例即可，但需要注意的是在返回给浏览器前将文件指针重新指向开头。</p><p>详情查看 flask.send_file 的用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> docxtpl <span class="keyword">import</span> DocxTemplate</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> send_file</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">export_monthly_report</span><span class="params">(year, index)</span>:</span></span><br><span class="line">    context = &#123;&#125; <span class="comment"># 填充数据</span></span><br><span class="line">    doc = DocxTemplate(app.root_path + <span class="string">'/templates/report_monthly.docx'</span>)</span><br><span class="line">    target_filename = <span class="string">'monthly_&#123;&#125;_&#123;&#125;.docx'</span>.format(year, index)</span><br><span class="line">    doc.render(context)</span><br><span class="line">    file_stream = io.BytesIO()</span><br><span class="line">    doc.save(file_stream)</span><br><span class="line">    file_stream.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> send_file(file_stream, as_attachment=<span class="literal">True</span>, attachment_filename=target_filename)</span><br></pre></td></tr></table></figure><h3 id="整合Django"><a href="#整合Django" class="headerlink" title="整合Django"></a>整合Django</h3><p>和 flask类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">export_monthly_report</span><span class="params">(request, year, index)</span>:</span></span><br><span class="line">    context = &#123;&#125; <span class="comment"># 填充数据</span></span><br><span class="line">    doc = DocxTemplate(app.root_path + <span class="string">'/templates/report_monthly.docx'</span>)</span><br><span class="line">    target_filename = <span class="string">'monthly_&#123;&#125;_&#123;&#125;.docx'</span>.format(year, index)</span><br><span class="line">    doc.render(context)</span><br><span class="line">    file_stream = io.BytesIO()</span><br><span class="line">    doc.save(file_stream)</span><br><span class="line">    file_stream.seek(<span class="number">0</span>)</span><br><span class="line">    response = HttpResponse(</span><br><span class="line">        file_stream.getvalue(),  <span class="comment"># use the stream's contents</span></span><br><span class="line">        content_type=<span class="string">"application/vnd.openxmlformats-officedocument.wordprocessingml.document"</span>,</span><br><span class="line">    )</span><br><span class="line">    response[<span class="string">"Content-Disposition"</span>] = <span class="string">'attachment; filename = "&#123;&#125;"'</span>.format(target_filename)</span><br><span class="line">    response[<span class="string">"Content-Encoding"</span>] = <span class="string">"UTF-8"</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在web开发过程中，经常需要导出一些word文档，比如运营月报、进货单、收据等。它们的特点是格式都是一致的，只是需要不同的数据进行填充。&lt;/p&gt;
&lt;p&gt;docx 和 docxtpl 是比较常见的处理 word 文件的python库。其中前者用于创建一个包含段落、图片、表格、页眉等元素文档，后者使用类似 jinja2 的方式从模板文档生成新的文档。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docx是一种压缩文档格式，使用XML形式定义了样式、段落等内容。详情可以查看 &lt;a href=&quot;https://www.toptal.com/xml/an-informal-introduction-to-docx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《An Informal Introduction to DOCX》&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="文档" scheme="http://kinegratii.github.io/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Python开发工程师笔试题（web方向）</title>
    <link href="http://kinegratii.github.io/2019/12/20/python-web-interview-questions/"/>
    <id>http://kinegratii.github.io/2019/12/20/python-web-interview-questions/</id>
    <published>2019-12-20T12:28:25.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>Python开发工程师（web方向）</p><a id="more"></a><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>★ 列出5个常用Python标准库？</p><p>★ 在单元测试库unittest中，函数 <code>unittest.TestCase.subTest</code> 和 装饰器 <code>unittest.skipIf</code> 的作用分别是什么？</p><p>★ Django数据库操作中，函数 <code>bulk_create</code> 和 循环 save 在用法上有什么区别？</p><p>★ 什么是“N+1”查询的问题。Django如何解决这一问题。</p><p>★ WSGI和ASGI有什么相同点和不同点。</p><p>★ 在web开发中，表单传递参数和JSON传递参数有什么不同，各自的应用场景是什么？</p><p>★ 下面下划线的作用是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, user = User.objects.get_or_create(username=<span class="string">'admin'</span>, default=&#123;<span class="string">'password'</span>:<span class="string">'123456'</span>, <span class="string">'last_updated'</span>: <span class="string">'2019-10-23 08:00:00'</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="程序阅读题"><a href="#程序阅读题" class="headerlink" title="程序阅读题"></a>程序阅读题</h2><p>★ 阅读下面的python2程序，回答第1-2题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf8</span></span><br><span class="line"></span><br><span class="line"> a = range(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x, y:x + y, a[<span class="number">7</span>:] + a[<span class="number">-4</span>::<span class="number">2</span>] + a[<span class="number">-5</span>:<span class="number">5</span>] + a[<span class="number">3</span>:<span class="number">-2</span>:<span class="number">4</span>])  / <span class="number">10</span></span><br></pre></td></tr></table></figure><p>（1） 变量 result的值是多少？</p><p>（2） 以上代码在python3下是否可以正常运行，如果不能，需要怎样修改才能正常运行且结果不变。（3点）</p><p>★ 阅读下列程序片段，根据运行结果补充函数 <code>inject</code> 的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app_id)</span>:</span></span><br><span class="line">        self.app_id = app_id</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inject</span><span class="params">(self. **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">app = App(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.inject(app_id=6)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_context</span><span class="params">(context)</span>:</span></span><br><span class="line">    context = context <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    context.update(&#123;<span class="string">'method'</span>: <span class="string">'build_context'</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> context</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(build_context(&#123;<span class="string">'name'</span>:<span class="string">'hello'</span>&#125;)) <span class="comment"># 结果为 &#123;'name':'hello', 'app_id': 6, 'method': 'build_context'&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python开发工程师（web方向）&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Python" scheme="http://kinegratii.github.io/tags/Python/"/>
    
      <category term="Django" scheme="http://kinegratii.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>博客V5.0升级笔记</title>
    <link href="http://kinegratii.github.io/2019/09/30/blog_upgrade_note/"/>
    <id>http://kinegratii.github.io/2019/09/30/blog_upgrade_note/</id>
    <published>2019-09-30T02:48:54.000Z</published>
    <updated>2020-11-08T06:32:52.265Z</updated>
    
    <content type="html"><![CDATA[<p>2019年9月30日，本博客升级了相关库，具体信息如下：</p><table><thead><tr><th>库</th><th>现有版本</th><th>原有版本</th></tr></thead><tbody><tr><td>node</td><td>8.11.2</td><td>8.11.2</td></tr><tr><td>hexo-cli</td><td>2.0.0</td><td>1.1.0</td></tr><tr><td>hexo</td><td>3.9.0</td><td>3.2.2</td></tr><tr><td>hexo-theme-next</td><td>7.4.0</td><td>6.3.0</td></tr></tbody></table><a id="more"></a><h2 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h2><ul><li>博客新增版本记录</li><li>新增 pjax 特性</li><li>新增 github Banner</li><li>新增相关文章模块</li><li>更新正文字体大小</li></ul><h2 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h2><h3 id="依赖库更新"><a href="#依赖库更新" class="headerlink" title="依赖库更新"></a>依赖库更新</h3><p>和正常 Node 项目一致，使用 npm 更新即可。</p><p>更新全局 hexo-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g hexo-cli</span><br></pre></td></tr></table></figure><p>进入博客目录</p><p>查看可升级的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm outdated</span><br><span class="line">Package                  Current  Wanted  Latest  Location</span><br><span class="line">hexo                       3.2.2   3.9.0   3.9.0  Kinegratii-blog</span><br><span class="line">hexo-deployer-git          0.2.0   0.2.0   2.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-archive     0.1.4   0.1.5   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-category    0.1.3   0.1.3   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-feed        1.2.0   1.2.2   2.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-index       0.2.0   0.2.1   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-searchdb    1.0.3   1.0.8   1.0.8  Kinegratii-blog</span><br><span class="line">hexo-generator-sitemap     1.1.2   1.2.0   1.2.0  Kinegratii-blog</span><br><span class="line">hexo-generator-tag         0.2.0   0.2.0   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-renderer-ejs          0.2.0   0.2.0   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-renderer-marked      0.2.11  0.2.11   2.0.0  Kinegratii-blog</span><br><span class="line">hexo-renderer-stylus       0.3.1   0.3.3   1.1.0  Kinegratii-blog</span><br><span class="line">hexo-server                0.2.0   0.2.2   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-symbols-count-time    0.4.4   0.4.4   0.6.1  Kinegratii-blog</span><br><span class="line">hexo-wordcount             2.0.1   2.0.1   6.0.1  Kinegratii-blog</span><br></pre></td></tr></table></figure><p>全局安装 npm-check工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check</span><br></pre></td></tr></table></figure><p>更新所有包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-check -u --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>升级后的版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;hexo&quot;: &quot;^3.9.0&quot;,</span><br><span class="line">  &quot;hexo-deployer-git&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">  &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">  &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">  &quot;hexo-generator-feed&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">  &quot;hexo-generator-index&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">  &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;,</span><br><span class="line">  &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">  &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">  &quot;hexo-related-popular-posts&quot;: &quot;^3.0.6&quot;,</span><br><span class="line">  &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">  &quot;hexo-renderer-marked&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">  &quot;hexo-renderer-stylus&quot;: &quot;^1.1.0&quot;,</span><br><span class="line">  &quot;hexo-server&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">  &quot;hexo-symbols-count-time&quot;: &quot;^0.6.1&quot;,</span><br><span class="line">  &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Next主题更新"><a href="#Next主题更新" class="headerlink" title="Next主题更新"></a>Next主题更新</h3><p>几个文档采用手动合并更新：</p><ul><li>next主题配置文件：_config.yaml  （必须以现有配置文件为基础）</li><li>中文翻译文件： zh-CN.yml</li><li>插件库：lib</li><li>插件库版本忽略文件：themes\next.gitignore</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年9月30日，本博客升级了相关库，具体信息如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;库&lt;/th&gt;
&lt;th&gt;现有版本&lt;/th&gt;
&lt;th&gt;原有版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;8.11.2&lt;/td&gt;
&lt;td&gt;8.11.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hexo-cli&lt;/td&gt;
&lt;td&gt;2.0.0&lt;/td&gt;
&lt;td&gt;1.1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hexo&lt;/td&gt;
&lt;td&gt;3.9.0&lt;/td&gt;
&lt;td&gt;3.2.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hexo-theme-next&lt;/td&gt;
&lt;td&gt;7.4.0&lt;/td&gt;
&lt;td&gt;6.3.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://kinegratii.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>编译Python脚本</title>
    <link href="http://kinegratii.github.io/2019/04/25/compile-python-files/"/>
    <id>http://kinegratii.github.io/2019/04/25/compile-python-files/</id>
    <published>2019-04-25T12:37:10.000Z</published>
    <updated>2020-11-08T06:32:52.265Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述了将 python 源代码文件编译成相应的库文件。</p><a id="more"></a><h2 id="1-文件类型"><a href="#1-文件类型" class="headerlink" title="1 文件类型"></a>1 文件类型</h2><p>python开发中文件类型如下：</p><table><thead><tr><th>序号</th><th>文件类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>.py</td><td>源代码文件</td></tr><tr><td>2</td><td>.pyw</td><td>源代码文件</td></tr><tr><td>3</td><td>.pyi</td><td>存根文件，用于类、函数的声明；参见PEP 484</td></tr><tr><td>4</td><td>.pyc</td><td>字节码文档</td></tr><tr><td>5</td><td>.pyo</td><td>和pyc类似，优化后的字节码文件</td></tr><tr><td>6</td><td>.pyd</td><td>库文件，和dll 和 so 文件类似</td></tr></tbody></table><h3 id="和dll的区别"><a href="#和dll的区别" class="headerlink" title="和dll的区别"></a>和dll的区别</h3><p>关于 dll 和 pyd 的区别可以参见 官方文档 <a href="https://docs.python.org/3/faq/windows.html#id6" target="_blank" rel="noopener">Is a *.pyd file the same as a DLL?</a>。</p><h3 id="编译pyd文件"><a href="#编译pyd文件" class="headerlink" title="编译pyd文件"></a>编译pyd文件</h3><p><a href="https://cython.org/" target="_blank" rel="noopener">Cython</a> 是一个静态编译器，也是 python语言的超集。 Cpython 将python代码转化为 c 语言代码，这个过程称为 <strong>Cythonizing</strong> 。和 原来的 python 代码相比，其执行速度将有较大的提高。</p><p>第一步，在windows下编译需要两个工具：</p><ul><li>微软python编译器，在 <a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">https://visualstudio.microsoft.com/downloads/</a> 下载记可</li><li>cpython 包，使用 <code>pip install cpython</code></li></ul><p>第二步，提供源代码。以 <em>hello.py</em> 文件为例子，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello world!"</span>)</span><br></pre></td></tr></table></figure><p>第三步，编写一个 setup.py 文件，基本代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ext_modules=cythonize(<span class="string">'module.py'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第四步，使用以下命令开始编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><p>会在同一个目录下生成 hell.pyd 文件，这个文件可以像正常的模块进行 import 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文描述了将 python 源代码文件编译成相应的库文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="构建" scheme="http://kinegratii.github.io/tags/%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>英语的那些大数字</title>
    <link href="http://kinegratii.github.io/2019/01/15/english-big-numbers/"/>
    <id>http://kinegratii.github.io/2019/01/15/english-big-numbers/</id>
    <published>2019-01-15T14:18:35.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>Idle Aiport Tycoon 游戏中出现的那些大数字。</p><a id="more"></a><p>为了避免数字位数太多而无法看清它具体的数值，人们在数字中每隔3个数字加入一个分隔符，这就是千位分隔符，比如 <code>1,000,000</code>。</p><p>英式英文和美式英文在一些单词表示上有所不同，这里指的是英式英文。</p><table><thead><tr><th>单词</th><th>汉语</th><th>数字</th><th>缩写</th></tr></thead><tbody><tr><td>million</td><td>百万</td><td>10^6</td><td>M</td></tr><tr><td>billion</td><td>十亿</td><td>10^9</td><td>B</td></tr><tr><td>trillion</td><td>万亿</td><td>10^12</td><td>T</td></tr><tr><td>quadrillion</td><td>-</td><td>10^15</td><td>q</td></tr><tr><td>quintillion</td><td>-</td><td>10^18</td><td>Q</td></tr><tr><td>sextillion</td><td>-</td><td>10^21</td><td>s</td></tr><tr><td>septillion</td><td>-</td><td>10^24</td><td>S</td></tr><tr><td>octillion</td><td>-</td><td>10^27</td><td>o</td></tr><tr><td>nonillion</td><td>-</td><td>10^30</td><td>N</td></tr><tr><td>decillion</td><td>-</td><td>10^33</td><td>d</td></tr><tr><td>undecillion</td><td>涧</td><td>10^36</td><td>u</td></tr><tr><td>duodecillion</td><td>-</td><td>10^39</td><td>D</td></tr><tr><td>tredecillion</td><td>-</td><td>10^42</td><td>Td</td></tr><tr><td>quattuordecillion</td><td>-</td><td>10^45</td><td>qd</td></tr><tr><td>quindecillion</td><td>-</td><td>10^48</td><td>Qd</td></tr><tr><td>exdecillion</td><td>-</td><td>10^51</td><td></td></tr><tr><td>septendecillion</td><td>-</td><td>10^54</td><td></td></tr><tr><td>octodecillion</td><td>-</td><td>10^57</td><td></td></tr><tr><td>novemdecillion</td><td>-</td><td>10^60</td><td></td></tr><tr><td>vigintillion</td><td>-</td><td>10^63</td><td></td></tr><tr><td>centillion</td><td>-</td><td>10^66</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Idle Aiport Tycoon 游戏中出现的那些大数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识与思维" scheme="http://kinegratii.github.io/categories/%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="英语" scheme="http://kinegratii.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Borax.Lunardate:中国农历日期</title>
    <link href="http://kinegratii.github.io/2019/01/05/lunardate-module/"/>
    <id>http://kinegratii.github.io/2019/01/05/lunardate-module/</id>
    <published>2019-01-05T06:34:29.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要介绍了我国传统的农历历法知识，并叙述了 Borax-Lunar 工具库开发背后的一些算法原理和技术资料。</p><a id="more"></a><h1 id="1-农历概述"><a href="#1-农历概述" class="headerlink" title="1 农历概述"></a>1 农历概述</h1><p>农历是我国的传统历法，依据太阳和月球位置的精确预报以及约定的日期编排规则编排日期，并以传统命名方法表述日期。</p><p>2017年，我国已经颁布了国家推荐性标准《GB/T 33661-2017 农历的编算和颁行》。</p><h2 id="1-1-编排规则"><a href="#1-1-编排规则" class="headerlink" title="1.1 编排规则"></a>1.1 编排规则</h2><p>农历属于一种阴阳合历，基本规则如下：其年份分为平年和闰年。平年为十二个月；闰年为十三个月。月份分为大月和小月，大月三十天，小月二十九天。一年中哪个月大，哪个月小，可由“置闰规则”计算决定。</p><blockquote><p>若从某个农历十一月开始到下一个农历十一月（不含）之间有13个农历月，则需要置闰。置闰规则为：去其中最先出现的一个不包含中气的农历月为农历闰月。</p></blockquote><p>除此之外，还有生肖纪年、干支纪年、二十四节气等。</p><h2 id="1-2-表示方法"><a href="#1-2-表示方法" class="headerlink" title="1.2 表示方法"></a>1.2 表示方法</h2><p>农历日期通常有以下几种表示方法：</p><ul><li>农历乙未年正月初一</li><li>农历牛年闰五月十一</li><li>农历甲午年七月庚戌日</li><li>公元2016年农历丙申年十一月廿九</li></ul><h2 id="1-3-二十四节气"><a href="#1-3-二十四节气" class="headerlink" title="1.3 二十四节气"></a>1.3 二十四节气</h2><p>一个回归年内24个太阳地心视黄经等于15度的整数倍的时刻的总称，每个时刻成为一个节气。太阳每年运行360度，共经历二十四个节气，分别为立春（315度）、雨水（330度）、惊蛰（345度）、春分（0度、360度）、清明（15度）、谷雨（30度）、立夏（45度）、小满（60度）、芒种（75度）、夏至（90度）、小暑（105度）、大暑（120度）、立秋（135度）、处暑（150度）、白露（165度）、秋分（180度）、寒露（195度）、霜降（210度）、立冬（225度）、小雪（240度）、大雪（255度）、冬至（270度）、小寒（285度）、大寒（300度）。可以通过下面的儿歌记忆这些节气。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">春雨惊春清谷天，</span><br><span class="line">夏满芒夏暑相连，</span><br><span class="line">秋处露秋寒霜降，</span><br><span class="line">冬雪雪冬小大寒，</span><br><span class="line">每月两节不变更，</span><br><span class="line">最多相差一两天</span><br></pre></td></tr></table></figure><p>2016年11月30日，中国“二十四节气”被正式列入联合国教科文组织人类非物质文化遗产代表作名录。</p><h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><p>农历月份大小、农历闰/平年、二十四节气的日期没有什么特定的规律，只能使用原始的“查表法”存储和查询这些信息。</p><h2 id="2-1-大小月和闰月"><a href="#2-1-大小月和闰月" class="headerlink" title="2.1 大小月和闰月"></a>2.1 大小月和闰月</h2><p>从香港天文台网站可以获取1900 - 2100年的农历信息，每一天包含公历日期、农历日期、星期、节气四项基本信息。日期范围的基本信息如下表：</p><table><thead><tr><th>项目</th><th>起始日</th><th>…</th><th>2100年</th><th>2101年</th><th>…</th><th>截止日</th></tr></thead><tbody><tr><td>公历</td><td>1990年1月31日</td><td>…</td><td>2100年12月31日</td><td>2101年1月1日</td><td>…</td><td>2101年1月28日</td></tr><tr><td>农历</td><td>1900年正月初一</td><td>…</td><td>2100年十二月初一</td><td>2100年十二月初二</td><td>…</td><td>2100年十二月二十九</td></tr><tr><td>offset</td><td>0</td><td>…</td><td>73383</td><td>73384</td><td>…</td><td>73411</td></tr><tr><td>干支</td><td>庚午年丙子月壬辰日</td><td>…</td><td>庚申年戊子月丁未日</td><td>-</td><td>…</td><td>-</td></tr></tbody></table><p>具体到一个农历年中，从中可以看出以下几点信息：</p><ul><li>每个月有多少天；哪些是大月（30天），哪些是小月（29天）</li><li>本年是否有闰月；如果有，是哪个月份</li></ul><p>如何使用精炼的数据结构表述这些信息，是一个重要的前提，主要要求算法简单、内存占用少。网上有许多种方式，一种比较通行的做法是使用5字节的数据，高3位总是“000”，实际使用的低17位二进制。</p><table><thead><tr><th>字段</th><th>闰月大小标志</th><th>月份大小标志</th><th>闰月月份</th></tr></thead><tbody><tr><td>大小</td><td>4b</td><td>12b</td><td>4b</td></tr><tr><td>2017年示例</td><td>0001</td><td>0101 0001 0111</td><td>0110</td></tr><tr><td>描述</td><td>本年有闰月</td><td>2,4,8,10,11,12为大月</td><td>六月是闰月</td></tr><tr><td>2019年示例</td><td>0000</td><td>1010 1001 0011</td><td>0000</td></tr><tr><td>描述</td><td>无闰月</td><td>1,3,5,8,11,12为大月</td><td>无闰月</td></tr></tbody></table><p>综上所述，2017年信息可以使用 0x15176 表示；2019年信息可使用 0x0a930 表示。</p><h2 id="2-2-节气的数据结构"><a href="#2-2-节气的数据结构" class="headerlink" title="2.2 节气的数据结构"></a>2.2 节气的数据结构</h2><p><strong>36位字符串</strong></p><p>二十四节气开始的日期，与通用的公历几乎一致，最多相差一两天，因为是按照地球一年绕太阳公转一周作为依据。比如小寒通常落在在1月5-7日，立春落在2月3-5日，冬至落在12月21-23日。即每个月都会有2个节气，1月只能有小寒、大寒这两个节气。</p><p>构建两个含有24元素的数组，</p><p>第一个数组以小寒为第1个节气重新排列这24个节气。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小寒, 大寒, 立春, 雨水, 惊蛰, 春分, 清明, 谷雨, 立夏, 小满, 芒种, 夏至,</span><br><span class="line">小暑, 大暑, 立秋, 处暑, 白露, 秋分, 寒露, 霜降, 立冬, 小雪, 大雪, 冬至</span><br></pre></td></tr></table></figure><p>第二个数组表示对应节气对应的日期数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 20 4 19 6 21 5 20 6 21 6 22 7 23 8 23 8 23 9 24 8 23 7 22</span><br></pre></td></tr></table></figure><p>结合这两个数组，可记录在一个公历年中，二十四个节气分别是在哪一天。比如上述的24个数字可解释为：1月6日是小寒、1月20日是大寒…12月7日是大雪、12月22日是冬至。</p><p>在 Python 语言层面，可以使用字符串（基本数据类型）代替上述数组（复合数据类型），即<code>&quot;620419621520621622723823823924823722&quot;</code> ，需要36位字符存储。</p><p>解析表中数据的 Python 代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_term</span><span class="params">(year_info)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">36</span>, <span class="number">3</span>):</span><br><span class="line">        s = year_info[i:i + <span class="number">3</span>]</span><br><span class="line">        result.extend([int(s[<span class="number">0</span>]), int(s[<span class="number">1</span>:<span class="number">3</span>])])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>30位字符串</strong></p><p><a href="https://github.com/jjonline/calendar.js" target="_blank" rel="noopener">jjonline/calendar.js</a> 提供了一种用更为简单的表示方法：利用十六进制压缩数字的位数，进一步简化为30位的字符串。具体计算过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">9778397bd097c36b0b6fc9274c91aa  # 按长度5分割，共6组</span><br><span class="line"></span><br><span class="line">97783 97bd0 97c36 b0b6f c9274 c91aa  # 转化为十进制</span><br><span class="line"></span><br><span class="line">620419 621520 621622 723823 823924 823722  # 按长度1,2,1,2细分</span><br><span class="line"></span><br><span class="line">6 20 4 19 6 21 5 20 6 21 6 22 7 23 8 23 8 23 9 24 8 23 7 22</span><br></pre></td></tr></table></figure><p>使用 Python代码实现上述算法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_term</span><span class="params">(term_info)</span>:</span></span><br><span class="line">    values = [str(int(term_info[i:i + <span class="number">5</span>], <span class="number">16</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>)]</span><br><span class="line">    term_day_list = []</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> values:</span><br><span class="line">        term_day_list.extend([</span><br><span class="line">            int(v[<span class="number">0</span>]), int(v[<span class="number">1</span>:<span class="number">3</span>]), int(v[<span class="number">3</span>]), int(v[<span class="number">4</span>:<span class="number">6</span>])</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">return</span> term_day_list</span><br></pre></td></tr></table></figure><p><strong>24位字符串</strong></p><blockquote><p>从 Borax v1.2.0 开始使用算法。</p></blockquote><p>统计1900-2100年之前节气日期统计可知，中气的日期都是在18-24日之间，这些均为两位数，可以通过线性变化转为一位数的数字，结合月份特点，可以通过减去一个固定偏移量15就是比较好的选择。</p><p>同样的按照上述处理，具体过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">654466556667788888998877 # 按长度1分割</span><br><span class="line"></span><br><span class="line">6 5 4 4 6 6 5 5 6 6 6 7 7 8 8 8 8 8 9 9 8 8 7 7 # 增加偏移量，奇位置为0，偶位置为15</span><br><span class="line"></span><br><span class="line">6 20 4 19 6 21 5 20 6 21 6 22 7 23 8 23 8 23 9 24 8 23 7 22</span><br></pre></td></tr></table></figure><p>同样的使用Python 代码如下，和30位表示法相比，更为简单直接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_term_days</span><span class="params">(term_info)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [int(c) + [<span class="number">0</span>, <span class="number">15</span>][i % <span class="number">2</span>] <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(term_info)]</span><br></pre></td></tr></table></figure><h1 id="3-Borax-Lunardate概述"><a href="#3-Borax-Lunardate概述" class="headerlink" title="3 Borax-Lunardate概述"></a>3 Borax-Lunardate概述</h1><p>到2019年1月为止，关于农历的主题，github/PyPI 上已经有非常多的代码项目，语言有C、Java、Python等，具体的思路也不一样。综合来看，这些库有的功能单一，只覆盖某几个方面；有的已经很久没有更新了，主要是农历信息已在多年之前就采集完成，但是对于一些最新的数据修正未能及时涵盖；也有的在代码层面没有很好的适用最新的 Python 语言特性。</p><p>基于此，本人利用收集整理的一些技术资料开发出了 Borax-Lunar 这个库，主要的目标和特点有：</p><ul><li><strong>完整的农历信息</strong></li></ul><p>在开发过程中我收集网络上的几个重要农历数据，包含了干支、生肖、节气等事项，并同时将它们作为数据验证的参考标准。</p><p>另外，一些术语命名（比如天干、地支等）采用 《GB/T 33661-2017 农历的编算和颁行》 所规定的文字。</p><ul><li><strong>功能完备</strong></li></ul><p>Borax-Lunardate 库分为三个部分：1) 基于 <code>LunarDate</code> 的农历日期表示；2）类似于 <code>datetime.strftime</code> 的字符串格式系统；3） 一些常用的农历工具接口。</p><p>其中第2,3部分是网络上的农历库比较少涉及的，Borax-Lunardate 在这一方面非常有优势的。</p><ul><li><strong>对标datetime</strong></li></ul><p>在模块/类层面的组织和分类上，Borax-Lunardate 对标标准库的 <code>datetime</code>  和 <code>calendar</code> 模块，实现了这两个模块中与农历日期相联系的方法，<code>LunarDate</code> 和 <code>date</code> 类有许多相同的特性，包括不可变类、可比较性、时间加减等。 甚至有些命名也是一样的，比如 <code>strftime</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lunardate.LunarDate    &lt;------&gt;   datetime.date</span><br><span class="line"></span><br><span class="line">lunardate.LCalendars   &lt;------&gt;   calendar.Calendar</span><br></pre></td></tr></table></figure><h1 id="4-模块设计"><a href="#4-模块设计" class="headerlink" title="4 模块设计"></a>4 模块设计</h1><h2 id="4-1-LunarDate日期类"><a href="#4-1-LunarDate日期类" class="headerlink" title="4.1 LunarDate日期类"></a>4.1 LunarDate日期类</h2><h3 id="4-1-1-初始化日期对象"><a href="#4-1-1-初始化日期对象" class="headerlink" title="4.1.1 初始化日期对象"></a>4.1.1 初始化日期对象</h3><p><code>LunarDate</code> 是一个重要的类，每一个对象表示一个农历日期，一个特定的农历日期可以由农历年、月、日、闰月标志4个字段唯一确定，可以使用这些字段初始化对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from borax.calendars.lunardate import LunarDate</span><br><span class="line">&gt;&gt;&gt;LunarDate(2018, 7, 1)</span><br><span class="line">LunarDate(2018, 7, 1, 0)</span><br></pre></td></tr></table></figure><p>对于一些特定的日期，也可以通过类方法创建这些日期对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt;LunarDate.today()</span><br><span class="line">LunarDate(2018, 7, 1, 0)</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt;LunarDate.yesterday()</span><br><span class="line">LunarDate(2018, 6, 29, 0)</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt;LunarDate.tomorrow()</span><br><span class="line">LunarDate(2018, 7, 2, 0)</span><br></pre></td></tr></table></figure><h3 id="4-1-2-基准日期"><a href="#4-1-2-基准日期" class="headerlink" title="4.1.2 基准日期"></a>4.1.2 基准日期</h3><p><code>LunarDate</code> 类使用可表示范围的下限作为基准日期（即<code>LunarDate(1990, 1, 1, False)</code>）。对象的 offset 属性表示与基准日期相差的天数，这也是一种可以唯一确定日期的方法。</p><h2 id="4-2-格式化显示"><a href="#4-2-格式化显示" class="headerlink" title="4.2 格式化显示"></a>4.2 格式化显示</h2><p>该功能由 Borax-Lunardate 特有的功能，提供了与 <code>datetime.date.strftime</code> 相似的功能。</p><h3 id="4-2-1-使用方法"><a href="#4-2-1-使用方法" class="headerlink" title="4.2.1 使用方法"></a>4.2.1 使用方法</h3><p><code>LunarDate</code> 提供了 <code>strftime</code> 方法，可以将一个农历日期按照给定的格式转化为字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LunarDate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strftime</span><span class="params">(fmt:str)</span> -&gt; str:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>格式字符串使用 ‘%’ 加一个字母的描述符(Directive)表示日期对象的一个字段，常用的描述符见下表：</p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th><th>示例值</th><th>格式描述符</th><th>备注</th></tr></thead><tbody><tr><td>year</td><td><code>int</code></td><td>农历年</td><td>2018</td><td>%y</td><td></td></tr><tr><td>month</td><td><code>int</code></td><td>农历月</td><td>6</td><td>%m</td><td></td></tr><tr><td>day</td><td><code>int</code></td><td>农历日</td><td>26</td><td>%d</td><td></td></tr><tr><td>leap</td><td><code>bool</code></td><td>是否闰月</td><td>False</td><td>%l</td><td>(1)</td></tr><tr><td>offset</td><td><code>int</code></td><td>距下限的偏移量</td><td>43287</td><td>-</td><td></td></tr><tr><td>term</td><td><code>str</code> 或 <code>None</code></td><td>节气名称</td><td>立秋</td><td>%t</td><td></td></tr><tr><td>cn_year</td><td><code>str</code></td><td>中文年</td><td>二〇一八年</td><td>%Y</td><td>(2)</td></tr><tr><td>cn_month</td><td><code>str</code></td><td>中文月</td><td>六月</td><td>%M</td><td>(2)</td></tr><tr><td>cn_day</td><td><code>str</code></td><td>中文日</td><td>廿六</td><td>%D</td><td>(2)</td></tr><tr><td>gz_year</td><td><code>str</code></td><td>干支年份</td><td>戊戌</td><td>%o</td><td></td></tr><tr><td>gz_month</td><td><code>str</code></td><td>干支月份</td><td>庚申</td><td>%p</td><td></td></tr><tr><td>gz_day</td><td><code>str</code></td><td>干支日</td><td>辛未</td><td>%q</td><td></td></tr><tr><td>animal</td><td><code>str</code></td><td>年生肖</td><td>狗</td><td>%a</td><td></td></tr><tr><td>-</td><td><code>str</code></td><td>两位数字的月份</td><td>06</td><td>%A</td><td></td></tr><tr><td>-</td><td><code>str</code></td><td>两位数字的日期</td><td>26</td><td>%B</td><td></td></tr></tbody></table><p>备注：</p><ul><li>(1) ‘%l’ 将闰月标志格式化为数字，如“0”、“1”</li><li>(2) ‘%Y’、’%M’、’%D’ 三个中文名称不包含“年”、“月”、“日”后缀汉字</li></ul><p>下面是几个使用 <code>strftime</code> 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;today = LunarDate.today()</span><br><span class="line">&gt;&gt;&gt;today.strftime（&apos;%Y-%M-%D&apos;)</span><br><span class="line">&apos;二〇一八-六-廿六&apos;</span><br><span class="line">&gt;&gt;&gt;today.strftime(&apos;今天的干支表示法为：%G&apos;)</span><br><span class="line">&apos;今天的干支表示法为：戊戌年庚申月辛未日&apos;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-源码解析"><a href="#4-2-2-源码解析" class="headerlink" title="4.2.2 源码解析"></a>4.2.2 源码解析</h3><p><code>strftime</code> 的具体实现定义在 <code>lunardate.Formatter</code> 类。该类接受一个 %形式的格式字符串，转化为命名字段形式的格式字符串，并格式化给定的日期对象，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;%Y-%M-%D&apos;  ==&gt;  &apos;&#123;cn_year&#125;-&#123;cn_month&#125;-&#123;cn_day&#125;&apos;  ==&gt; &apos;二〇一八-六-廿六&apos;</span><br></pre></td></tr></table></figure><p>某个字段 field 的具体值，根据下列先后顺序确定具体的值。</p><ul><li><code>Formatter.get_&lt;field&gt;</code></li><li><code>obj.&lt;field&gt;()</code></li><li><code>obj.&lt;field&gt;</code></li></ul><p>核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Formatter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resolve</span><span class="params">(self, obj, field)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            func = getattr(self, <span class="string">'get_'</span> + field)</span><br><span class="line">            <span class="keyword">return</span> func(obj)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            attr = getattr(obj, field)</span><br><span class="line">            <span class="keyword">if</span> callable(attr):</span><br><span class="line">                <span class="keyword">return</span> attr()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> attr</span><br></pre></td></tr></table></figure><h2 id="4-3-类型标注"><a href="#4-3-类型标注" class="headerlink" title="4.3 类型标注"></a>4.3 类型标注</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p><a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener">PEP 484</a> 和 <a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener">PEP526</a> 提供了一种针对 Python 语言的类型标注方法。在 Python3.5+ 以上，可以使用 <code>typing</code> 标准模块实现这一目的，需要说明的是：</p><ul><li><p>方便使用者了解所调用函数的参数类型和返回值类型</p></li><li><p>类型标注不会影响运行，不会抛出异常，只是警告</p></li><li><p>配合IDE的语法语义检查功能，增强智能提示功能</p><p>下面是一个参数和返回值都是字符串的函数标注：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello '</span> + name</span><br></pre></td></tr></table></figure><p>除了一些基本类型，常用的符合数据类型还有 <code>Any</code>、<code>Union</code>、<code>Tuple</code>、<code>List</code>、<code>Callable</code>、<code>TyVar</code>、<code>Generic</code> 等。</p><p>需要注意的是，Python 的语言特性也可能给类型标准的使用带来了一些麻烦，比如变量在使用过程中其类型有所变化。基于目标用户是API使用者，大概可以整理出几条实用的原则：</p><ul><li>只应用在公共接口（类、函数、方法、变量）加上类型标注。</li><li>全局常量不使用类型标注</li><li>魔术方法不使用类型标注</li><li>私有方法可以不使用类型标注</li></ul><h3 id="4-3-2-常用的使用示例"><a href="#4-3-2-常用的使用示例" class="headerlink" title="4.3.2 常用的使用示例"></a>4.3.2 常用的使用示例</h3><p>类型标注学习起来也不困难，掌握几种常见的情形即可。</p><p>使用 <code>:</code>表示参数类型，使用 <code>-&gt;</code> 表示返回值类型，如上述的 <code>greeting</code> 函数 。</p><p>默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg: int = <span class="number">0</span>)</span> -&gt; <span class="keyword">None</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>可选参数，需要使用 <code>Optional</code>，通常和上面的默认参数相互配合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ndays</span><span class="params">(year: int, month: Optional[int] = None, leap: bool = False)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>自定义类型、混合类型，闰月标记可以使用布尔值或者整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Leap = Union[bool, int]</span><br></pre></td></tr></table></figure><p>后向引用，如果使用的类还没有定义，可以使用包含类名的字符串，以便后续实例化。一般用于创建对象的方法或者树形结构的定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LunarDate</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_solar_date</span><span class="params">(cls, year: int, month: int, day: int)</span> -&gt; 'LunarDate':</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>类型绑定。在后向引用的例子中，通常需要在多个地方使用字符串方式，为避免拼写错误，可以使用 <code>TypeVar</code> 的  bound 参数提前预定义。</p><blockquote><p><code>T = TypeVar(&#39;T&#39;, bound=BaseClass)</code> 使用父类创建类型变量以便所有子类均可匹配，这和 Java/C++ 语言中的 <em>多态</em> 相类似。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>, bound=<span class="string">'LunarDate'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LunarDate</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_solar_date</span><span class="params">(cls, year: int, month: int, day: int)</span> -&gt; T:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>迭代器，使用 <code>Iterator</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(n:int)</span> -&gt; Iterator[int]:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure><h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h1><ul><li><a href="http://www.hko.gov.hk/gts/time/conversion.htm" target="_blank" rel="noopener">香港天文台农历信息</a></li><li><a href="https://en.wikipedia.org/wiki/Chinese_calendar" target="_blank" rel="noopener">“农历”维基词条</a></li><li><a href="https://github.com/jjonline/calendar.js" target="_blank" rel="noopener">jjonline/calendar.js</a></li><li><a href="https://github.com/lidaobing/python-lunardate" target="_blank" rel="noopener">lidaobing/python-lunardate</a></li><li><a href="https://stackoverflow.com/questions/33533148/how-do-i-specify-that-the-return-type-of-a-method-is-the-same-as-the-class-itsel" target="_blank" rel="noopener">Forward references - Stackflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简要介绍了我国传统的农历历法知识，并叙述了 Borax-Lunar 工具库开发背后的一些算法原理和技术资料。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="项目" scheme="http://kinegratii.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="农历" scheme="http://kinegratii.github.io/tags/%E5%86%9C%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>WordScapes(纵横填字母)游戏工具</title>
    <link href="http://kinegratii.github.io/2018/10/29/word-scapes-helper-tool/"/>
    <id>http://kinegratii.github.io/2018/10/29/word-scapes-helper-tool/</id>
    <published>2018-10-29T10:54:38.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>WordScapes 是一个有关英文单词的简单游戏，游戏要求从打乱的字母选择若干个组成一系列有效的单词，填入图中的纵横框。</p><p>游戏链接： <a href="https://play.google.com/store/apps/details?id=com.peoplefun.wordcross" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.peoplefun.wordcross</a></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>在玩游戏时，写了一个简单的脚本， 列出从给定的字母中排序组成和合法英文单词。</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/9875406/49424677-48213d00-f7d6-11e8-8bc0-acf41dad27b9.jpg" alt="WordScapes"></p><p>对于该局游戏，依次使用下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python word_scapes.py dvmeo 3</span><br><span class="line">med</span><br><span class="line">emo</span><br><span class="line">doe</span><br><span class="line">mod</span><br><span class="line">ode</span><br><span class="line"><span class="meta">$</span> python word_scapes.py dvmeo 4</span><br><span class="line">dome</span><br><span class="line">move</span><br><span class="line">mode</span><br><span class="line">dove</span><br><span class="line">demo</span><br><span class="line"><span class="meta">$</span> python word_scapes.py dvmeo 5</span><br><span class="line">moved</span><br></pre></td></tr></table></figure><p>需要注意的是，脚本的输出包括了缩略词，但在 WordScapes 中，缩略词不被认为是一个有效的单词。</p><h1 id="2-安装和部署"><a href="#2-安装和部署" class="headerlink" title="2 安装和部署"></a>2 安装和部署</h1><p>脚本仅依赖 拼音检查库 <a href="https://sourceforge.net/projects/pyenchant/" target="_blank" rel="noopener">PyEnchant</a></p><p>需要先安装Enchant，才能再安装 PyEnchant，可以使用下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install enchant</span><br><span class="line">pip install pyenchant</span><br></pre></td></tr></table></figure><p>在 PyEnchant 中最主要的就是 <code>Dict</code> 对象，我们可以使用它来检查单词的拼写是否正确，使用的方式也很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; import enchant</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; d = enchant.Dict("en_US")</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; d.check("Hello")</span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; d.check("Helo")</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h1 id="3-API文档"><a href="#3-API文档" class="headerlink" title="3 API文档"></a>3 API文档</h1><p>该脚本共有两种使用方式。</p><h2 id="方式-1-生成特定长度的英文单词"><a href="#方式-1-生成特定长度的英文单词" class="headerlink" title="方式 1: 生成特定长度的英文单词"></a>方式 1: 生成特定长度的英文单词</h2><p><strong>命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python word_scapes.py LETTERS [LENGTH]</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><code>LENGTH</code> 默认为字母个数</li><li><code>LENGTH</code> 的有效值为 1 ~ 字母个数</li></ul><p><strong>例子</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python word_scapes.py dvmeo</span><br><span class="line">moved</span><br><span class="line"><span class="meta">$</span> python word_scapes.py dvmeo 4</span><br><span class="line">move</span><br><span class="line">dome</span><br><span class="line">demo</span><br><span class="line">mode</span><br><span class="line">dove</span><br></pre></td></tr></table></figure><h2 id="方式-2-生成符合特定模式的单词"><a href="#方式-2-生成符合特定模式的单词" class="headerlink" title="方式 2: 生成符合特定模式的单词"></a>方式 2: 生成符合特定模式的单词</h2><p><strong>命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python word_scapes.py &lt;LETTERS&gt; &lt;PATTERN&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><code>PATTERN</code> 由字母和 <code>*</code> 组成，一个 <code>*</code> 字符代表 <code>LETTERS</code> 中的任意一个字符</li><li><code>PATTERN</code> 参数需要使用 <code>&#39;&#39;</code> 包裹起来</li></ul><p><strong>例子</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python word_scapes.py dvmeo 'm**'</span><br><span class="line">mod</span><br><span class="line">med</span><br><span class="line"><span class="meta">$</span> python word_scapes.py dvmeo '*e*'</span><br><span class="line">med</span><br></pre></td></tr></table></figure><h1 id="4-源代码"><a href="#4-源代码" class="headerlink" title="4 源代码"></a>4 源代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Usage</span></span><br><span class="line"><span class="string">scapes.py arest</span></span><br><span class="line"><span class="string">scapes.py arest 2</span></span><br><span class="line"><span class="string">scapes.py arest '**e**'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> enchant</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_words_with_count</span><span class="params">(letters, count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> permutations(letters, count):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">''</span>.join(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_words_with_pattern</span><span class="params">(letters, pattern)</span>:</span></span><br><span class="line">    random_chars = list(letters)</span><br><span class="line">    random_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> pattern:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'*'</span>:</span><br><span class="line">            random_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                random_chars.remove(c)</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'Invalid letter in pattern: &#123;&#125;'</span>.format(c))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> chars <span class="keyword">in</span> permutations(random_chars, random_count):</span><br><span class="line">        _p = list(pattern)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _i, _c <span class="keyword">in</span> enumerate(_p):</span><br><span class="line">            <span class="keyword">if</span> _c == <span class="string">'*'</span>:</span><br><span class="line">                _p[_i] = chars[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">''</span>.join(_p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_words</span><span class="params">(letters, param)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> param <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> isinstance(param, int):</span><br><span class="line">        g = list_words_with_count(letters, param)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g = list_words_with_pattern(letters, param)</span><br><span class="line"></span><br><span class="line">    d = enchant.Dict(<span class="string">'en_US'</span>)</span><br><span class="line">    word_set = &#123;w <span class="keyword">for</span> w <span class="keyword">in</span> g <span class="keyword">if</span> d.check(w)&#125;</span><br><span class="line">    print(<span class="string">'\n'</span>.join(word_set))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    args = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> len(args) == <span class="number">2</span>:</span><br><span class="line">        letters, param = args</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            param = int(param)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        letters = args[<span class="number">0</span>]</span><br><span class="line">        param = <span class="literal">None</span></span><br><span class="line">    list_words(letters, param)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WordScapes 是一个有关英文单词的简单游戏，游戏要求从打乱的字母选择若干个组成一系列有效的单词，填入图中的纵横框。&lt;/p&gt;
&lt;p&gt;游戏链接： &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.peoplefun.wordcross&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://play.google.com/store/apps/details?id=com.peoplefun.wordcross&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;在玩游戏时，写了一个简单的脚本， 列出从给定的字母中排序组成和合法英文单词。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>poetry 开发工具</title>
    <link href="http://kinegratii.github.io/2018/09/18/poetry-development-tool/"/>
    <id>http://kinegratii.github.io/2018/09/18/poetry-development-tool/</id>
    <published>2018-09-18T13:44:35.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://poetry.eustace.io/" target="_blank" rel="noopener">poetry</a> 是一个 Python 依赖管理和构建、发布的工具。</p><p>在 Python 中，对于初学者来说，打包系统和依赖管理是非常复杂和难懂的。即使对于经验丰富的开发者，一个项目总是要同时创建多个文件： <code>setup.py</code> ,<code>requirements.txt</code>,<code>setup.cfg</code> , <code>MANIFEST.in</code> ，还有最新的 <code>Pipfile</code>。</p><p>基于此， poetry 将所有的配置都放置在一个 toml 文件中，这些配置包括：依赖管理、构建、打包、发布。</p><p>poetry 的灵感来自于其他语言的一些工具： composer(PHP) 和 cargo (Rust) 。</p><a id="more"></a><h2 id="TOML文件与配置"><a href="#TOML文件与配置" class="headerlink" title="TOML文件与配置"></a>TOML文件与配置</h2><p>TOML 的全称是 Tom’s Obvious, Minimal Language 。TOML是前GitHub CEO， Tom Preston-Werner，于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换为一个哈希表(Hash table)。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title</span> = <span class="string">"TOML 例子"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[owner]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"Tom Preston-Werner"</span></span><br><span class="line"><span class="attr">organization</span> = <span class="string">"GitHub"</span></span><br><span class="line"><span class="attr">bio</span> = <span class="string">"GitHub Cofounder &amp; CEO\nLikes tater tots and beer."</span></span><br><span class="line"><span class="attr">dob</span> = <span class="number">1979</span>-<span class="number">05</span>-<span class="number">27</span>T07:<span class="number">32</span>:<span class="number">00</span>Z</span><br><span class="line"></span><br><span class="line"><span class="section">[database]</span></span><br><span class="line"><span class="attr">server</span> = <span class="string">"192.168.1.1"</span></span><br><span class="line"><span class="attr">ports</span> = [ <span class="number">8001</span>, <span class="number">8001</span>, <span class="number">8002</span> ]</span><br><span class="line"><span class="attr">connection_max</span> = <span class="number">5000</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在 Python 中可以使用 <a href="https://github.com/uiri/toml" target="_blank" rel="noopener">toml</a> 库读取和写入配置，该库使用非常方面，拥有和 json 一样的接口。</p><ul><li><code>toml.load(f, _dict=dict)</code></li><li><code>toml.loads(s, _dict=dict)</code></li><li><code>toml.dump(o, f)</code></li><li><code>toml.dumps(o)</code></li></ul><p>在 Python 项目中，可以在根目录 <code>pyproject.toml</code> 定义相关配置，该名称由 <a href="https://www.python.org/dev/peps/pep-0518/#toml" target="_blank" rel="noopener">PEP 518</a> 所规定，可用于一般的开发工具，不仅仅是 poetry 。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p> poetry 由一系列的命令所组成，这些命令能够覆盖项目开发的流程。</p><table><thead><tr><th>名称</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td>new</td><td>创建一个项目脚手架，包含基本结构、pyproject.toml 文件</td><td></td></tr><tr><td>init</td><td>基于已有的项目代码创建 pyproject.toml 文件，支持交互式填写</td><td></td></tr><tr><td>install</td><td>安装依赖库</td><td></td></tr><tr><td>update</td><td>更新依赖库</td><td></td></tr><tr><td>add</td><td>添加一个或多个依赖库</td><td><code>poetry add six pytz</code></td></tr><tr><td>remove</td><td>移除依赖库</td><td></td></tr><tr><td>show</td><td>查看具体依赖库信息，支持显示树形依赖链</td><td><code>poetry show --tree</code></td></tr><tr><td>build</td><td>构建 tar.gz 或 wheel 包</td><td></td></tr><tr><td>publish</td><td>发布到 PyPI</td><td></td></tr><tr><td>run</td><td>运行脚本和代码</td><td><code>poetry run python app.py</code></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>备注：</p><ul><li>和 npm 一样， poetry 将依赖库分为 <code>main</code> 和 <code>dev</code> 两种渠道，使用 <code>poetry add -D pyinstaller</code> 添加为 dev 依赖包</li></ul><p>示例：add 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">F:\ArgonApp&gt;poetry add -D pyinstaller</span><br><span class="line">Using version ^3.4 for pyinstaller</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Package operations: 4 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">  - Installing altgraph (0.16.1)</span><br><span class="line">  - Installing macholib (1.11)</span><br><span class="line">  - Installing pefile (2018.8.8)</span><br><span class="line">  - Installing pyinstaller (3.4)</span><br></pre></td></tr></table></figure><p>查看树形依赖链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pyecharts 0.5.11 Python echarts, make charting easier</span><br><span class="line">|-- future *</span><br><span class="line">|-- jinja2 *</span><br><span class="line">|   `-- markupsafe &gt;=0.23</span><br><span class="line">|-- jupyter-echarts-pypkg 0.1.2</span><br><span class="line">|   |-- lml 0.0.2</span><br><span class="line">|   `-- pyecharts-jupyter-installer 0.0.3</span><br><span class="line">|-- lml 0.0.2</span><br><span class="line">|-- pillow *</span><br><span class="line">`-- pyecharts-javascripthon 0.0.6</span><br><span class="line">    `-- javascripthon &gt;=0.10</span><br><span class="line">        |-- dukpy *</span><br><span class="line">        |-- macropy3 1.1.0b2</span><br><span class="line">        `-- setuptools *</span><br><span class="line">pyinstaller 3.4 PyInstaller bundles a Python application and all its dependencies into a single package.</span><br><span class="line">|-- altgraph *</span><br><span class="line">|-- macholib &gt;=1.8</span><br><span class="line">|   `-- altgraph &gt;=0.15</span><br><span class="line">|-- pefile &gt;=2017.8.1</span><br><span class="line">|   `-- future *</span><br><span class="line">`-- setuptools *</span><br><span class="line">pypiwin32 223</span><br><span class="line">`-- pywin32 &gt;=223</span><br><span class="line">pywin32 223 Python for Window Extensions</span><br><span class="line">pywin32-ctypes 0.2.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://poetry.eustace.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;poetry&lt;/a&gt; 是一个 Python 依赖管理和构建、发布的工具。&lt;/p&gt;
&lt;p&gt;在 Python 中，对于初学者来说，打包系统和依赖管理是非常复杂和难懂的。即使对于经验丰富的开发者，一个项目总是要同时创建多个文件： &lt;code&gt;setup.py&lt;/code&gt; ,&lt;code&gt;requirements.txt&lt;/code&gt;,&lt;code&gt;setup.cfg&lt;/code&gt; , &lt;code&gt;MANIFEST.in&lt;/code&gt; ，还有最新的 &lt;code&gt;Pipfile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;基于此， poetry 将所有的配置都放置在一个 toml 文件中，这些配置包括：依赖管理、构建、打包、发布。&lt;/p&gt;
&lt;p&gt;poetry 的灵感来自于其他语言的一些工具： composer(PHP) 和 cargo (Rust) 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="工具" scheme="http://kinegratii.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Hexo NexT 6升级笔记</title>
    <link href="http://kinegratii.github.io/2018/07/23/migrate-to-hexo-next-6/"/>
    <id>http://kinegratii.github.io/2018/07/23/migrate-to-hexo-next-6/</id>
    <published>2018-07-23T07:18:52.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p> 博客V5.0已发布，参见 <a href="/2019/09/30/blog_upgrade_note/">博客V5.0升级笔记</a> 。</p><h2 id="A-概述"><a href="#A-概述" class="headerlink" title="A 概述"></a>A 概述</h2><p>本文叙述了将 NexT 5.1.0 迁移到 6.3.0 的过程中的一些笔记。使用 NexT 6 的考虑在于：</p><ul><li>优化配置项</li><li>支持 Valine 评论系统</li><li>代码快支持复制功能</li><li>其他从 v5.1.0 起内置的功能</li></ul><a id="more"></a><h2 id="B-准备工作"><a href="#B-准备工作" class="headerlink" title="B 准备工作"></a>B 准备工作</h2><p>如何安装 NexT 6 有多种选择，这里仅介绍的是一种简单机械的方法。</p><ol><li><p><strong>备份</strong> : 将 <em>themes\next</em> 文件夹复制备份到另外一个目录下，然后删除原有的 next 文件夹。</p></li><li><p><strong>下载</strong>：打开 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">代码仓库</a> ，切换到标签 v6.3.0 ，点击 “Download zip” 下载压缩包。</p></li><li><p><strong>替换</strong>: 解压并重名为 next ，放入 <em>themes</em> 目录。</p></li></ol><blockquote><p>在 github 访问缓慢时，与 克隆代码 和 浏览器下载 相比，使用迅雷工具下载会提高不少的速度。</p></blockquote><h2 id="C-迁移步骤"><a href="#C-迁移步骤" class="headerlink" title="C 迁移步骤"></a>C 迁移步骤</h2><h3 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h3><p>通常来说，需要改动一下几个文件：</p><ul><li>博客配置文件 <em>_config.yml</em></li><li>主题配置文件 <em>themes\next_config.yml</em></li><li>语言翻译文件 <em>themes\next\languages\zh-CN.yml</em></li></ul><h3 id="语言-amp-翻译"><a href="#语言-amp-翻译" class="headerlink" title="语言&amp;翻译"></a>语言&amp;翻译</h3><p>在 NexT 6 中，简体中文的名称变为 zh-CN ，因此在 <strong>博客配置文件</strong> 里需要将原有的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><p>另外现在语言文件名称为 <em>zh-CN.yaml</em> ，格式没有变化，可以使用原有的 <em>zh-Hans.yaml</em> 覆盖。</p><h3 id="菜单链接"><a href="#菜单链接" class="headerlink" title="菜单链接"></a>菜单链接</h3><p>NexT 6 将分开的 链接 和 图标 配置合并在了一个配置项中，并使用 || 分割。受这一特性影响，以下配置项目有所变化，需手动修改：</p><ul><li>菜单 theme.menu</li><li>社交 theme.social</li><li>代码Fork theme.github_banner</li></ul><p>Hexo 5 风格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives</span></span><br><span class="line"><span class="attr">  topics:</span> <span class="string">/topics</span></span><br><span class="line"><span class="attr">  library:</span> <span class="string">/library</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  topics:</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  library:</span> <span class="string">book</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">user</span></span><br></pre></td></tr></table></figure><p>Hexo 6 风格：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  topics:</span> <span class="string">/topic/</span> <span class="string">||</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  library:</span> <span class="string">/library/</span> <span class="string">||</span> <span class="string">book</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br></pre></td></tr></table></figure><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>这些配置无任何变化，将配置内容复制到对应选项即可。</p><ul><li>右下角的“回到顶部”按钮</li><li>打赏文字、图片 theme.reward_comment</li><li>网站 icon 图片 theme.favicon</li><li>本地搜索 theme.local_search</li></ul><h2 id="D-插件"><a href="#D-插件" class="headerlink" title="D 插件"></a>D 插件</h2><p>这些功能之前是使用修改源代码方式，现在可以使用 “包/插件引入 + 选项配置” 的方式激活该功能。</p><blockquote><p>插件路径定义在 <em>themes\next\source\lib</em> 目录下。</p></blockquote><table><thead><tr><th>功能</th><th>插件</th><th>引入方式</th><th>配置项</th></tr></thead><tbody><tr><td>字数统计</td><td><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a></td><td>包</td><td>theme.symbols_count_time</td></tr><tr><td>图片浏览</td><td><a href="https://github.com/theme-next/theme-next-fancybox3" target="_blank" rel="noopener">theme-next-fancybox3</a></td><td>插件</td><td>theme.fancybox</td></tr><tr><td>顶部进度条</td><td><a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener">theme-next-pace</a></td><td>插件</td><td>theme.pace</td></tr><tr><td>leancloud访问计数</td><td><a href="https://github.com/theme-next/hexo-leancloud-counter-security" target="_blank" rel="noopener">leancloud-visitors</a></td><td>插件</td><td>theme.leancloud_visitors</td></tr></tbody></table><p><strong>引入方式</strong></p><p>以包方式引入比较简单，使用 命令 <code>npm install &lt;package-name&gt; -save</code> 即可。</p><p>以插件方式引入，在 <em>theme\next</em> 目录使用代码克隆命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;github-url&gt; source\lib\&lt;plugin-name&gt;</span><br></pre></td></tr></table></figure><p><strong>进度条</strong></p><p>进度条使用 <a href="http://github.hubspot.com/pace/" target="_blank" rel="noopener">pace.js</a> 插件，<a href="http://github.hubspot.com/pace/docs/welcome/" target="_blank" rel="noopener">点此</a> 查看每个配置的效果图。</p><h2 id="E-评论系统"><a href="#E-评论系统" class="headerlink" title="E 评论系统"></a>E 评论系统</h2><p>NexT 6 已经集成这个功能了，可以使用和访问量同一个应用。</p><p>1 在云端的 leancloud 应用中创建一个名为 <code>Comment</code> 的类，使用默认的 ACL 权限设置。</p><p>2 在主题配置文件中设置 app_id 和 app_key 即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span>   <span class="comment"># your leancloud application appid</span></span><br><span class="line"><span class="attr">  appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure><h2 id="F-部署"><a href="#F-部署" class="headerlink" title="F 部署"></a>F 部署</h2><p>修改 <em>theme\next.gitignore</em> 文件，将 <em>theme\next\source\lib</em> 下的文件也提交到版本库。</p><p>具体做法是删除以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Ignore optional external libraries</span><br><span class="line">source/lib/*</span><br><span class="line"></span><br><span class="line"># Track internal libraries &amp; Ignore unused verdors files</span><br><span class="line">source/lib/font-awesome/less/</span><br><span class="line">source/lib/font-awesome/scss/</span><br><span class="line">!source/lib/font-awesome/*</span><br><span class="line"></span><br><span class="line">!source/lib/jquery/</span><br><span class="line"></span><br><span class="line">source/lib/ua-parser-js/*</span><br><span class="line">!source/lib/ua-parser-js/dist/</span><br><span class="line"></span><br><span class="line">!source/lib/velocity/</span><br></pre></td></tr></table></figure><h2 id="G-参考资料"><a href="#G-参考资料" class="headerlink" title="G 参考资料"></a>G 参考资料</h2><ul><li><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 博客V5.0已发布，参见 &lt;a href=&quot;/2019/09/30/blog_upgrade_note/&quot;&gt;博客V5.0升级笔记&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;A-概述&quot;&gt;&lt;a href=&quot;#A-概述&quot; class=&quot;headerlink&quot; title=&quot;A 概述&quot;&gt;&lt;/a&gt;A 概述&lt;/h2&gt;&lt;p&gt;本文叙述了将 NexT 5.1.0 迁移到 6.3.0 的过程中的一些笔记。使用 NexT 6 的考虑在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化配置项&lt;/li&gt;
&lt;li&gt;支持 Valine 评论系统&lt;/li&gt;
&lt;li&gt;代码快支持复制功能&lt;/li&gt;
&lt;li&gt;其他从 v5.1.0 起内置的功能&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://kinegratii.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="软件迁移" scheme="http://kinegratii.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>处理和迁移遗留的代码</title>
    <link href="http://kinegratii.github.io/2018/06/27/dealing-with-legacy-code/"/>
    <id>http://kinegratii.github.io/2018/06/27/dealing-with-legacy-code/</id>
    <published>2018-06-27T12:23:56.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>【书名】</strong>：Django Design Patterns and Best Practices</li><li><strong>【主题】</strong>：Dealing with Legacy Code (处理遗留的代码)</li><li><strong>【摘要】</strong>：本文以 Django项目为例子，叙述在处理遗留代码过程中所使用的多项技术。阅读代码库通常是容易被低估的一个基本技能。在实践过程中，我们应当尽可能使用原有的可以运行良好的代码，而不是重复地发明轮子。另外测试案例也是代码编程一个非常重要的组成部分。</li></ul><a id="more"></a><h2 id="A-概述"><a href="#A-概述" class="headerlink" title="A 概述"></a>A 概述</h2><p>参加一个项目的开发是一个令人激动人心的事情，在此过程中你可以了解和使用到一些强大的工具和前沿的技术。然而常常接收的却是一个已经存在的，甚至远古时期的项目。当然，Django 发行仅有十几年（2005年），和其他语言框架相比，算是比较年轻的项目。由于技术的迅速的发展，使用早期 Django 项目是一个巨大的挑战，仅仅使用源码和文档可能是不够的。</p><p>和项目维护相比，项目迁移更多涉及到是系统设计层面的内容，比如：</p><ul><li>使用新版本的语言，比如 从 Python2 迁移到 Python3</li><li>使用新版本的库以具有更好的性能表现</li><li>使用 CBV（类视图） 改写项目中的 CBV （函数视图）</li><li>使用 django-rest-framework 实现项目的 Restful API</li></ul><h2 id="B-Django-版本"><a href="#B-Django-版本" class="headerlink" title="B Django 版本"></a>B Django 版本</h2><p>确定项目使用了哪个版本的 Django 是一个重要的基础步骤。随着 Django 不断发展和完善，一些概念、规范和规则可能有所变化，比如  <em>默认目录结构</em> 和 <em>最佳实践规则</em> 。</p><h3 id="依赖文件"><a href="#依赖文件" class="headerlink" title="依赖文件"></a>依赖文件</h3><p>一般来说，每个项目的根目录会有一个 <em>requirements.txt</em> 或者 <em>setup.py</em> 的文件，表明了这个项目使用了哪些第三方库，它们的版本是多少，通常是类似下面格式的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django=1.11.2</span><br></pre></td></tr></table></figure><p>使用 “=” 描述的依赖，是一个非常精确的版本。与此相对应的是类似 <code>django&gt;=1.8</code> 的形式 ，表示是一个范围， pip 安装时总是以符合该范围的最新版本为准。</p><blockquote><p><strong>延伸</strong> 固定依赖库的版本是一个最佳实践，这样会减少一些意想不到的错误，使得构建过程具有确定性。<a href="https://docs.pipenv.org/" target="_blank" rel="noopener">pipenv</a> 是一个 Python 项目开发构建工具，为项目提供了单独的虚拟环境，使用  Pipfile.lock 文件产生确定性的构建过程。</p></blockquote><p>在现实的项目则往往是没有 <em>requirements.txt</em> 文件或 <em>setup.py</em> 文件，这时候你可能需要尝试其他方式来确定它的 Django 版本。</p><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>在大多情况下，Django 项目可能部署在一个虚拟环境或者携带有构建环境，事实上，这种做法也是一个最佳实践额规则。当你位于一个虚拟环境时，可以按照下面的步骤查询 Django 版本。</p><p>第一步，激活该环境，在 Linux 中可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> source venv_path/bin/activate</span><br></pre></td></tr></table></figure><p>第二步，使用下面的 Python 片段，查询版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; import django</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; django.get_version()</span><br><span class="line">'1.11.1'</span><br></pre></td></tr></table></figure><p>当然除了上述的方法外，也可以直接在 Django 源码查看版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd envs/foo_env/lib/python2.7/site-packages/django</span><br><span class="line"><span class="meta">$</span> cat __init__.py</span><br><span class="line">VERSION = (1, 11, 1, 'final', 0)</span><br></pre></td></tr></table></figure><h3 id="配置模块与Django版本特性"><a href="#配置模块与Django版本特性" class="headerlink" title="配置模块与Django版本特性"></a>配置模块与Django版本特性</h3><p>项目的配置模块是一个项目的重要的模块，它包含了该项目的基本信息和所使用的一些组件、构件、外部资源等。一般来说，配置模块名称为 <em>settings.py</em>。有时根据不同的环境，使用不同的配置，比如一个符合最佳实践的文件布局可能如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fooo/</span><br><span class="line">    Foo/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings/</span><br><span class="line">            __init__.py</span><br><span class="line">            base.py</span><br><span class="line">            dev.py</span><br><span class="line">            prod.py</span><br><span class="line">            test.py</span><br><span class="line">        urls.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><p>使用 <code>django-admin startproject</code> 命令生成的项目，在 <code>settings.py</code> 的顶部含有类似下面的注释文字，清楚地记载了该项目所使用的具体版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Django settings for bws project.</span><br><span class="line"></span><br><span class="line">Generated by &apos;django-admin startproject&apos; using Django 1.8.3.</span><br></pre></td></tr></table></figure><p>当然这只是表明项目创建时的版本，如果在开发过程中，项目有所更新，也可以通过 git 日志来获取版本的变更情况。</p><p>另外的，如果上述的注释被删除的话，需要根据项目的一些特性并结合版本发布日志可以大致确定版本范围。</p><p>下面是一些版本中比较大的变化：</p><table><thead><tr><th>版本</th><th>特性更新</th></tr></thead><tbody><tr><td>1.4 LTS</td><td>新的默认项目文件布局</td></tr><tr><td>1.5</td><td><code>AUTH_PROFILE_MODULE</code> 被废弃，使用 <code>AUTH_USER_MODEL</code></td></tr><tr><td>1.7</td><td>支持数据库迁移，可以使用 <code>migrate</code> 命令</td></tr><tr><td>1.8 LTS</td><td>开始支持 Jinja2 模板引擎。</td></tr><tr><td>2.0</td><td>不再支持 Python2</td></tr></tbody></table><p>Django 的版本发布采用语义化的规范，特性发布以 <em>X.Y</em> 的格式，具体可查看 <a href="https://docs.djangoproject.com/en/2.0/internals/release-process/" target="_blank" rel="noopener">The Release proccess</a>。</p><h2 id="C-阅读代码"><a href="#C-阅读代码" class="headerlink" title="C 阅读代码"></a>C 阅读代码</h2><h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p>和 PHP 不同的是， Python 项目源代码文件不是位于 web 服务器的文档根目录，比如 <em>wwwroot</em> 或 <em>public_html</em> 。将源代码和配置数据放置在公共访问目录之外，web 爬虫程序就无法访问这些文件，提高了安全性。</p><h3 id="入口点-——-路由"><a href="#入口点-——-路由" class="headerlink" title="入口点 —— 路由"></a>入口点 —— 路由</h3><p>通常来说，Python 程序的入口点类似于下面的代码段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>Django 使用的是 “模型 - 模板 - 视图” 的架构模式，简称为 MTV ，是 MVC 的一种变形。在项目中，路由 是一个很好的入口点，包含了从每个请求到响应的映射。代码上可能为一个模块文件(Module)，复杂的情况下也可能是一个包(Package)。但无论何种情况，总是存在 <em>根路由</em> ，并且定义在项目配置模块中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROOT_URLCONF = <span class="string">'projectname.urls'</span></span><br></pre></td></tr></table></figure><p>在 Linux 中，可以使用下面的命令寻找和定位 根路由：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> find . -iname settings.py -exec grep -H 'ROOT_URLCONF' &#123;&#125; \;</span><br><span class="line">./projectname/settings.py:ROOT_URLCONF = 'projectname.urls'</span><br><span class="line"><span class="meta">$</span> ls projectname/urls.py</span><br><span class="line">projectname/urls.py</span><br></pre></td></tr></table></figure><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><strong>代码本身以及测试案例是了解代码的最好的方法。</strong> 对于遗留的代码，旧有的文档可能会与之相匹配，但有时也无法覆盖未来的问题。</p><p>Django 的官方文档位于 <a href="https://www.djangoproject.com" target="_blank" rel="noopener">https://www.djangoproject.com</a> 。在右下角可以切换到不同的版本。</p><h3 id="应用逻辑与可视化"><a href="#应用逻辑与可视化" class="headerlink" title="应用逻辑与可视化"></a>应用逻辑与可视化</h3><p>图表是了解一个了解程序最好的方法。</p><p><a href="https://github.com/django-extensions/django-extensions" target="_blank" rel="noopener">django-command-extensions</a> 是一个工具扩展包，提供了 <em>graph_models</em> 命令，可以用图表的方式显示所有数据模型及其之间的关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python manage.py graph_models -a -o myapp_models.png</span><br></pre></td></tr></table></figure><p>在 PyCharm IDE 中也有类似的功能。右键选择模型文件 <em>models.py</em>，依次选择下面的菜单项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Diagrams -&gt; Show Diagram -&gt; Django Model Dependency Diagram</span><br></pre></td></tr></table></figure><p>需要注意的是，图中的 <code>str</code> 是 <code>settings.AUTH_USER_MODEL</code> 指向的模型类。</p><p>显示的图表如下：</p><p><img src="/images/bws-diagram.png" alt="bws-diagram"></p><p>你还可以导出 uml 和 png 等不同的文件格式。</p><h2 id="D-增量变化-OR-全新重写"><a href="#D-增量变化-OR-全新重写" class="headerlink" title="D 增量变化 OR 全新重写"></a>D 增量变化 OR 全新重写</h2><blockquote><p>代码是一个债务，而不是一个资产，更少的代码具有更好的可维护性。</p></blockquote><p>在最好的情况下，遗留的代码，总是我们所期望的：</p><ul><li>拥有测试代码</li><li>良好的文档</li><li>平稳地迁移新环境</li></ul><p>在最坏的情况下，可能更希望放弃现有的代码，并且开始重新开始新的编码工作。</p><p>在具体工作的过程中，应当根据具体的情况，比如项目进度、时间要求、业务逻辑等不同因素采取不同的策略。</p><p>有时候，在重写的过程中，应用（业务）领域的复杂度将是一个巨大的障碍。这是因为在编写旧有代码过程中所学习的大量的知识可能会遗失。特别的是，代码逻辑设计差以至于很难从中了解具体的业务逻辑。</p><p>最差的重写是转换，比如将原来的 PHP 项目使用 Python 语言重写，在此过程中很可能会丢失原有 PHP 语言的一些最佳实践规则。</p><h2 id="E-特征测试"><a href="#E-特征测试" class="headerlink" title="E 特征测试"></a>E 特征测试</h2><blockquote><p>编写测试案例应当在作任何改变之前。</p></blockquote><p>使用测试，我们可以非常容易和正确地修改已有代码的行为。没有测试，则不可能知道我们的改变让代码变得更好还是更差。</p><p>特征测试描述了系统当前的实际行为。这是使用的一些步骤：</p><ol><li>在测试用具中使用目标代码快</li><li>编写一个你会知道失败的断言</li><li>从失败的断言中知道代码的行为</li><li>修改测试，让它预期目标代码块的实际行为</li><li>重复上述步骤</li></ol><p>当准备在遗留系统中使用一个方法之前，请查看一下是否已有针对它的测试，没有的话就自己写一个，始终保持这一习惯，你的测试就能起到信息传递媒介的作用。别人只要一看到你的测试就能够知道对于某方法他们该期望什么而不该期望什么，试图使一个类变得可测试这一行为本身往往能够改善代码的质量，于是人们能够发现什么是可行的，以及是如何可行的，他们可以进行修改，更正BUG，然后继续前进。</p><h2 id="F-数据库"><a href="#F-数据库" class="headerlink" title="F 数据库"></a>F 数据库</h2><p>在 Django 中，可以使用下面的命令导入旧有的数据库结构。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python manage.py inspectdb &gt; models.py</span><br></pre></td></tr></table></figure><p>以上命令会根据配置模块的配置内容生成 Python 代码，这些代码通常位于 <em>models.py</em> 文件。</p><p>这里有一些最佳实践规则：</p><ul><li>了解 Django ORM 的一些限制，比如不支持多字段主键、NoSQL数据库等。</li><li>清理代码，比如移除不必要的 ID 字段，Django 将会自动创建。</li><li>外键处理，在某些数据库中，原始生成的外键可能是使用整数类型定义的。</li><li>模块划分，将其分散在不同的 APP 以符合具体的业务逻辑</li><li>在迁移的过程中，会创建额外的数据表，比如 django_* 等数据表</li></ul><h2 id="G-参考资料"><a href="#G-参考资料" class="headerlink" title="G 参考资料"></a>G 参考资料</h2><ul><li><a href="https://docs.djangoproject.com/en/2.0/howto/upgrade-version/" target="_blank" rel="noopener">Upgrading Django to a newer version</a></li><li><a href="https://www.revsys.com/tidbits/recommended-django-project-layout/" target="_blank" rel="noopener">Recommended Django Project Layout</a></li><li><a href="https://www.artima.com/weblogs/viewpost.jsp?thread=198296" target="_blank" rel="noopener">Working Effectively With Characterization Tests</a></li><li>《修改代码的艺术》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;【书名】&lt;/strong&gt;：Django Design Patterns and Best Practices&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【主题】&lt;/strong&gt;：Dealing with Legacy Code (处理遗留的代码)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【摘要】&lt;/strong&gt;：本文以 Django项目为例子，叙述在处理遗留代码过程中所使用的多项技术。阅读代码库通常是容易被低估的一个基本技能。在实践过程中，我们应当尽可能使用原有的可以运行良好的代码，而不是重复地发明轮子。另外测试案例也是代码编程一个非常重要的组成部分。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://kinegratii.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Django" scheme="http://kinegratii.github.io/tags/Django/"/>
    
      <category term="软件工程与实践" scheme="http://kinegratii.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Django2.1新功能笔记</title>
    <link href="http://kinegratii.github.io/2018/06/19/feature-note-for-django-21/"/>
    <id>http://kinegratii.github.io/2018/06/19/feature-note-for-django-21/</id>
    <published>2018-06-19T12:25:50.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>2018年8月1日，Django 2.1 正式版发布。</p><p>2018年7月18日，Django 2.1 RC 1发布。</p><p>2018年6月18日，Django 发布 2.1Beta1，这是 2.1 系列的第一个公测版本，正式版预计于8月初发布。</p><p>本文仅列出一些比较重要的改变，具体可详见 <a href="https://docs.djangoproject.com/en/2.1/releases/2.1/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.1/releases/2.1/</a> 。</p><a id="more"></a><h2 id="1-Python-版本支持"><a href="#1-Python-版本支持" class="headerlink" title="1 Python 版本支持"></a>1 Python 版本支持</h2><p>Python 版本要求 3.5+ ，不再支持 3.4 。</p><h2 id="2-查看-view-权限"><a href="#2-查看-view-权限" class="headerlink" title="2 查看(view)权限"></a>2 查看(view)权限</h2><p>Django 2.1 新增了 <strong>查看(View)</strong> 权限。至此 Django 的模型默认有四种权限：</p><table><thead><tr><th>权限</th><th>Code</th></tr></thead><tbody><tr><td>增加（Add）</td><td><code>&lt;app_label&gt;.add_&lt;modelname&gt;</code></td></tr><tr><td>删除（Delete）</td><td><code>&lt;app_label&gt;.delete_&lt;modelname&gt;</code></td></tr><tr><td>修改（Change）</td><td><code>&lt;app_label&gt;.change_&lt;modelname&gt;</code></td></tr><tr><td>查看（View）</td><td><code>&lt;app_label&gt;.view_&lt;modelname&gt;</code></td></tr></tbody></table><p>正好和数据库原子操作 “CURD” 一一对应。需要注意的是，<strong>一个用户具有修改权限，自然也具查看权限。</strong> 这既符合实际逻辑，又保证了旧有版本的兼容性。</p><h3 id="has-view-permission函数"><a href="#has-view-permission函数" class="headerlink" title="has_view_permission函数"></a>has_view_permission函数</h3><p>在 Admin 中新增了函数  <code>ModelAdmin.has_view_permission()</code> ，控制用户是否具有可读权限。函数签名为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModelAdmin.has_view_permission(request:HttpRequest, obj:Model=None) -&gt; bool</span><br></pre></td></tr></table></figure><p>该函数应当返回一个布尔值，表明 查看某个具体的模型对象 obj 的操作是否被允许。如果 obj 为 None ，则表示 该模型类型的所有对象的查看操作是否被允许。</p><p>默认实现上，如果一个用户具有 “Change” 或 “View” 权限，则返回 True 。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>因为新的查看权限的权限码（code）使用了 <code>&lt;app_label&gt;.view_&lt;modelname&gt;</code> 的格式，因此如果之前你将该权限码用于自定义的权限并且和查看权限有冲突时，应当更新自己定义的权限的权限码。</p><p>另外，如果之前使用了 <a href="https://github.com/ctxis/django-admin-view-permission" target="_blank" rel="noopener">django-admin-view-permission</a> 库，可能需要花费一定的时间完成整合工作。</p><h2 id="3-Cookie-的-SameSite-配置"><a href="#3-Cookie-的-SameSite-配置" class="headerlink" title="3 Cookie 的 SameSite 配置"></a>3 Cookie 的 SameSite 配置</h2><p><a href="https://www.owasp.org/index.php/SameSite" target="_blank" rel="noopener">SameSite-cookies</a> 是一种安全机制，用于定义cookie如何跨域发送。SameSite-cookies的目的是尝试阻止CSRF（Cross-site request forgery 跨站请求伪造）以及XSSI（Cross Site Script Inclusion (XSSI) 跨站脚本包含）攻击。</p><p>配置模块新增 <em>SESSION_COOKIE_SAMESITE</em> 和 <em>CSRF_COOKIE_SAMESITE</em> 项，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SESSION_COOKIE_SAMESITE = <span class="string">'Lax'</span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_SAMESITE = 'Strict'</span></span><br><span class="line"><span class="comment"># SESSION_COOKIE_SAMESITE = None</span></span><br><span class="line"></span><br><span class="line">CSRF_COOKIE_SAMESITE = <span class="string">'Lax'</span></span><br></pre></td></tr></table></figure><p>可选的值有三种（请注意下首字母大写）：</p><p>(1) “Strict”： 表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。</p><p>举个例子，如果 Github 网站设置了这个值之后，已登录的用户点击协作邮件讨论中私有项目的链接，浏览器将不会接受 Cookie ，用户也将不能访问该项目主页。</p><p>(2) “Lax”：在安全性和使用性之间作了一个平衡。属性只会在使用危险HTTP方法发送跨域cookie的时候进行阻止，例如POST方式。</p><p>(3) None：禁用该特性。</p><h2 id="4-用户-权限-动作"><a href="#4-用户-权限-动作" class="headerlink" title="4 用户 - 权限 - 动作"></a>4 用户 - 权限 - 动作</h2><p><img src="/images/user-permission-action.png" alt="user-permission-action"></p><p>文档： <a href="https://docs.djangoproject.com/en/2.1/ref/contrib/admin/actions/#setting-permissions-for-actions" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.1/ref/contrib/admin/actions/#setting-permissions-for-actions</a></p><p>和模型一样，动作也拥有权限配置了，可以限制只有某些权限的用户使用该动作。例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_published</span><span class="params">(modeladmin, request, queryset)</span>:</span></span><br><span class="line">    queryset.update(status=<span class="string">'p'</span>)</span><br><span class="line">make_published.allowed_permissions = (<span class="string">'change'</span>,)</span><br></pre></td></tr></table></figure><p><code>make_published()</code> 仅对那些通过了 <code>ModelAdmin.has_change_permission()</code> 检测的用户可用。</p><p>在具体表现形式上，如果一个用户没有 change 权限，在对象列表页面的动作下拉菜单不会显示 “make_published” 项目。</p><p><code>allowed_permissions</code> 中的多个权限是 “或” 的关系，只要通过任何一个即可，用户就可以使用该 动作（Action）。</p><h2 id="5-模型初始化"><a href="#5-模型初始化" class="headerlink" title="5 模型初始化"></a>5 模型初始化</h2><p>模型类支持 <code>__init_subclass__</code> 函数重写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class QuestBase:</span><br><span class="line">...    # this is implicitly a @classmethod (see below for motivation)</span><br><span class="line">...    def __init_subclass__(cls, swallow, **kwargs):</span><br><span class="line">...        cls.swallow = swallow</span><br><span class="line">...        super().__init_subclass__(**kwargs)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class Quest(QuestBase, swallow=&quot;african&quot;):</span><br><span class="line">...    pass</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Quest.swallow</span><br><span class="line">&apos;african&apos;</span><br></pre></td></tr></table></figure><p>这个特性提供了 metaclass 处理复杂类继承的另一种解决方案。当一个类需要使用两个以上的元类（Metaclass）时，需要手动创建一个新的 元类 以合并这几个元类。现在可以重写 <code>__init_subclass__</code> 来自定义类的创建流程，而无需创建用于合并的元类。</p><p>一般来说，这个特性很少会用得到。，相关内容 参见 <a href="https://www.python.org/dev/peps/pep-0487/" target="_blank" rel="noopener">PEP 487</a>。</p><h2 id="6-验证类视图"><a href="#6-验证类视图" class="headerlink" title="6 验证类视图"></a>6 验证类视图</h2><p>文档： <a href="https://docs.djangoproject.com/en/2.1/topics/auth/default/#all-authentication-views" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.1/topics/auth/default/#all-authentication-views</a></p><p><code>contrib.auth</code> （用户验证登录模块）的函数视图 <em>被移除</em> (Removed)，可以使用对应的类视图，比如 <code>contrib.auth.views.LoginView</code> 类。在更新到 Django 2.1 时，必须完成这一个改变。</p><p>比如函数视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> views <span class="keyword">as</span> auth_views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r'^login/$'</span>, auth_views.login, &#123;<span class="string">'template_name'</span>: <span class="string">'accounts/login.html'</span>&#125;, name=<span class="string">'account_login'</span>),</span><br><span class="line">    re_path(<span class="string">r'^logout/$'</span>, auth_views.logout, &#123;<span class="string">'template_name'</span>: <span class="string">'accounts/logout.html'</span>&#125;, name=<span class="string">'account_logout'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以改写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> views <span class="keyword">as</span> auth_views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r'^login/$'</span>, auth_views.LoginView.as_view(), &#123;<span class="string">'template_name'</span>: <span class="string">'accounts/login.html'</span>&#125;, name=<span class="string">'account_login'</span>),</span><br><span class="line">    re_path(<span class="string">r'^logout/$'</span>, auth_views.LogoutView.as_view(), &#123;<span class="string">'template_name'</span>: <span class="string">'accounts/logout.html'</span>&#125;, name=<span class="string">'account_logout'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="7-模型字段"><a href="#7-模型字段" class="headerlink" title="7 模型字段"></a>7 模型字段</h2><h3 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h3><p><code>BooleanField</code> 允许 <code>null=True</code> 的设置，用以替代 <code>NullBooleanField</code> 的功能，这也意味着后者可能在未来的版本中移除。</p><h3 id="JSONField"><a href="#JSONField" class="headerlink" title="JSONField"></a>JSONField</h3><p><code>django.contrib.postgres.fields.JSONField</code> 查询严格区分以下两种 “空值” 形式：</p><ul><li>键 key 的值为 null ： 使用 <code>Q(key=None)</code></li><li>缺少键 key ：使用 <code>Q(key__isnull=True)</code></li></ul><blockquote><p>这个特性和之前有所变化，并且是第一次完整的列在文档中，因此需要按照最新的文档来检视现有的代码。</p></blockquote><h2 id="8-数据库查询高级特性"><a href="#8-数据库查询高级特性" class="headerlink" title="8 数据库查询高级特性"></a>8 数据库查询高级特性</h2><p>文档 <a href="https://docs.djangoproject.com/en/2.1/ref/models/database-functions" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.1/ref/models/database-functions</a></p><p>2.1 新增了一系列的文本数据库函数，包含了 Chr, Left, LPad, LTrim, Ord, Repeat, Replace, Right, RPad, RTrim, and Trim 。</p><p>Django 数据库查询的高级特性通常包括：</p><ul><li>自定义 Lookup</li><li>查询表达式</li><li>条件表达式</li><li>数据库函数</li></ul><p>自 1.8 以来，Django 在数据库查询支持方面越来越完善，每个版本都会有新的类和函数被添加进来，使用这些特性的优点在于：</p><ul><li>将复杂的数据处理放在数据库层，符合 web 开发的最佳实践</li><li>可以适应于不同的数据库类型</li><li>避免多线程下的 <em>竞态条件</em> 问题</li></ul><p>这些特性通常是业务相关的，可以使用 <code>extra</code> 和 <code>raw</code> 这两个原始 SQL 调用函数。</p><p>一般来说，如果现有代码可以正常工作，可以不必立即使用这些新特性。</p><h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9 其他"></a>9 其他</h2><ul><li>基于内存的缓存使用 LRU 选择算法，而不是之前的 伪随机算法。</li><li>默认的 jQuery 版本从 2.3.3 更新至 3.3.1</li></ul><h2 id="10-参考文档"><a href="#10-参考文档" class="headerlink" title="10 参考文档"></a>10 参考文档</h2><ul><li><a href="http://www.cnblogs.com/ziyunfei/p/5637945.html" target="_blank" rel="noopener">SameSite Cookie，防止 CSRF 攻击</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年8月1日，Django 2.1 正式版发布。&lt;/p&gt;
&lt;p&gt;2018年7月18日，Django 2.1 RC 1发布。&lt;/p&gt;
&lt;p&gt;2018年6月18日，Django 发布 2.1Beta1，这是 2.1 系列的第一个公测版本，正式版预计于8月初发布。&lt;/p&gt;
&lt;p&gt;本文仅列出一些比较重要的改变，具体可详见 &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/releases/2.1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.djangoproject.com/en/2.1/releases/2.1/&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Django" scheme="http://kinegratii.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>我的 Python 第三方库</title>
    <link href="http://kinegratii.github.io/2018/06/10/my-python-packages-and-libraries/"/>
    <id>http://kinegratii.github.io/2018/06/10/my-python-packages-and-libraries/</id>
    <published>2018-06-10T12:37:33.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>自己常用的 Python 第三方库。</p><a id="more"></a><h2 id="six"><a href="#six" class="headerlink" title="six"></a>six</h2><blockquote><p>2 x 3 = 6</p></blockquote><ul><li>地址： <a href="https://pythonhosted.org/six/" target="_blank" rel="noopener">https://pythonhosted.org/six/</a></li></ul><p>Python2和3的兼容库。</p><h2 id="wheel-twine"><a href="#wheel-twine" class="headerlink" title="wheel / twine"></a>wheel / twine</h2><p>第三方库 <strong>构建 - 分发</strong> 工具。</p><p>使用姿势： github + travis CI + wheel + twine ，参考  <a href="https://kinegratii.github.io/2017/04/25/python-project-ci-publish/">python项目持续集成与包发布</a> 。</p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p>地址：<a href="https://www.djangoproject.com/" target="_blank" rel="noopener">https://www.djangoproject.com/</a></p><p>Python web 领域两大框架之一，遵循 “大而全”、“开箱即用”的原则和规范。Django 源代码内部耦合度高、文档齐全、使用者众多。</p><p>在实际业务开发方面，有非常多的第三方库可以使用，具体可参见 <a href="https://djangopackages.org/" target="_blank" rel="noopener">Django Packages</a> 和 <a href="http://awesome-django.com/" target="_blank" rel="noopener">Awesome Django</a>。</p><p>使用姿势： Python 3.6 + Django 2.0</p><h2 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h2><p>地址：<a href="http://graphviz.org/" target="_blank" rel="noopener">http://graphviz.org/</a></p><p>图形可视化软件，支持 dot 格式文件。</p><h2 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h2><p>文档生成工具，使用 reStructuredText 作为标记语言，同时具有以下优点（引用自 <a href="http://sphinx-doc-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">中文官方网站</a>）：</p><ul><li>丰富的输出格式: HTML (包括M$帮助), LaTeX (为PDF输出), manual pages(man), 纯文本</li><li>完备的交叉引用: 语义化的标签,并对 函式,类,引文,术语以及类似片段消息可以自动化链接</li><li>明晰的分层结构: 轻松定义文档树,并自动化链接同级/父级/下级文章</li><li>美观的自动索引: 可自动生成美观的模块索引</li><li>精确的语法高亮: 基于 Pygments 自动生成语法高亮</li><li>开放的扩展: 支持代码块的自动测试,自动包含Python 的模块自述文档,等等</li></ul><p>使用姿势：  github + sphinx + readthedocs</p><h2 id="click"><a href="#click" class="headerlink" title="click"></a>click</h2><p>地址： <a href="https://github.com/pallets/click" target="_blank" rel="noopener">https://github.com/pallets/click</a></p><p>命令行工具，Pallets 出品。最大的特点是使用 <em>装饰器</em> 实现命名格式，和 argparse 相比，更加地 “所见即所用”。</p><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--count', default=1, help='Number of greetings.')</span></span><br><span class="line"><span class="meta">@click.option('--name', prompt='Your name',</span></span><br><span class="line">              help=<span class="string">'The person to greet.'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(count, name)</span>:</span></span><br><span class="line">    <span class="string">"""Simple program that greets NAME for a total of COUNT times."""</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(count):</span><br><span class="line">        click.echo(<span class="string">'Hello %s!'</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    hello()</span><br></pre></td></tr></table></figure><h2 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h2><p>地址：<a href="http://construct.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://construct.readthedocs.io/en/latest/</a></p><p>一个声明式(declarative)、对称式（symmetrical）二进制解析和构建工具，适用于建立大型复杂应用程序的通信协议。</p><p>第一，功能强大。能够解决的该领域的大多数问题，并且性能表现良好。</p><p>第二，通常应用于项目级，在总体设计、技术选型的步骤。如果只有一两个功能点使用到，就不要使用该库，“杀鸡焉用牛刀”。</p><p>第三，入门/学习比较难，它引入很多的自有概念，并且一系高级功能需要通读源码。</p><p>第四，在代码方面使用了很多 Python 技巧，比如 元类、魔术方法、设计模式等，源码非常值得学习。</p><h2 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h2><p><img src="/images/pyinstaller-draft1c-header-trans.png" alt="PyInstaller"></p><p>地址：<a href="http://www.pyinstaller.org/" target="_blank" rel="noopener">http://www.pyinstaller.org/</a></p><p>之前使用过几个打包工具（py2exe、cx_freeze），还是 PyInstaller 比较好用。程序打包主要难点在于：</p><ul><li>含有C扩展的第三方库的打包，比如 Pillow、lxml 。</li><li>数据文件的路径处理</li><li>图标文件</li></ul><p>可以参考 <a href="https://kinegratii.github.io/2016/04/23/python-package/">python打包工具</a> 这篇文章。</p><h2 id="tablib"><a href="#tablib" class="headerlink" title="tablib"></a>tablib</h2><p>地址： <a href="http://docs.python-tablib.org/en/latest/" target="_blank" rel="noopener">http://docs.python-tablib.org/en/latest/</a></p><p>表格型数据的导入/导出/处理库。支持 json/xls/xlsx/yaml/dbf 等多种文件格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = tablib.Dataset(headers=[&apos;First Name&apos;, &apos;Last Name&apos;, &apos;Age&apos;])</span><br><span class="line">&gt;&gt;&gt; map(data.append, [(&apos;Kenneth&apos;, &apos;Reitz&apos;, 22), (&apos;Bessie&apos;, &apos;Monke&apos;, 21)])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print data.json</span><br><span class="line">[&#123;&quot;Last Name&quot;: &quot;Reitz&quot;, &quot;First Name&quot;: &quot;Kenneth&quot;, &quot;Age&quot;: 22&#125;, &#123;&quot;Last Name&quot;: &quot;Monke&quot;, &quot;First Name&quot;: &quot;Bessie&quot;, &quot;Age&quot;: 21&#125;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print data.yaml</span><br><span class="line">- &#123;Age: 22, First Name: Kenneth, Last Name: Reitz&#125;</span><br><span class="line">- &#123;Age: 21, First Name: Bessie, Last Name: Monke&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; data.xlsx</span><br><span class="line">&lt;censored binary data&gt;</span><br></pre></td></tr></table></figure><h2 id="networkx"><a href="#networkx" class="headerlink" title="networkx"></a>networkx</h2><p>地址： <a href="http://networkx.github.io/" target="_blank" rel="noopener">http://networkx.github.io/</a></p><p>网络图的处理库，包含了：</p><ul><li>良好的数据结构</li><li>常用的图算法</li><li>可以与 <a href="https://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a>、<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">ECharts</a> 等配合良好</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/encode/django-rest-framework" target="_blank" rel="noopener">Django Rest Framework</a> - Django的Restful框架。</li><li><a href="https://github.com/bernardopires/django-tenant-schemas" target="_blank" rel="noopener">django-tenant-schemas</a> - 通过PostgreSQL Schemas在Django中实现多租户特性。当初用的时候Django1.7刚刚发布，因为Migrations的缘故，这个库还不支持，只好乖乖的使用1.6了，系统一直运行良好，也就没有必要更新了。</li><li><a href="https://github.com/django-crispy-forms/django-crispy-forms" target="_blank" rel="noopener">django-crispy-forms</a> - 渲染表单用的，支持Bootstrap2/3/4、Foundation、uni-form等UI框架，非常好用基本上一个模板tags或者filter就可实现，不用再在Python代码中写什么 <code>{&#39;class&#39;:&#39;form-control&#39;}</code> 了。Django 1.11 也引入了类似 crispy-form 的<a href="https://docs.djangoproject.com/en/1.11/ref/forms/renderers/" target="_blank" rel="noopener">基于模板的控件渲染</a>  - 目前API还没有稳定下来，估计要等到2.0了。</li><li><a href="https://github.com/mbi/django-simple-captcha" target="_blank" rel="noopener">django-simple-captcha</a> - 非常简单的表单验证码字段，支持随机字符串、算术题和自定义等不同验证方式。</li><li><a href="https://github.com/pyserial/pyserial" target="_blank" rel="noopener">pyserial</a> - Python的串口访问库。</li><li><a href="https://github.com/riptideio/pymodbus" target="_blank" rel="noopener">PyModus</a> Modbus通信协议的Python实现。</li><li><a href="https://github.com/lincolnloop/python-qrcode" target="_blank" rel="noopener">qrcode</a> - Python的生成二维码库，包括命令行工具和代码API。</li><li><a href="http://blog.getpelican.com/" target="_blank" rel="noopener">Pelican</a> - 静态站点生成器，之前博客就是用Pelican构建的，由于在windows上比较麻烦，改成Hexo了。</li><li><a href="http://lxml.de/" target="_blank" rel="noopener">lxml</a> - xml和html解析处理库。</li><li><a href="https://github.com/faucamp/python-gsmmodem" target="_blank" rel="noopener">python-gsmmodem</a> - Python的GSM库，包括收发短信、电话处理等功能，支持常见型号的芯片。</li><li><a href="https://github.com/lidaobing/python-lunardate" target="_blank" rel="noopener">python-lunardate</a> - 纯Python实现的中国农历库。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己常用的 Python 第三方库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://kinegratii.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>圈复杂度和McCabe</title>
    <link href="http://kinegratii.github.io/2018/04/08/cyclomatic-complexity-and-mccabe/"/>
    <id>http://kinegratii.github.io/2018/04/08/cyclomatic-complexity-and-mccabe/</id>
    <published>2018-04-08T11:40:35.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>【书名】</strong>：软件架构——Python语言实现</li><li><strong>【主题】</strong>：圈复杂度</li><li><strong>【摘要】</strong>：圈复杂度（Cyclomatic Complexity）是衡量计算机程序复杂程度的一种措施。它根据程序从开始到结束的线性独立路径的数量计算得来的。在 Python 中可以使用 mccabe 包测量程序的圈复杂度。</li></ul><a id="more"></a><h2 id="1-圈复杂度"><a href="#1-圈复杂度" class="headerlink" title="1 圈复杂度"></a>1 圈复杂度</h2><p>对于没有任何分支的代码，它的圈复杂度为 1 ，意味着代码只有一条路径。例如下面的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>对于有一条分支的代码，它的圈复杂度为 2 ，比如下面递归计算阶乘的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>在 1976 年， Thomas J. McCabe 开发了使用有向图计算复杂的算法。为了得到这个指标，程序控制流程图可以画成一个有向图，其中：</p><ul><li>节点表示一个程序块</li><li>边表示从一个程序块到另一个程序块的控制流</li></ul><p>根据程序的控制图，McCabe 复杂度可以表示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M = E - N + 2P</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>E：边的数量</li><li>N：节点的数量</li><li>P：连接组件的数量</li></ul><h2 id="2-McCabe的使用"><a href="#2-McCabe的使用" class="headerlink" title="2 McCabe的使用"></a>2 McCabe的使用</h2><p>在 Python 中可以使用 McCabe 包测量程序的圈复杂度。它可以当作一个独立的模块，也可以当作程序的一个插件。可以使用 pip 安装模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mccabe</span><br></pre></td></tr></table></figure><h3 id="2-1-作为命令行使用"><a href="#2-1-作为命令行使用" class="headerlink" title="2.1 作为命令行使用"></a>2.1 作为命令行使用</h3><p>和 <code>unittest</code> 、<code>flake8</code> 等工具一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python -m mccabe --min 5 mccabe.py</span><br><span class="line">("185:1: 'PathGraphingAstVisitor.visitIf'", 5)</span><br><span class="line">("71:1: 'PathGraph.to_dot'", 5)</span><br><span class="line">("245:1: 'McCabeChecker.run'", 5)</span><br><span class="line">("283:1: 'main'", 7)</span><br><span class="line">("203:1: 'PathGraphingAstVisitor.visitTryExcept'", 5)</span><br><span class="line">("257:1: 'get_code_complexity'", 5)</span><br></pre></td></tr></table></figure><h3 id="2-2-作为-flake8-插件"><a href="#2-2-作为-flake8-插件" class="headerlink" title="2.2 作为 flake8 插件"></a>2.2 作为 flake8 插件</h3><p>当 flake8 版本在 2.0 以上和 McCabe 已经安装的情况下，该插件可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flake8 --version</span><br><span class="line">2.0 (pep8: 1.4.2, pyflakes: 0.6.1, mccabe: 0.2)</span><br></pre></td></tr></table></figure><p>在命令中使用 <code>--max-complexity</code> 选项即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ flake8 --max-complexity 10 coolproject</span><br><span class="line">...</span><br><span class="line">coolproject/mod.py:1204:1: C901 &apos;CoolFactory.prepare&apos; is too complex (14)</span><br></pre></td></tr></table></figure><p>根据 McCabe 圈复杂度大于 10 ，就认为是 too complex ，需要进行重构以降低复杂度。</p><h2 id="3-程序控制图"><a href="#3-程序控制图" class="headerlink" title="3 程序控制图"></a>3 程序控制图</h2><h3 id="3-1-生成程序控制图"><a href="#3-1-生成程序控制图" class="headerlink" title="3.1 生成程序控制图"></a>3.1 生成程序控制图</h3><p>以上述 <code>factorial</code> 函数代码为例子，将其保存为一个 <em>factorial.py</em> 文件中，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>第一步 使用 <code>python -m mccabe factorial.py -d</code></p><p>输出 dot 文本图形描述语言的有向图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph &#123;</span><br><span class="line">subgraph &#123;</span><br><span class="line">node [shape=circle,label=&quot;If 4&quot;] 2187726207240;</span><br><span class="line">node [shape=circle,label=&quot;3:0: &apos;factorial&apos;&quot;] 2187726207016;</span><br><span class="line">node [shape=circle,label=&quot;Stmt 5&quot;] 2187726207408;</span><br><span class="line">node [shape=point,label=&quot;&quot;] 2187726207296;</span><br><span class="line">node [shape=circle,label=&quot;Stmt 7&quot;] 2187726207520;</span><br><span class="line">2187726207240 -- 2187726207408;</span><br><span class="line">2187726207240 -- 2187726207520;</span><br><span class="line">2187726207016 -- 2187726207240;</span><br><span class="line">2187726207408 -- 2187726207296;</span><br><span class="line">2187726207520 -- 2187726207296;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，Graphviz渲染图片</p><p><a href="http://www.graphviz.org/" target="_blank" rel="noopener">Graphviz</a> 是 AT&amp;T Labs Research开发的图形绘制工具软件.它使用一个特定的DSL(领域特定语言): dot作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。graphviz提供丰富的导出格式，如常用的图片格式，SVG，PDF格式等。</p><p>打开 Graphviz 编辑器，将上述文档保存为 factorial.gv 文档，生成程序控制图。</p><p><img src="/images/factorial.png" alt="factorial.gv"></p><p>第三步，计算 McCabe 复杂度</p><p>根据公式，复杂度： M = 5 - 4 + 2 x 1 = 2</p><h2 id="4-降低复杂度"><a href="#4-降低复杂度" class="headerlink" title="4 降低复杂度"></a>4 降低复杂度</h2><p>使用字典替代复杂的 <em>if-else</em> 分支代码是 Python 中降低复杂度一个有效的方法。</p><p>比如可以将下面的分支代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">'a'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x == <span class="string">'b'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>改为下面的字典映射代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'a'</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">'b'</span>: <span class="number">2</span></span><br><span class="line">    &#125;.get(x, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>复杂度也从 3 降低到 1 。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><ul><li><a href="https://www.amazon.com/Software-Architecture-Python-Balachandran-Pillai/dp/1786468522" target="_blank" rel="noopener">Software Architecture with Python</a></li><li><a href="http://www.aosabook.org/en/index.html" target="_blank" rel="noopener">The Architecture of Open Source Applications</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;【书名】&lt;/strong&gt;：软件架构——Python语言实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【主题】&lt;/strong&gt;：圈复杂度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【摘要】&lt;/strong&gt;：圈复杂度（Cyclomatic Complexity）是衡量计算机程序复杂程度的一种措施。它根据程序从开始到结束的线性独立路径的数量计算得来的。在 Python 中可以使用 mccabe 包测量程序的圈复杂度。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://kinegratii.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件架构" scheme="http://kinegratii.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>django-echarts v0.3 系列发布日志</title>
    <link href="http://kinegratii.github.io/2018/02/25/django-echarts-030-release-note/"/>
    <id>http://kinegratii.github.io/2018/02/25/django-echarts-030-release-note/</id>
    <published>2018-02-25T10:47:04.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文已收录于 <a href="/pyecharts-project/">《pyecharts 开发专辑》</a> 。</p></blockquote><a id="more"></a><h1 id="v0-3-5-发布日志"><a href="#v0-3-5-发布日志" class="headerlink" title="v0.3.5 发布日志"></a>v0.3.5 发布日志</h1><p>django-echarts v0.3.5 于 2018 年 5 月 4 日正式发布。版本日志为：</p><ul><li><code>NamedCharts</code> 命名图表访问改为字典访问方式</li></ul><h1 id="v0-3-4-发布日志"><a href="#v0-3-4-发布日志" class="headerlink" title="v0.3.4 发布日志"></a>v0.3.4 发布日志</h1><p>django-echarts v0.3.4 于 2018 年 4 月 23 日正式发布。版本日志为：</p><ul><li>适配 pyecharts v0.4.x</li><li>发布独立的 <code>borax.fetch</code> 工具包，<code>django_echarts.datasets.fetch</code> 将在 v0.4 后移除</li><li>新增 <code>django_echarts.datasets.NamedCharts</code> 的多图表类，支持图表可命名</li><li>原有的 <code>pyecharts.custom.page.Page</code> 类不再推荐使用</li></ul><h1 id="v0-3-3-发布日志"><a href="#v0-3-3-发布日志" class="headerlink" title="v0.3.3 发布日志"></a>v0.3.3 发布日志</h1><p>django-echarts v0.3.3 于 2018 年 4 月 3 日正式发布。版本日志为：</p><ul><li>发布独立的 <code>fetch</code> 模块文档</li><li>重写 example 项目的部分逻辑</li></ul><h1 id="v0-3-2-发布日志"><a href="#v0-3-2-发布日志" class="headerlink" title="v0.3.2 发布日志"></a>v0.3.2 发布日志</h1><p>django-echarts v0.3.2 于 2018 年 3 月 13 日正式发布。版本日志为：</p><ul><li>移除 Django 的显示依赖</li><li>移除对 <code>numpy.Array</code> 的默认json编码</li></ul><h1 id="v0-3-1-发布日志"><a href="#v0-3-1-发布日志" class="headerlink" title="v0.3.1 发布日志"></a>v0.3.1 发布日志</h1><p>django-echarts v0.3.1 于 2018 年 3 月 8 日正式发布。版本日志为：</p><ul><li>恢复对 Django 1.11 LTS 的支持</li><li>改善 fetch 模块调用方式，<code>ifetch_multiple</code> 函数的关键字参数不再需要重复指定默认值</li><li><code>fetch</code> 模块函数支持自定义 getter 参数</li><li>ECharts 默认版本更新至v4.0.4</li><li>支持 ECharts 4.0 SVG渲染器的配置</li></ul><h2 id="1-fetch-模块改进"><a href="#1-fetch-模块改进" class="headerlink" title="1 fetch 模块改进"></a>1 fetch 模块改进</h2><p>v0.3.1 基于 <a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="noopener">PEP 3102</a> 调整了 <code>fetch</code> 模块所有函数的定义形式。由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifetch_multiple</span><span class="params">(iterable, defaults, getter, *keys)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifetch_multiple</span><span class="params">(iterable, *keys, defaults=None, getter=None)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>其中 <code>default</code> / <code>defaults</code> / <code>getter</code> 三个可选参数均要求以关键字形式传入。</p><p>之前无论是否使用自己的  defaults 均必须传入以符合位置参数的要求，现在无需这种做法。</p><p>之前：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifetch_multiple(DICT_LIST_DATA, &#123;&#125;, <span class="literal">None</span>, <span class="string">'name'</span>, <span class="string">'age'</span>)</span><br></pre></td></tr></table></figure><p>现在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifetch_multiple(DICT_LIST_DATA, <span class="string">'name'</span>, <span class="string">'age'</span>)</span><br></pre></td></tr></table></figure><h2 id="2-增加自定义-getter-回调函数"><a href="#2-增加自定义-getter-回调函数" class="headerlink" title="2 增加自定义 getter 回调函数"></a>2 增加自定义 getter 回调函数</h2><p>一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y, z)</span>:</span></span><br><span class="line">        self._data = &#123;<span class="string">'x'</span>: x, <span class="string">'y'</span>: y, <span class="string">'z'</span>: z&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._data.get(key)</span><br><span class="line"></span><br><span class="line">my_getter = <span class="keyword">lambda</span> item, key: item.get(key)</span><br><span class="line">data_list = [MockItem(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), MockItem(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), MockItem(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">xs, ys, zs = fetch(data_list, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, getter=my_getter)</span><br></pre></td></tr></table></figure><p>getter 必须是一个回调函数，函数符合以下的要求：</p><ul><li>必须含有名称为 <code>item</code> 和 <code>key</code> 的两个参数</li><li>item 表示单个实体类对象；key 表示索引、属性、键值名称</li></ul><h2 id="3-支持-ECharts-SVG-配置"><a href="#3-支持-ECharts-SVG-配置" class="headerlink" title="3 支持 ECharts SVG 配置"></a>3 支持 ECharts SVG 配置</h2><p>django-echarts 新增了一个名为 renderer 的项目配置项，可选值包括 <code>&#39;canvas&#39;</code> 和 <code>&#39;svg&#39;</code> 。</p><p>django-echarts 按照以下顺序选择渲染方式：</p><ul><li>图表属性 <code>Chart.renderer</code></li><li>项目配置的 <code>DJANGO_ECHARTS[‘renderer’]</code> 的设置</li></ul><p>django-echarts 默认使用 canvas 渲染器，可以通过以下方式更改为 svg 渲染。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DJANGO_ECHARTS = &#123;</span><br><span class="line">    <span class="string">'echarts_version'</span>:<span class="string">'4.0.4'</span>,</span><br><span class="line">    <span class="string">'renderer'</span>: <span class="string">'svg'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是只有 echarts_version 大于 4 时，才可以使用 svg 渲染。django-echarts 并不会强制检查这一点，请使用者自行确认。</p><h1 id="v0-3-0-发布日志"><a href="#v0-3-0-发布日志" class="headerlink" title="v0.3.0 发布日志"></a>v0.3.0 发布日志</h1><p>django-echarts v0.3.0 正式发布。该版本将 <strong>仅支持</strong> Python3.5+ 以及 Django2.0+ 的环境，同时该增加了若干个功能特性：</p><ul><li>移除对 Python2 的支持</li><li>新增计数模块 <code>datasets.section_counter</code></li><li>部分函数增加 Key-Only Arguments ( <a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="noopener">PEP 3102</a> ) 限定</li><li>下载命令增加 <code>--fake</code> 选项，支持预览调试</li><li>整合单元测试</li><li>发布数据构建文档</li></ul><!-- more --><h2 id="1-Python3迁移"><a href="#1-Python3迁移" class="headerlink" title="1 Python3迁移"></a>1 Python3迁移</h2><p>django-echarts 使用了更为激进的迁移策略，v0.3之后将仅支持  Python3.5+ 以及 Django2.0+ 的运行环境，不再支持 Python2 ，django-echarts v0.3 将在 Python2 环境中出现语法层面的错误。</p><p>具体来说就是  <a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="noopener">PEP 3102</a> 的应用，在3.X中新增了强制关键字参数传递（Keyword-Only Arguments）中，定义的形式为使用 * 单独占用一个参数，表示之后的参数必须以关键字方式传入参数，否则将引发TypeError异常。</p><p>例子：</p><p>django_echarts.plugins.host.HostStore</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostStore</span><span class="params">(object)</span>:</span></span><br><span class="line">    HOST_DICT = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *, context=None, default_host=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>django_echarts.plugins.store.SettingsStore</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SettingsStore</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *, echarts_settings=None, extra_settings=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>是否使用 Keyword-Only Arguments ，自己根据实际情况总结了一些应用场景。</p><ul><li>函数有两个以上的可选参数（提供了默认参数）</li><li>这些参数的功能意义是平等的，通常可任意调换位置</li></ul><p>比如 django_echarts.datasets.section_counter.BSectionIndex 类的 <code>__init__</code> 就没有使用这个特性，因为 [lower, upper] 更符合实际表达形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSectionIndex</span><span class="params">(BIndex)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lower=None, upper=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="2-计数模块-section-counter"><a href="#2-计数模块-section-counter" class="headerlink" title="2 计数模块 section_counter"></a>2 计数模块 section_counter</h2><p>该模块针对常见的数据计数业务场景进行的封装，该模块基于内置 <code>collections.Counter</code> 模块，并基于此进行了一些扩展。</p><p>BSectionCounter 库用于计算符合一系列条件的数目计数类。</p><p>先看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data_list = list(df[<span class="string">'stars'</span>])</span><br><span class="line">labels = [<span class="string">'00~00'</span>, <span class="string">'01~10'</span>, <span class="string">'11~50'</span>, <span class="string">'51~100'</span>, <span class="string">'101~500'</span>, <span class="string">'501~1000'</span>, <span class="string">'&gt;1000'</span>]</span><br><span class="line">sizes = []</span><br><span class="line">sizes.append(len([pp <span class="keyword">for</span> pp <span class="keyword">in</span> data_list <span class="keyword">if</span> pp == <span class="number">0</span>]))</span><br><span class="line">sizes.append(len([pp <span class="keyword">for</span> pp <span class="keyword">in</span> data_list <span class="keyword">if</span> pp &gt;= <span class="number">1</span> <span class="keyword">and</span> pp &lt;= <span class="number">10</span>]))</span><br><span class="line">sizes.append(len([pp <span class="keyword">for</span> pp <span class="keyword">in</span> data_list <span class="keyword">if</span> pp &gt;= <span class="number">11</span> <span class="keyword">and</span> pp &lt;= <span class="number">50</span>]))</span><br><span class="line">sizes.append(len([pp <span class="keyword">for</span> pp <span class="keyword">in</span> data_list <span class="keyword">if</span> pp &gt;= <span class="number">51</span> <span class="keyword">and</span> pp &lt;= <span class="number">100</span>]))</span><br><span class="line">sizes.append(len([pp <span class="keyword">for</span> pp <span class="keyword">in</span> data_list <span class="keyword">if</span> pp &gt;= <span class="number">101</span> <span class="keyword">and</span> pp &lt;= <span class="number">500</span>]))</span><br><span class="line">sizes.append(len([pp <span class="keyword">for</span> pp <span class="keyword">in</span> data_list <span class="keyword">if</span> pp &gt;= <span class="number">501</span> <span class="keyword">and</span> pp &lt;= <span class="number">1000</span>]))</span><br><span class="line">sizes.append(len([pp <span class="keyword">for</span> pp <span class="keyword">in</span> data_list <span class="keyword">if</span> pp &gt;= <span class="number">1001</span>]))</span><br><span class="line">stargazer_bar = Bar(<span class="string">"stars"</span>, <span class="string">"stars hist graph of users"</span>, width=CHART_WIDTH)</span><br><span class="line">stargazer_bar.add(<span class="string">""</span>, labels, sizes, is_label_show=<span class="literal">True</span>, mark_line=[<span class="string">"average"</span>])</span><br></pre></td></tr></table></figure><p>使用 BSelectionCounter 后，简化为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data_list = list(df[<span class="string">'stars'</span>])</span><br><span class="line">rc1 = BSectionCounter(</span><br><span class="line">    BValueIndex(<span class="number">0</span>),</span><br><span class="line">    BSectionIndex(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    BSectionIndex(<span class="number">11</span>, <span class="number">50</span>),</span><br><span class="line">    BSectionIndex(<span class="number">51</span>, <span class="number">100</span>),</span><br><span class="line">    BSectionIndex(<span class="number">101</span>, <span class="number">500</span>),</span><br><span class="line">    BSectionIndex(<span class="number">501</span>, <span class="number">1000</span>),</span><br><span class="line">    BSectionIndex(<span class="number">1001</span>)</span><br><span class="line">)</span><br><span class="line">labels, sizes = rc1.feed_as_axises(data_list)</span><br><span class="line">stargazer_bar = Bar(<span class="string">"stars"</span>, <span class="string">"stars hist graph of users"</span>, width=CHART_WIDTH)</span><br><span class="line">stargazer_bar.add(<span class="string">""</span>, labels, sizes, is_label_show=<span class="literal">True</span>, mark_line=[<span class="string">"average"</span>])</span><br></pre></td></tr></table></figure><h2 id="3-下载命令支持预览调试"><a href="#3-下载命令支持预览调试" class="headerlink" title="3 下载命令支持预览调试"></a>3 下载命令支持预览调试</h2><p>增加 <code>--fake</code> 后，命令将仅打印出对应文件的下载路径、引用路径、存储位置，而 <strong>不会进行任何实际的下载操作</strong> ，可用于预览调试。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;python manage.py download_echarts_js echarts.min china --fake</span><br><span class="line">[Info] Download Meta for [echarts.min]</span><br><span class="line">        Remote Url: https://cdn.bootcss.com/echarts/3.7.0/echarts.min.js</span><br><span class="line">        Local  Url: /static/echarts/echarts.min.js</span><br><span class="line">        Local Path: E:\projects\django-echarts\example\static\echarts\echarts.min.js</span><br><span class="line">[Info] Download Meta for [china]</span><br><span class="line">        Remote Url: http://echarts.baidu.com/asset/map/js/china.js</span><br><span class="line">        Local  Url: /static/echarts/china.js</span><br><span class="line">        Local Path: E:\projects\django-echarts\example\static\echarts\china.js</span><br></pre></td></tr></table></figure><p>fake 命名灵感来自于 <a href="https://docs.djangoproject.com/en/2.0/ref/django-admin/#cmdoption-migrate-fake" target="_blank" rel="noopener">migrate命令</a> 。</p><h2 id="4-发布数据构建文档"><a href="#4-发布数据构建文档" class="headerlink" title="4 发布数据构建文档"></a>4 发布数据构建文档</h2><p>v0.3.0 开始，有关数据构建的文档将独立出来。一方面，从功能上来说，数据构建模块仅是数据创建和渲染过程中可能使用到的工具性代码，并不是核心功能。</p><p>另一方面，由于该模块的工具特性使其具有更为一般的通用性，因此在后续开发中，有考虑将其纳入 正在编写的 “pyecharts-contrib计划’’之中。</p><blockquote><p>pyecharts-contrib 计划旨在于构建通用、简单的脚手架模板，和提供解决数据可视化领域中一些常见问题的工具集合。使用者可以迅速地基于 contrib 开始新的项目。pyecharts-contrib 将追求遵循<a href="https://docs.python.org/3/tutorial/stdlib.html#tut-batteries-included" target="_blank" rel="noopener">“batteries included” philosophy</a> 。pyecharts-contrib 命名的灵感来自于 <code>django.contrib</code> 。</p><p>目前，该计划正在紧张有序的进行中。</p></blockquote><h2 id="5-其他功能改进"><a href="#5-其他功能改进" class="headerlink" title="5 其他功能改进"></a>5 其他功能改进</h2><p>其他部分功能改进。</p><ul><li><code>FieldValuesQuerySet.fetch_values</code> 类和方法重名为 <code>AxisValuesQuerySet.as_axis_values</code> 更加符合实际意义</li><li>整合测试样例</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文已收录于 &lt;a href=&quot;/pyecharts-project/&quot;&gt;《pyecharts 开发专辑》&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="数据可视化" scheme="http://kinegratii.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="项目" scheme="http://kinegratii.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>你好，2018！</title>
    <link href="http://kinegratii.github.io/2017/12/30/happy-2018/"/>
    <id>http://kinegratii.github.io/2017/12/30/happy-2018/</id>
    <published>2017-12-30T14:17:39.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ____     ___    _    ___</span><br><span class="line">|___ \   / _ \  / |  ( _ )</span><br><span class="line">  __) | | | | | | |  / _ \</span><br><span class="line"> / __/  | |_| | | | | (_) |</span><br><span class="line">|_____|  \___/  |_|  \___/</span><br></pre></td></tr></table></figure><blockquote><p>echo “2018” | figlet</p></blockquote><a id="more"></a><h2 id="2017年技术大事记"><a href="#2017年技术大事记" class="headerlink" title="2017年技术大事记"></a>2017年技术大事记</h2><p>又到了一年总结的时间了，总的来说，2017年是平平淡淡的，按部就班地完成各项任务。</p><p><em>（按时间先后排序）</em></p><ul><li>第一次参加 OSC源创会</li><li>主持并完成公司 NMS v2.0 项目的重构和试运行工作</li><li>维护 HydrantDeviceSystem 项目</li><li>完成个人项目《水资源费征收工作平台》，发布v1.2.X系列版本</li><li>阅读《构建之法》等技术书籍</li><li>加入 <a href="https://github.com/pyecharts" target="_blank" rel="noopener">pyecharts开源项目团队</a></li><li>撰写26篇博客文章</li></ul><h2 id="2017年博客总结"><a href="#2017年博客总结" class="headerlink" title="2017年博客总结"></a>2017年博客总结</h2><p>2017年是博客重建后的第一年，一共写了 26 篇文章，大概每个月写两篇，主要围绕基础技术而展开的。</p><p>按照年份统计数据见下表：</p><table><thead><tr><th>分类</th><th>数目</th><th>占比</th></tr></thead><tbody><tr><td>2017</td><td>26</td><td>68.42%</td></tr><tr><td>2016</td><td>9</td><td>23.69%</td></tr><tr><td>2015</td><td>3</td><td>7.89%</td></tr></tbody></table><p>目前总计达到38篇文章，其中15和16年的文章是从其他地方精选整合而来的，数量相对就比较少了。</p><p>按照分类统计如下表：</p><table><thead><tr><th>分类</th><th>数目</th><th>占比</th></tr></thead><tbody><tr><td>编程</td><td>24</td><td>63.15%</td></tr><tr><td>技术研究</td><td>10</td><td>26.32%</td></tr><tr><td>生活</td><td>4</td><td>10.53%</td></tr></tbody></table><p>使用 <a href="http://echarts.baidu.com/" target="_blank" rel="noopener">Echarts</a> 渲染图表如下：</p><p><img src="/images/blog-catalog-statistics-2017.png" alt="Blog-Catalog"></p><p>目前还是偏重于语言基础技术层次，系统设计和原理性的文章还是偏少。希望自己2018年在这方面需要一定的加强。</p><h2 id="2018年期望与规划"><a href="#2018年期望与规划" class="headerlink" title="2018年期望与规划"></a>2018年期望与规划</h2><ul><li>本职工作</li><li>pyecharts项目 <a href="https://github.com/pyecharts/pyecharts" target="_blank" rel="noopener">https://github.com/pyecharts/pyecharts</a></li><li>django-echarts项目 <a href="https://github.com/kinegratii/django-echarts" target="_blank" rel="noopener">https://github.com/kinegratii/django-echarts</a></li><li>系统架构设计师资格考试 （2018年11月10-11日）</li><li>技术书籍阅读</li><li>继续撰写博客文章，总结工作项目经验</li><li>BWS v2.0 重构工作</li></ul><h2 id="系统架构设计师考试"><a href="#系统架构设计师考试" class="headerlink" title="系统架构设计师考试"></a>系统架构设计师考试</h2><p>考试目标</p><p>系统架构设计师是一个最终确认和评估系统需求，给出开发规范，搭建系统实现的核心构架，并澄清技术细节、扫清主要难点的技术人员。 系统架构设计师考试合格人员能够根据系统需求规格说明书，结合应用领域和技术发展的实际情况，考虑有关约束条件，设计正确、合理的软件架构，确保系统架构具有良好的特性；能够对项目的系统架构进行描述、分析、设计与评估；能够按照相关标准编写相应的设计文档；能够与系统分析师、项目管理师相互协作、配合工作；具有高级工程师的实际工作能力和业务水平。</p><p>考试要求</p><ul><li>（1）掌握计算机硬软件与网络基础知识；</li><li>（2）熟悉信息系统开发过程；</li><li>（3）理解信息系统开发标准、常用信息技术标准；</li><li>（4）熟悉主流的中间件和应用服务器平台；</li><li>（5）掌握软件系统建模、系统架构设计技术；</li><li>（6）熟练掌握信息安全技术、安全策略、安全管理知识；</li><li>（7）了解信息化、信息技术有关法律、法规的基础知识；</li><li>（8）了解用户的行业特点，并根据行业特点架构合适的系统设计；</li><li>（9）掌握应用数学基础知识；</li><li>（10）熟练阅读和正确理解相关领域的英文文献。</li></ul><p>考试科目设置</p><ul><li>（1）信息系统综合知识，考试时间为150分钟，笔试，选择题；</li><li>（2）系统架构设计案例分析，考试时间为90分钟，笔试，问答题；</li><li>（3）系统架构设计论文，考试时间为120分钟，笔试，论文题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; ____     ___    _    ___&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|___ \   / _ \  / |  ( _ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __) | | | | | | |  / _ \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / __/  | |_| | | | | (_) |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|_____|  \___/  |_|  \___/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;echo “2018” | figlet&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://kinegratii.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="里程碑" scheme="http://kinegratii.github.io/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>pyecharts 开发笔记</title>
    <link href="http://kinegratii.github.io/2017/11/23/pyecharts-development-note/"/>
    <id>http://kinegratii.github.io/2017/11/23/pyecharts-development-note/</id>
    <published>2017-11-23T12:53:09.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文已收录于 <a href="/pyecharts-project/">《pyecharts 开发专辑》</a> 。</p></blockquote><p>本文记录了在 pyecharts 开发过程中的一些想法思路和具体问题分析解决的方案。写作本文的目的主要有两个：一是工作总结，每完成一项工作需要静下心来总结工作得失，这就是一种进步和成长；二是技术分享，对于同一个知识和技术，每个人的理解和思考都是不同的，博客提供了一个很好的分享平台。</p><p>本文基于 <a href="https://github.com/chenjiandongx/pyecharts/pull/240" target="_blank" rel="noopener">PR 自定义模板</a> 整理。</p><a id="more"></a><h2 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h2><h3 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h3><p>大约七八月份的时候就尝试了写了 <a href="https://github.com/kinegratii/django-echarts" target="_blank" rel="noopener">django-echarts</a> 这个项目，发现一些细节性问题处理起来不太方便，更为主要的是一个整体的架构没有完整的建立起来。直到十月份的时候才腾下时间思考这个问题。</p><p>因为本人是主要从事 Django 开发的，因此代码风格和思想难免受到 Django 的影响，比如基于类的代码、Mixin模式，还有一些变量命名等等。</p><h3 id="从-OPP-到-OOP"><a href="#从-OPP-到-OOP" class="headerlink" title="从 OPP 到 OOP"></a>从 OPP 到 OOP</h3><p>面向过程和面向对象是两种不同的设计和编码方法。在我看来，虽然二者互有优劣，但并不是排他的。在前期开发过程中，使用面向过程的方法更有助于我们描述功能，把场景活动翻译成程序语言，因为我们自己就是一个过程性的思维，“先做什么，再做什么”。</p><p>随着开发不断推进，我们逐渐了解其内在的联系，抽象出对象、动作、接口等概念，进而能够应用继承、多态等面向对象的思想。</p><p>Python 之所以称之为万能胶水，我觉得一个原因是 Python 在面向过程和面向对象之间切换自由。描述同一语言 Python 不像 Java 那些，一上来就各种类，各种继承。</p><h3 id="规则、公开、API"><a href="#规则、公开、API" class="headerlink" title="规则、公开、API"></a>规则、公开、API</h3><p>这个主要是和 Python 语言特点有关，Python 是比较灵活的。比如 Python 对于属性权限限制是“约定俗称”的。下面的 <code>js_dependencies</code> 属性应当被看成是私有的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chart</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._js_dependencies = &#123;&#125;</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">js_dependencies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._js_dependencies</span><br></pre></td></tr></table></figure><p>但是，你也可以直接使用 <code>chart._js_dependencies</code> 来访问，只不过：</p><ul><li>IDE 可能会发出警告（warnings）</li><li>变更无法预料，从开发者的角度，无需为此语句有效性提供任何保障</li></ul><p>使用 <code>@property</code> 语法公开了该类的一个访问接口。</p><p>当然，何时公开、怎么公开又是另外一个问题了。</p><h3 id="持续开发与废弃策略"><a href="#持续开发与废弃策略" class="headerlink" title="持续开发与废弃策略"></a>持续开发与废弃策略</h3><p>这里的持续性开发指的的公共API的稳定性，更为确切的说是废弃策略。随着项目的不断推进，新代码不断加入，旧代码不断淘汰。但由于开源项目的公开性和考虑其稳定性，无用的代码并总是立即被删除，而是经过一段时间后再删除，在这方面，个人 Django 项目做的比较好，将旧有代码按照淘汰进程分几个等级(<a href="https://docs.djangoproject.com/en/1.11/internals/release-process/#deprecation-policy" target="_blank" rel="noopener">链接</a>) ，我自己在此基础上增加了一个等级：Not Recommend ，通常用于重大变更，涉及到核心代码</p><ul><li>不再推荐使用(Not Recommend)：仅在更新日志和文档中表明</li><li>废弃(Deprecated)：使用 <code>warnings</code> 模块表明</li><li>移除(Removed)：删除相关代码</li></ul><h2 id="功能设计与实现"><a href="#功能设计与实现" class="headerlink" title="功能设计与实现"></a>功能设计与实现</h2><h3 id="html转义与Python实现"><a href="#html转义与Python实现" class="headerlink" title="html转义与Python实现"></a>html转义与Python实现</h3><p>转义字符串（Escape Sequence）也称字符实体(Character Entity)。在HTML中，定义转义字符串的原因有两个：第一个原因是像“&lt;”和“&gt;”这类符号已经用来表示HTML标签，因此就不能直接当作文本中的符号来使用。为了在HTML文档中使用这些符号，就需要定义它的转义字符串。当解释程序遇到这类字符串时就把它解释为真实的字符。在输入转义字符串时，要严格遵守字母大小写的规则。第二个原因是，有些字符在ASCII字符集中没有定义，因此需要使用转义字符串来表示。</p><p>字符串安全</p><p>如果启用了手动转义，按需转义变量就是 <strong>你的</strong> 责任。要转义什么？如果你有 一个 <em>可能</em> 包含 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&amp;</code> 或 <code>&quot;</code> 字符的变量，你必须转义 它，除非变量中的 HTML 有可信的良好格式。转义通过用管道传递到过滤器 <code>|e</code> 来实现: <code></code> 。</p><p>当启用了自动转移，默认会转移一切，除非值被显式地标记为安全的。可以在应用中 标记，也可以在模板中使用 |safe 过滤器标记。这种方法的主要问题是 Python 本 身没有被污染的值的概念，所以一个值是否安全的信息会丢失。如果这个信息丢失， 会继续转义，你最后会得到一个转义了两次的内容。</p><p>显示地标记值安全的有两种方式：</p><ul><li>在模板中使用 <code>safe</code> 过滤器</li><li>传递给模板的值用 <code>Markup</code> 类包裹下</li></ul><p>根据 <a href="http://jinja.pocoo.org/docs/2.10/api/#jinja2.Markup" target="_blank" rel="noopener">官方文档</a> ，<code>Markup</code> 可以无需转义即可标记一个字符串为安全的。这是通过实现 <code>__html__</code> 接口来实现的。<code>Markup</code> 是 <code>unicode</code> 的直接子类，拥有其众多的方法和属性。核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Markup</span><span class="params">(text_type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__html__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>其使用方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; Markup("Hello &lt;em&gt;World&lt;/em&gt;!")</span><br><span class="line">Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!')</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; class Foo(object):</span><br><span class="line">...  def __html__(self):</span><br><span class="line">...   return '&lt;a href="#"&gt;foo&lt;/a&gt;'</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Markup(Foo())</span><br><span class="line">Markup(u'&lt;a href="#"&gt;foo&lt;/a&gt;')</span><br></pre></td></tr></table></figure><blockquote><p>Jinja2 的 <a href="http://docs.jinkan.org/docs/jinja2/api.html#jinja2.Markup" target="_blank" rel="noopener"><code>Markup</code></a> 类至少与 Pylons 和 Genshi 兼容。预计不久更多模板 引擎和框架会采用 <code>__html__</code> 的概念。</p></blockquote><p>Django 目前也支持 <code>__html__</code> 接口协议。其数据实体定义在 <code>django.utils.safestring.SafeData</code> 。源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeData</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__html__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns the html representation of a string for interoperability.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This allows other template engines to understand Django's SafeData.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><h3 id="js-内嵌引入的正则替换"><a href="#js-内嵌引入的正则替换" class="headerlink" title="js 内嵌引入的正则替换"></a>js 内嵌引入的正则替换</h3><p>主要指的是 <code>pyecharts.utils.freeze_js</code> 的原理是先渲染生成 html 文件字符串，再使用正则替换，这在之前是没有问题，引入自定义模板后，模板文件也有可能引用其他文件（如 bootstrap.min.js），这样的话，碰到该行直接出现错误。</p><p>改进的办法是在渲染的过程就根据配置决定是否替换，因此该函数也可移除。</p><h3 id="和-Flask-整合问题"><a href="#和-Flask-整合问题" class="headerlink" title="和 Flask 整合问题"></a>和 Flask 整合问题</h3><blockquote><p>此种方式是整合过程中产生一个代码版本，后来发现会破坏 Flask 原有的功能，因此改写为下一节的代码版本。但此种整合方式也是思考的一个过程，因此没有将此删除。</p></blockquote><p>这是上周末刚刚完成的内容，解决在 Flask 框架中使用模板函数的问题。主要代码摘抄如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jinjia2 <span class="keyword">import</span> Environment <span class="keyword">as</span> BaseEnvironment</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Environment</span><span class="params">(BaseEnvironment)</span>:</span></span><br><span class="line">    <span class="string">"""Works like a regular Jinja2 environment but has some additional</span></span><br><span class="line"><span class="string">    knowledge of how Flask's blueprint works so that it can prepend the</span></span><br><span class="line"><span class="string">    name of the blueprint to referenced templates if necessary.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, **options)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'loader'</span> <span class="keyword">not</span> <span class="keyword">in</span> options:</span><br><span class="line">            options[<span class="string">'loader'</span>] = app.create_global_jinja_loader()</span><br><span class="line">        BaseEnvironment.__init__(self, **options)</span><br><span class="line">        self.app = app</span><br></pre></td></tr></table></figure><p>pyecharts 模板引擎</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jinjia2 <span class="keyword">import</span> Environment</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchartsEnvironment</span><span class="params">(Environment)</span>:</span></span><br><span class="line">    <span class="string">"""Built-in jinja2 template engine for pyecharts</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pyecharts_config=None, *args, **kwargs)</span>:</span></span><br><span class="line">        self._pyecharts_config = pyecharts_config <span class="keyword">or</span> PyEchartsConfig()</span><br><span class="line">        loader = kwargs.pop(<span class="string">'loader'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> loader <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            loader = FileSystemLoader(</span><br><span class="line">                self._pyecharts_config.echarts_template_dir)</span><br><span class="line">        super(EchartsEnvironment, self).__init__(</span><br><span class="line">            keep_trailing_newline=<span class="literal">True</span>,</span><br><span class="line">            trim_blocks=<span class="literal">True</span>,</span><br><span class="line">            lstrip_blocks=<span class="literal">True</span>,</span><br><span class="line">            loader=loader,</span><br><span class="line">            *args,</span><br><span class="line">            **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add PyEChartsConfig</span></span><br><span class="line">        self.globals.update(&#123;</span><br><span class="line">            <span class="string">'echarts_js_dependencies'</span>: echarts_js_dependencies,</span><br><span class="line">            <span class="string">'echarts_js_dependencies_embed'</span>: echarts_js_dependencies_embed,</span><br><span class="line">            <span class="string">'echarts_container'</span>: echarts_container,</span><br><span class="line">            <span class="string">'echarts_js_content'</span>: echarts_js_content,</span><br><span class="line">            <span class="string">'echarts_js_content_wrap'</span>: echarts_js_content_wrap</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>代码解析要点如下：</p><ul><li><code>Flask.Environment</code> 新增了两点扩展：<ul><li>增加了一个必要的 app 成员变量，这是一个 Flask 实例</li><li>同时提供了默认的 loader 。</li></ul></li><li><code>pyecharts.engine.EchartsEnvironment</code> 也有两点扩展：<ul><li>增加了一个可选 pyecharts_config 成员变量</li><li>同时提供了默认的 loader。</li></ul></li></ul><p>整合的目标是实现一个类，使得同时具有以上四个特点。</p><p>主要整合方式：</p><p>第一种：Mixin 方式。这种方式是实现最为简单，但是在此种情况下却无法使用，这是因为二者都重写了 <code>__init__</code> ，都涉及到对象的创建过程，不建议使用。</p><p>第二种是代码混合方式：让一个直接继承 <code>jinja2.Environment</code> ，将另外一个的代码搬入。因为 <code>Flask.Environment</code> 的代码比较少，继承 <code>EchartsEnvironment</code> 是更为优化的。</p><p>下面是使用第二种方式整合的最终代码及其使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ----- Adapter ---------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlaskEchartsEnvironment</span><span class="params">(EchartsEnvironment)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, **kwargs)</span>:</span></span><br><span class="line">        EchartsEnvironment.__init__(self, **kwargs)</span><br><span class="line">        self.app = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---User Code ----</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlask</span><span class="params">(Flask)</span>:</span></span><br><span class="line">    jinja_environment = FlaskEchartsEnvironment</span><br><span class="line">    jinja_options = &#123;<span class="string">'pyecharts_config'</span>: PyEchartsConfig(</span><br><span class="line">        jshost=<span class="string">'https://cdn.bootcss.com/echarts/3.7.2'</span>,</span><br><span class="line">        echarts_template_dir=<span class="string">'templates'</span></span><br><span class="line">    )&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = MyFlask(__name__)</span><br></pre></td></tr></table></figure><p>因为 EchartsEnvironment 显式传入了 loader 参数，抵消了 Environment 类 loader 的重写逻辑。</p><p>目前该代码放在 demo 内，没有整合为 pyecharts 一部分。</p><h3 id="web框架整合优化"><a href="#web框架整合优化" class="headerlink" title="web框架整合优化"></a>web框架整合优化</h3><p>上一节实现有个重大问题，表面上看会覆盖原有模板目录功能，导致必须现实设置 <code>echarts_template_dir</code> 。因此必须继承  <code>flask.templating.Environment</code> 以保全全部功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask.templating <span class="keyword">import</span> Environment</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> HeatMap</span><br><span class="line"><span class="keyword">from</span> pyecharts.engine <span class="keyword">import</span> PyEchartsConfigMixin, ECHAERTS_TEMPLATE_FUNCTIONS</span><br><span class="line"><span class="keyword">from</span> pyecharts.conf <span class="keyword">import</span> PyEchartsConfig</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlaskEchartsEnvironment</span><span class="params">(Environment, PyEchartsConfigMixin)</span>:</span></span><br><span class="line">    pyecharts_config = PyEchartsConfig(</span><br><span class="line">        jshost=<span class="string">'https://cdn.bootcss.com/echarts/3.7.2'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(FlaskEchartsEnvironment, self).__init__(*args, **kwargs)</span><br><span class="line">        self.globals.update(ECHAERTS_TEMPLATE_FUNCTIONS)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlask</span><span class="params">(Flask)</span>:</span></span><br><span class="line">    jinja_environment = FlaskEchartsEnvironment</span><br><span class="line"></span><br><span class="line">app = MyFlask(__name__)</span><br></pre></td></tr></table></figure><p>之后和标准的 Flask 项目一样使用。</p><h3 id="命名借鉴"><a href="#命名借鉴" class="headerlink" title="命名借鉴"></a>命名借鉴</h3><p>比如 <code>Page.from_charts</code> 借鉴了 <code>django.db.models.Manager.from_queryset</code> 。<br>又比如类 Mixin 模式变量方法的命名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">clas DemoMixin(object):</span><br><span class="line">    foo1 = <span class="literal">None</span></span><br><span class="line">    foo2 = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_foo1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.foo1</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_foo2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.foo2</span><br></pre></td></tr></table></figure><h2 id="Python-2-3"><a href="#Python-2-3" class="headerlink" title="Python 2/3"></a>Python 2/3</h2><h3 id="json-dumps-输出结果"><a href="#json-dumps-输出结果" class="headerlink" title="json.dumps 输出结果"></a>json.dumps 输出结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">c = &#123;<span class="string">'date'</span>:<span class="string">'2017-01-01'</span>, <span class="string">'a'</span>:<span class="string">'1'</span>&#125;</span><br><span class="line">data = json.dumps(c, indent=<span class="number">0</span>)</span><br><span class="line">print(len(data))</span><br><span class="line">print(<span class="string">'*'</span>.join(data))</span><br></pre></td></tr></table></figure><p>上述代码在 2 和 3 环境下运行结果是不同的，结果如下：</p><p>环境：Python 3.6.3 (v3.6.3:2c5fed8, Oct  3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">34</span><br><span class="line">&#123;*</span><br><span class="line">*&quot;*d*a*t*e*&quot;*:* *&quot;*2*0*1*7*-*0*1*-*0*1*&quot;*,*</span><br><span class="line">*&quot;*a*&quot;*:* *&quot;*1*&quot;*</span><br><span class="line">*&#125;</span><br></pre></td></tr></table></figure><p>环境：2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:25:58) [MSC v.1500 64 bit (AMD64)]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">35</span><br><span class="line">&#123;*</span><br><span class="line">*&quot;*d*a*t*e*&quot;*:* *&quot;*2*0*1*7*-*0*1*-*0*1*&quot;*,* *</span><br><span class="line">*&quot;*a*&quot;*:* *&quot;*1*&quot;*</span><br><span class="line">*&#125;</span><br></pre></td></tr></table></figure><p>简而言之，将字典转化为json字符串时，python2 在每一对键值分割符“,”增加了一个空格</p><p>下面是测试 <code>pyecharts.utils.json_dumps</code> 功能的测试代码（使用 nosetests 框架）。影响到的是最后测试的时候直接使用表达式结果作为 assert 语句的第一个参数，这是一个取巧的方法，因为目前没有引入 <code>six</code> 等兼容库，代码需要多写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnknownTypeEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, (datetime.datetime, datetime.date)):</span><br><span class="line">            <span class="keyword">return</span> obj.isoformat()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> obj.astype(float).tolist()</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> obj.astype(str).tolist()</span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    <span class="keyword">return</span> json.JSONEncoder.default(self, obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_dumps</span><span class="params">(data, indent=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> json.dumps(data, indent=indent, cls=UnknownTypeEncoder)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json_encoder</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Test json encoder.</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    data = date(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    eq_(json.dumps(&#123;<span class="string">'date'</span>: <span class="string">'2017-01-01'</span>, <span class="string">'a'</span>: <span class="string">'1'</span>&#125;, indent=<span class="number">0</span>), json_dumps(&#123;<span class="string">'date'</span>: data, <span class="string">'a'</span>: <span class="string">'1'</span>&#125;))</span><br><span class="line"></span><br><span class="line">    data2 = &#123;<span class="string">'np_list'</span>: np.array([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])&#125;</span><br><span class="line">    data2_e = &#123;<span class="string">'np_list'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]&#125;</span><br><span class="line">    eq_(json.dumps(data2_e, indent=<span class="number">0</span>), json_dumps(data2))</span><br></pre></td></tr></table></figure><p>上述测试代码是一个不好的实践方法，把测试目标改变了，上面测试的是 <code>data2_e</code> 和 <code>data2</code> 的 json 输出是否一致，而不是  <code>data2</code>  的 json 是否符合预期的 json 格式，这二者是截然不同的，显然我们要测试的是后者。</p><p>假设 <code>json.dumps</code> 输出不是符合标准的 json 数据，上述测试案例可以通过，但在之后的功能测试是不能通过的。</p><p>上述的测试代码已经蕴含了 <code>json.dumps</code> 一定能输出标准的 json 数据，这当然是。</p><p>按照测试原则，assert 语句的第一个应当是表征字面量，下面就是一个简单的对比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_HOST = <span class="string">'https://chfw.github.io/jupyter-echarts/echarts'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pyecharts_remote_jshost</span><span class="params">()</span>:</span></span><br><span class="line">    target_config = PyEchartsConfig(jshost=DEFAULT_HOST)</span><br><span class="line">    eq_(<span class="string">'https://chfw.github.io/jupyter-echarts/echarts'</span>, target_config.jshost) <span class="comment"># 良好的实践</span></span><br><span class="line">    eq_(DEFAULT_HOST, target_config.jshost) <span class="comment"># 糟糕的实践</span></span><br></pre></td></tr></table></figure><h3 id="函数不定参数定义与调用"><a href="#函数不定参数定义与调用" class="headerlink" title="函数不定参数定义与调用"></a>函数不定参数定义与调用</h3><p>在 Python3 中，函数定义时允许常规变量(regular argument)出现在一个不定参数(varargs argument)之后，如下面的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortwords</span><span class="params">(*wordlist, case_sensitive=False)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>需要注意的是，调用的时候 case_sensitive 必须以关键字形式传入，类似 <code>sortwords(&#39;Apple&#39;, &#39;Orange&#39;, case_sensitive=True)</code> 。</p><p>更多的资料可以参考 <a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="noopener">PEP 3102</a> 。</p><p>之前在考虑 <code>page.from_charts(cls, *charts)</code> 是否添加 jshost 相关参数的时候碰到这个问题，最后考虑不添加这个特性，主要基于下面两个原因：</p><p>1 如果添加这个参数，会再调用时引起歧义，有以下两种种定义形式：</p><p>第一种： <code>Page.from_charts(jshost=None, *args)</code></p><p>这种方式有个问题，就是即使 jshost 无意设置，也需使用 None 占位。</p><p><code>Page.from_charts(chart1, chart2)</code> 调用从字面上是将两个图表合并，实际上只有一个，调用时会把 chart1 传给 jshost</p><p>第二种：<code>Page.from_charts(*args, jshost=None)</code></p><p>这个将可选的参数放置在最后，可以解决 <code>Page.from_charts(chart1, chart2)</code> 字面和实际效果一致，但是仅Python3.5+支持</p><p>2 从功能上来看，该方法只是 <code>__init__</code> 方法的补充，不一定非要和其等价。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>非常感谢 <a href="https://github.com/chenjiandongx" target="_blank" rel="noopener">@chenjiandongx</a> 和 <a href="https://github.com/chfw" target="_blank" rel="noopener">@chfw</a> 两位提供问题讨论和代码复查方面的经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文已收录于 &lt;a href=&quot;/pyecharts-project/&quot;&gt;《pyecharts 开发专辑》&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文记录了在 pyecharts 开发过程中的一些想法思路和具体问题分析解决的方案。写作本文的目的主要有两个：一是工作总结，每完成一项工作需要静下心来总结工作得失，这就是一种进步和成长；二是技术分享，对于同一个知识和技术，每个人的理解和思考都是不同的，博客提供了一个很好的分享平台。&lt;/p&gt;
&lt;p&gt;本文基于 &lt;a href=&quot;https://github.com/chenjiandongx/pyecharts/pull/240&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PR 自定义模板&lt;/a&gt; 整理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术研究" scheme="http://kinegratii.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Python" scheme="http://kinegratii.github.io/tags/Python/"/>
    
      <category term="数据可视化" scheme="http://kinegratii.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>电脑开发软件的5个清单</title>
    <link href="http://kinegratii.github.io/2017/10/09/pc-software-checklist/"/>
    <id>http://kinegratii.github.io/2017/10/09/pc-software-checklist/</id>
    <published>2017-10-09T11:49:04.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p>长假后的第一天，把电脑换成win10 64位，也重装了一些软件。本文将记录一些其中使用的软件，包含基本软件和开发工具。</p><a id="more"></a><h2 id="清单1：基本软件"><a href="#清单1：基本软件" class="headerlink" title="清单1：基本软件"></a>清单1：基本软件</h2><ul><li>微软自带输入法</li><li>好压：压缩软件</li><li>美图看看</li><li>everything：文件搜索</li><li>驱动精灵</li><li>福昕PDF阅读器 ： 比较好用；支持下本地的企业</li><li>google：浏览器<ul><li>adblock 广告去除插件</li><li>octree 代码浏览插件</li><li>bing 搜索引擎设置</li><li>书签导入</li></ul></li><li>Fences桌面整理软件 ：主要是图标分类分区显示</li><li>OneDrive文件存储</li><li>网易云音乐</li><li>closeAD  弹窗广告拦截器</li></ul><h2 id="清单2：基本开发工具"><a href="#清单2：基本开发工具" class="headerlink" title="清单2：基本开发工具"></a>清单2：基本开发工具</h2><ul><li>notepad++:记事本</li><li>atom 代码编辑器</li><li>typora:Markdown编辑器</li><li>git：代码管理库<ul><li>git账号设置</li><li>SSH公钥部署到 github 和 码云</li></ul></li></ul><h2 id="清单3：社交工具"><a href="#清单3：社交工具" class="headerlink" title="清单3：社交工具"></a>清单3：社交工具</h2><ul><li>邮箱客户端 :  使用自带的 Windows Mail 即可<ul><li>公司邮箱</li><li>个人邮箱</li></ul></li><li>微信电脑版</li><li>QQ 电脑版</li><li>TIM 电脑版</li></ul><h2 id="清单4：语言及其环境"><a href="#清单4：语言及其环境" class="headerlink" title="清单4：语言及其环境"></a>清单4：语言及其环境</h2><ul><li>Java运行环境<ul><li>JRE环境变量配置</li></ul></li><li><del>python2.7</del> ：基本上不再安装了</li><li>python3.6：追求最新的版本</li><li>Pycharm：Python开发环境<ul><li>pip源设置</li></ul></li><li>nodejs 8<ul><li>npm源设置</li></ul></li><li>常用全局包<ul><li>hexo ：博客构建工具</li><li>docsify ： 文档生成工具</li><li>ionic ： 混合 APP 开发框架</li><li>vuejs ： 前端开发主力框架</li></ul></li><li>hexo：博客构建</li></ul><h2 id="清单5：项目环境"><a href="#清单5：项目环境" class="headerlink" title="清单5：项目环境"></a>清单5：项目环境</h2><ul><li>Hexo博客<ul><li>Hexo安装</li><li>依赖重新安装</li></ul></li><li>Graphviz 可视化工具</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;长假后的第一天，把电脑换成win10 64位，也重装了一些软件。本文将记录一些其中使用的软件，包含基本软件和开发工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://kinegratii.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="软件" scheme="http://kinegratii.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="清单" scheme="http://kinegratii.github.io/tags/%E6%B8%85%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>django2笔记:路由path语法</title>
    <link href="http://kinegratii.github.io/2017/09/25/django2-url-path/"/>
    <id>http://kinegratii.github.io/2017/09/25/django2-url-path/</id>
    <published>2017-09-25T10:09:15.000Z</published>
    <updated>2020-11-08T06:32:52.269Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/django.png" alt="django"></p><p>9月23，<a href="https://www.djangoproject.com/" target="_blank" rel="noopener">Django</a> 发布了2.0a1版本，这是一个 feature freeze 版本，如果没有什么意外的话，2.0正式版不会再增加新的功能了。按照以往的规律，预计正式版将在12月发布。</p><blockquote><p>备注：Django 2.0 于12月2日已经正式发布。 （<a href="https://www.djangoproject.com/weblog/2017/dec/02/django-20-released/" target="_blank" rel="noopener">链接</a>）</p></blockquote><p>2.0无疑是一个里程碑版本，移除了对 Python2.7 的支持，最少需要 3.4 以上，建议使用3.5以上的版本。</p><a id="more"></a><p> <a href="https://docs.djangoproject.com/en/2.0/releases/2.0/#what-s-new-in-django-2-0" target="_blank" rel="noopener">What’s new in Django2.0</a>  文档中一共列出了三个新的特性：</p><ul><li>更简单的URL路由语法 (Simplified URL routing syntax)</li><li>admin应用的针对移动设备的优化改进(Mobile-friendly <code>contrib.admin</code>)</li><li>支持SQL开窗表达式(Window expressions)</li></ul><p>第一个特性，主要用于动态路由定义上。在Django2.0代码实现中，主要的变化是新增了 <code>django.urls.path</code> 函数，它允许使用一种更加简洁、可读的路由语法。比如之前的版本的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$'</span>, views.year_archive),</span><br></pre></td></tr></table></figure><p>在新版本中也可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'articles/&lt;int:year&gt;/'</span>, views.year_archive),</span><br></pre></td></tr></table></figure><p>新语法支持类型转化，在上述的例子中， year_archive 函数接收到的year参数就变成整数而不是字符串。</p><p>如果你有接触过 Flask 框架，就会发现和 <a href="http://flask.pocoo.org/docs/0.12/quickstart/#variable-rules" target="_blank" rel="noopener">Variable-Rules</a> 的语法形式和功能都是相类似的。</p><h2 id="一-问题引入"><a href="#一-问题引入" class="headerlink" title="一 问题引入"></a>一 问题引入</h2><p>下面是 Django1.X 的一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">year_archive</span><span class="params">(request, year)</span>:</span></span><br><span class="line">    year = int(year) <span class="comment"># convert str to int</span></span><br><span class="line">    <span class="comment"># Get articles from database</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail_view</span><span class="params">(request, article_id)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_view</span><span class="params">(request, article_id)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_view</span><span class="params">(request, article_id)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">'articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/'</span>, year_archive),</span><br><span class="line">    url(<span class="string">'article/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/detail/'</span>, detail_view),</span><br><span class="line">    url(<span class="string">'articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/edit/'</span>, edit_view),</span><br><span class="line">    url(<span class="string">'articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/delete/'</span>, delete_view),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>考虑下这样的两个问题：</p><p>第一个问题，函数 <code>year_archive</code> 中year参数是字符串类型的，因此需要先转化为整数类型的变量值，当然 <code>year=int(year)</code> 不会有诸如如TypeError或者ValueError的异常。那么有没有一种方法，在url中，使得这一转化步骤可以由Django自动完成？</p><p>第二个问题，三个路由中 article_id 在业务中表示同一个字段，使用同样的正则表达式，但是你需要写三遍，当之后 article_id 规则改变后，需要同时修改三处代码，那么有没有一种方法，只需修改一处即可？</p><p>在 Django2.0 中，可以使用 <code>path</code> 解决以上的两个问题。</p><h2 id="二-使用示例"><a href="#二-使用示例" class="headerlink" title="二 使用示例"></a>二 使用示例</h2><p>这是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/2003/'</span>, views.special_case_2003),</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/'</span>, views.year_archive),</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/&lt;int:month&gt;/'</span>, views.month_archive),</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug&gt;/'</span>, views.article_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>基本规则：</p><ul><li>使用尖括号(<code>&lt;&gt;</code>)从url中捕获值。</li><li>捕获值中可以包含一个转化器类型（converter type），比如使用 <code>&lt;int:name&gt;</code> 捕获一个整数变量。若果没有转化器，将匹配任何字符串，当然也包括了 <code>/</code> 字符。</li><li>无需添加前导斜杠。</li></ul><p>以下是根据 <a href="https://docs.djangoproject.com/en/2.0/topics/http/urls/#example" target="_blank" rel="noopener">2.0官方文档</a> 而整理的示例分析表：</p><table><thead><tr><th>请求URL</th><th>匹配项</th><th>视图函数调用形式</th></tr></thead><tbody><tr><td>/articles/2005/03/</td><td>第3个</td><td>views.month_archive(request, year=2005, month=3)</td></tr><tr><td>/articles/2003/</td><td>第1个</td><td>views.special_case_2003(request)</td></tr><tr><td>/articles/2003</td><td>无</td><td>-</td></tr><tr><td>/articles/2003/03/building-a-django-site/</td><td>第4个</td><td>views.article_detail(request, year=2003, month=3, slug=”building-a-django-site”)</td></tr></tbody></table><h2 id="三-path转化器"><a href="#三-path转化器" class="headerlink" title="三 path转化器"></a>三 path转化器</h2><blockquote><p>文档原文是Path converters，暂且翻译为转化器。</p></blockquote><p>Django默认支持以下5个转化器：</p><ul><li>str,匹配除了路径分隔符（<code>/</code>）之外的非空字符串，这是默认的形式</li><li>int,匹配正整数，包含0。</li><li>slug,匹配字母、数字以及横杠、下划线组成的字符串。</li><li>uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。</li><li>path,匹配任何非空字符串，包含了路径分隔符</li></ul><h2 id="四-自定义转化器"><a href="#四-自定义转化器" class="headerlink" title="四 自定义转化器"></a>四 自定义转化器</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>对于一些复杂或者复用的需要，可以定义自己的转化器。转化器是一个类或接口，它的要求有三点：</p><ul><li><p><code>regex</code> 类属性，字符串类型</p></li><li><p><code>to_python(self, value)</code> 方法，value是由类属性 <code>regex</code> 所匹配到的字符串，返回具体的Python变量值，以供Django传递到对应的视图函数中。</p></li><li><p><code>to_url(self, value)</code> 方法，和 <code>to_python</code> 相反，value是一个具体的Python变量值，返回其字符串，通常用于url反向引用。</p></li></ul><p>先看看默认的 <code>IntConverter</code> 和 <code>StringConverter</code> 是怎么实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntConverter</span>:</span></span><br><span class="line">    regex = <span class="string">'[0-9]+'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringConverter</span>:</span></span><br><span class="line">    regex = <span class="string">'[^/]+'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>第二个例子，是自己实现的4位年份的转化器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourDigitYearConverter</span>:</span></span><br><span class="line">    regex = <span class="string">'[0-9]&#123;4&#125;'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%04d'</span> % value</span><br></pre></td></tr></table></figure><h3 id="4-2-注册"><a href="#4-2-注册" class="headerlink" title="4.2 注册"></a>4.2 注册</h3><p>使用<code>register_converter</code> 将其注册到URL配置中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> register_converter, path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> converters, views</span><br><span class="line"></span><br><span class="line">register_converter(converters.FourDigitYearConverter, <span class="string">'yyyy'</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/2003/'</span>, views.special_case_2003),</span><br><span class="line">    path(<span class="string">'articles/&lt;yyyy:year&gt;/'</span>, views.year_archive),</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="五-使用正则表达式"><a href="#五-使用正则表达式" class="headerlink" title="五 使用正则表达式"></a>五 使用正则表达式</h2><p>如果上述的paths和converters还是无法满足需求，也可以使用正则表达式，这时应当使用 <code>django.urls.re_path</code> 函数。</p><p>在Python正则表达式中，命名式分组语法为 <code>(?P&lt;name&gt;pattern)</code> ，其中name为名称， pattern为待匹配的模式。</p><p>之前的示例代码也可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/2003/'</span>, views.special_case_2003),</span><br><span class="line">    re_path(<span class="string">'articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/'</span>, views.year_archive),</span><br><span class="line">    re_path(<span class="string">'articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/'</span>, views.month_archive),</span><br><span class="line">    re_path(<span class="string">'articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[^/]+)/'</span>, views.article_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这段代码和之前的代码实现了基本的功能，但是还是有一些区别：</p><ul><li>这里的代码匹配更加严格，比如year=10000在这里就无法匹配。</li><li>传递给视图函数的变量都是字符串类型，这点和 <code>url</code> 是一致的。</li></ul><p><strong>无命名分组</strong></p><p>一般来说，不建议使用这种方式，因为有可能引入歧义，甚至错误。</p><h2 id="六-Import变动"><a href="#六-Import变动" class="headerlink" title="六 Import变动"></a>六 Import变动</h2><p><code>django.urls.path</code> 可以看成是 <code>django.conf.urls.url</code> 的增强形式。</p><p>为了方便，其引用路径也有所变化，请注意下 <code>urls</code> 包路径的变更，不再是 <code>conf</code> 的子包了，目前和 <code>views</code> 、<code>conf</code> 一样，被认为是 Django 的核心组件。</p><table><thead><tr><th>1.X</th><th>2.0</th><th>备注</th></tr></thead><tbody><tr><td>-</td><td>django.urls.path</td><td>新增，url的增强版</td></tr><tr><td>django.conf.urls.include</td><td>django.urls.include</td><td>路径变更</td></tr><tr><td>django.conf.urls.url</td><td>django.urls.re_path</td><td>异名同功能，url不会立即废弃</td></tr></tbody></table><h2 id="七-代码改写"><a href="#七-代码改写" class="headerlink" title="七 代码改写"></a>七 代码改写</h2><p>将“问题引入”一节的代码使用新的path函数可以改写如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, register_converter</span><br><span class="line"><span class="keyword">from</span> django.urls.converters <span class="keyword">import</span> SlugConverter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourDigitYearConverter</span>:</span></span><br><span class="line">    regex = <span class="string">'[0-9]&#123;4&#125;'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%04d'</span> % value</span><br><span class="line"></span><br><span class="line">register_converter(SlugConverter, <span class="string">'article_id'</span>)</span><br><span class="line">register_converter(FourDigitYearConverter, <span class="string">'year'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">year_archive</span><span class="params">(request, year)</span>:</span></span><br><span class="line">    print(type(year)) <span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line">    <span class="comment"># Get articles from database</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail_view</span><span class="params">(request, article_id)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_view</span><span class="params">(request, article_id)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_view</span><span class="params">(request, article_id)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/&lt;year:year&gt;/'</span>, year_archive),</span><br><span class="line">    path(<span class="string">'article/&lt;article_id:article_id&gt;/detail/'</span>, detail_view),</span><br><span class="line">    path(<span class="string">'articles/&lt;article_id:article_id&gt;/edit/'</span>, edit_view),</span><br><span class="line">    path(<span class="string">'articles/&lt;article_id:article_id&gt;/delete/'</span>, delete_view),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="八-总结"><a href="#八-总结" class="headerlink" title="八 总结"></a>八 总结</h2><p>第一，目前 路由（url）到视图（View）的流程可以概括为四个步骤：</p><ol><li>url匹配</li><li>正则捕获</li><li>变量类型转化</li><li>视图调用</li></ol><p>Django2.0 和之前相比多了 <em>变量类型转化</em> 这一步骤。</p><p>第二，新的path语法可以解决一下以下几个场景：</p><ul><li>类型自动转化</li><li>公用正则表达式</li></ul><p>问题描述可参考 “问题引入” 一节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/django.png&quot; alt=&quot;django&quot;&gt;&lt;/p&gt;
&lt;p&gt;9月23，&lt;a href=&quot;https://www.djangoproject.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Django&lt;/a&gt; 发布了2.0a1版本，这是一个 feature freeze 版本，如果没有什么意外的话，2.0正式版不会再增加新的功能了。按照以往的规律，预计正式版将在12月发布。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：Django 2.0 于12月2日已经正式发布。 （&lt;a href=&quot;https://www.djangoproject.com/weblog/2017/dec/02/django-20-released/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.0无疑是一个里程碑版本，移除了对 Python2.7 的支持，最少需要 3.4 以上，建议使用3.5以上的版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://kinegratii.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Django" scheme="http://kinegratii.github.io/tags/Django/"/>
    
  </entry>
  
</feed>
