<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Borax-3.4.0发布日志]]></title>
    <url>%2F2020%2F11%2F08%2Fborax-release-note-340%2F</url>
    <content type="text"><![CDATA[2020年11月15日，也就是 v3.0.0 版本发布一周年之际，我们很高兴地宣布，Borax v3.4.0 正式发布。 1 项目开发SOP1.1 全新的项目组织形式Borax定位于一个由众多实用性功能组成的工具集合库。自v3.4开始，引入“话题/主题，Topic” 的概念，并使用“Borax.Foo” 的字符串标识每一个主题。 每个主题的代码形式可以是模块或包。目前已经被定义的主题如下表： 主题 描述 Borax.Calendars 农历日期库。由 Borax.LunarDate 、Borax.Festivals 和 Borax.Birthday 三部分组成 Borax.Choices 基于类定义的选项数据结构 Borax.Datasets 记录型数据的操作库 Borax.DataStructures 常用的数据结构 Borax.Numbers 数字处理库，包括中文数字、财务数字。 Borax.Pattern 基于Python实现的设计模式 Borax.UI 基于tkinter的封装 Borax.Utils 基础数据类型（字典、列表、对象）操作库。 基于主题的项目组织形式，我们还做了下列的工作： 按照主题重新组织Borax文档的编排 按照主题的方式重新调整部分模块的归属 1.2 发布周期和API废弃策略Borax 将继续遵循 “语义化版本2.0” 的版本管理策略，即由“&lt;主版本号&gt;.&lt;次版本号&gt;.&lt;修正版本号&gt;”组成。并结合相关情况制定相应的发布策略： 其中 次版本号 不大于9 一年发布两个“次版本系列”，时间是5月和11月。以“2020年11月-v3.4” 为起始点。 使用 “主版本废弃策略”，延长废弃进程。即 3.x 被标记为废弃的接口将在 v4.0 移除。 Borax 预计的发布日程表如下： 版本 发布日期 v3.4.0 2020年11月15日 v3.5.0 2021年5月15日（预计） v3.6.0 2021年11月15日（预计） … … 1.3 新的CI工具：Github ActionBorax 3.4开始使用 Github Action 代替原有的 Travis CI ，主要原因在于： 跟 Github 结合的很好，使用 方便。 生态发展很好，支持 step 共享。 新增基于 Codecov 的代码覆盖率显示。 1.4 Python版本支持：新增python3.9支持Borax 新增了对python3.9的构建支持。目前 Borax 支持以下的 python 版本： 1python3.5 ~ 3.9 2 Borax.Numbers: 中文数字的四种形式2.1 四种表示形式根据大小写和使用场景，中文数字可分为不同的形式： 小写所使用的汉字如下： 1一二三四五六七八九 十百千万亿 大写使用的汉字如下： 1壹贰叁肆伍陆柒捌玖 拾佰仟万亿 使用场景指的是数字“0”的表示形式。根据《出版物上数字用法(GB T 15835-2011)》的规定，汉字 “零” 和 “〇” 是有严格的使用场景。 123456789阿拉伯数字“0”有“零”和“〇”两种汉字书写形式。一个数字用作计量时，其中“0”的汉字书写形式为“零”，用作编号时，“0”的汉字书写形式为“〇”。 示例：“3052（个）”的汉字数字形式为“三千零五十二”（不写为“三千〇五十二”）“95.06”的汉字数字形式为“九十五点零六”（不写为“九十五点〇六”）“公元2012（年）”的汉字数字形式为“二〇一二”（不写为“二零一二”）---- 出版物上数字用法(GB T 15835-2011) 综上所述，数字204共有4种表示形式。 大写(Upper) 小写(Lower) 计量(Measure) 贰佰零肆 二百零四 编号(Order) 贰佰〇肆 二百〇四 财务金额使用的 大写，计量 的表示形式。法律条文中“第XXX条” 使用的是 小写，编号 的表示形式。 2.2 ChineseNumber类方法Borax v3.4 引入了中文数字的计量和编号两种不同用法，对于数字 “0” 使用不同的中文汉字描述。 函数 用法 ChineseNumbers.to_chinese_number(num:Union[int, str], upper:bool=False, order:bool=False) -&gt; str 使用upper控制大小写，使用order控制计量/编号 ChineseNumbers.measure_number(num:Union[int, str]) -&gt; str 小写，计量 ChineseNumbers.order_number(num:Union[int, str]) -&gt; str 小写，编号 3 Borax.Choices: 整合Django.Choices主要变化如下 整合ConstChoices和django choices 4 Borax.Calendars4.1 农历日期格式化strftime函数变化： 描述符 变更 %t 当节气不存在时显示为 - 而不是空字符串 %X [新增]月份的另一种形式，将“冬”、“腊”显示为“十一”、“十二” 描述符的文档，使用 年月日闰及其变种 的形式描述。 4.2 获取闰月的年份函数签名 1def LCalendars.get_leap_years(month:int=0) -&gt; tuple 函数返回 含有给定闰月的年份列表。当 month=0时，返回所有闰月的年份。当month大于12时，返回空元组。 4.3 节气日期在Borax v3.3可使用 LCalendars.create_solar_date 获取公历年特定节气的日期。 1def LCalendars.create_solar_date(year: int, term_index: Optional[int] = None, term_name: Optional[str] = None) -&gt; datetime.date 由于该方法的 year 参数和所在 LCalendars 类的意义有所冲突。Borax v3.4 该方法已废弃，新增 SCalendars.term2date ，签名如下： 1def SCalendars.term2date(year: int, term_name: Optional[str] = None) -&gt; datetime.date 主要变化： 移除了 term_index 参数 参数 term_name 支持 &#39;ChunFeng&#39; 和 &#39;春分&#39; 两种形式 4.4 import路径在Borax v3.4版本中，对开放的类提供了shortcut import path，完整的信息如下： 实际引用 Shortcut引用 borax.calendars.lundardate.LunarDate borax.calendars.LunarDate borax.calendars.lunardate.LCalendars borax.calendars.LCalendars borax.calendars.utils.SCalendars borax.calendars.SCalendars 5 Borax.JSON: JSON序列化5.1 模块组织Borax V3.4版本将 bjson 和 cjson 两个模块整合合并，形成全新的 borax.cjson 模块。原有的 bjson 将被标记为 Deprecated ，并在V4.0中移除。 V3.3.x V3.4.x 描述 borax.seriaize.bjson 实现基于类的 JSON Encoder borax.serialize.cjson borax.cjson 实现基于函数的 JSON Encoder 最终保留 cjson 意味着完全采用基于函数的实现方式。 新的 borax.serialize.cjson 的变化如下： 默认使用目标类 __json__ 的编码函数 新增 datetime / date 等常用类JSON编码 使用 cjson.encoder.register 添加新的编码函数 5.2 使用示例123456789101112131415161718from datetime import date, datetimefrom borax.calendars import LunarDatefrom borax.serialize import cjson@cjson.encoder.register(LunarDate)def encode_ld(ld): return ld.strftime('%Y年%L%M月%D日')data = &#123;'current_time': datetime.now()&#125;print(cjson.dumps(data))data2 = &#123; 'solar_day': date.today(), 'lunar_day': LunarDate.today()&#125;print(cjson.dumps(data2, ensure_ascii=False)) 输出结果 12&#123;&quot;current_time&quot;: &quot;2020-10-10 10:42:25&quot;&#125;&#123;&quot;solar_day&quot;: &quot;2020-10-10&quot;, &quot;lunar_day&quot;: &quot;二〇二〇年八月廿四日&quot;&#125; 6 Borax.SerialNo 基于 Pool 的生成器borax.counters.serial_pool 模块使用新的方式实现序列号生成器。包括以下函数和类： serial_no_generator 序列号生成器 SerialElement 序列号实体类 SerialNoPool 生成池 123456789from borax.counters.serial_pool import SerialNoPool# 返回 'LC00000000' ~ 'LC99999999' 的迭代器pool = SerialNoPool(label_fmt='LC&#123;no&#125;', dights=8)data = pool.generate_labels(num=3)print(data) # ['LC00000000', 'LC0000001', 'LC00000002']pool.add_elements(data)]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArgonRobot-V3.0.0 发布计划]]></title>
    <url>%2F2020%2F08%2F05%2Fargon-robot-v300-plan%2F</url>
    <content type="text"><![CDATA[ArgonRobot-V3.0.0 发布计划 ArgonRobot是一个数据爬取和分析的综合管理平台。平台基于 Python3 + Flask + Peewee + Redis 开发。 主要功能如下： 数据抓取（包括定时和手动两种方式） 配置数据执行器 社交平台发布 平台月度/年度运营报告 发布进程如下： 日期 事项 2020.08.10 V3.0.0Beta1 发布 ，冻结新功能 2020.08.16 完善文档 2020.08.21 V3.0.0RC1发布 2020.08.25 V3.0.0 发布]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docx和docxtpl库的基本使用]]></title>
    <url>%2F2020%2F03%2F22%2Fthe-usage-of-docx-and-docxtpl%2F</url>
    <content type="text"><![CDATA[在web开发过程中，经常需要导出一些word文档，比如运营月报、进货单、收据等。它们的特点是格式都是一致的，只是需要不同的数据进行填充。 docx 和 docxtpl 是比较常见的处理 word 文件的python库。其中前者用于创建一个包含段落、图片、表格、页眉等元素文档，后者使用类似 jinja2 的方式从模板文档生成新的文档。 docx是一种压缩文档格式，使用XML形式定义了样式、段落等内容。详情可以查看 《An Informal Introduction to DOCX》。 文档构建安装方式使用 pip 安装这两个库即可： 12pip install python-docxpip install docxtpl 其中 docxtpl 还依赖 jinja2 库。 创建 word使用以下的方式创建一个 Document 对象，之后的操作都是基于该对象。 123from docx import Documentdocument = Document() 使用 add_* 函数添加到该文档对象，包括： 函数 说明 add_paragraph 段落 add_heading 标题 add_page_break 换页符 add_table(rows, cols) 表格 add_picture 图片 add_run 字符片段 run 是word中包含相同样式的字符片段，通常它的级别比 paragraph 更低。 这是正常的文字。这是粗体文字。 这是正常的文字。 比如上述的一段文字。依次由3个 run 组成。 待文档构建完成后，可以使用 save 函数保存到文件中。 1document.save('demo.docx') 文档模板使用方法docxtpl 的使用方法和 jinja2 类似。 123456from docxtpl import DocxTemplatedoc = DocxTemplate("my_word_template.docx")context = &#123; 'company_name' : "World company" &#125;doc.render(context)doc.save("generated_doc.docx") docxtpl 的核心在于前端标签定义。 变量渲染就像 jinja2 中一样，使用两个大括号即可。 1&#123;&#123; &lt;var&gt; &#125;&#125; 当 var 是 RichText 对象时，必须使用以下的方式： 1&#123;&#123;r &lt;var&gt; &#125;&#125; 为了能够准确的区分以上两种情况，建议变量名称不要单独命名为 r ，。 存储和输出整合Flask将文档对象保存到新建的 BytesIO() 实例即可，但需要注意的是在返回给浏览器前将文件指针重新指向开头。 详情查看 flask.send_file 的用法。 1234567891011121314import iofrom docxtpl import DocxTemplatefrom flask import send_filedef export_monthly_report(year, index): context = &#123;&#125; # 填充数据 doc = DocxTemplate(app.root_path + '/templates/report_monthly.docx') target_filename = 'monthly_&#123;&#125;_&#123;&#125;.docx'.format(year, index) doc.render(context) file_stream = io.BytesIO() doc.save(file_stream) file_stream.seek(0) return send_file(file_stream, as_attachment=True, attachment_filename=target_filename) 整合Django和 flask类似。 123456789101112131415def export_monthly_report(request, year, index): context = &#123;&#125; # 填充数据 doc = DocxTemplate(app.root_path + '/templates/report_monthly.docx') target_filename = 'monthly_&#123;&#125;_&#123;&#125;.docx'.format(year, index) doc.render(context) file_stream = io.BytesIO() doc.save(file_stream) file_stream.seek(0) response = HttpResponse( file_stream.getvalue(), # use the stream's contents content_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document", ) response["Content-Disposition"] = 'attachment; filename = "&#123;&#125;"'.format(target_filename) response["Content-Encoding"] = "UTF-8" return response]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python开发工程师笔试题（web方向）]]></title>
    <url>%2F2019%2F12%2F20%2Fpython-web-interview-questions%2F</url>
    <content type="text"><![CDATA[Python开发工程师（web方向） 基础语法★ 列出5个常用Python标准库？ ★ 在单元测试库unittest中，函数 unittest.TestCase.subTest 和 装饰器 unittest.skipIf 的作用分别是什么？ ★ Django数据库操作中，函数 bulk_create 和 循环 save 在用法上有什么区别？ ★ 什么是“N+1”查询的问题。Django如何解决这一问题。 ★ WSGI和ASGI有什么相同点和不同点。 ★ 在web开发中，表单传递参数和JSON传递参数有什么不同，各自的应用场景是什么？ ★ 下面下划线的作用是什么？ 1_, user = User.objects.get_or_create(username='admin', default=&#123;'password':'123456', 'last_updated': '2019-10-23 08:00:00'&#125;) 程序阅读题★ 阅读下面的python2程序，回答第1-2题。 1234# coding=utf8 a = range(1, 11)result = reduce(lambda x, y:x + y, a[7:] + a[-4::2] + a[-5:5] + a[3:-2:4]) / 10 （1） 变量 result的值是多少？ （2） 以上代码在python3下是否可以正常运行，如果不能，需要怎样修改才能正常运行且结果不变。（3点） ★ 阅读下列程序片段，根据运行结果补充函数 inject 的内容。 12345678910111213141516class App: def __init__(self, app_id): self.app_id = app_id def inject(self. **kwargs): passapp = App(2)@app.inject(app_id=6)def build_context(context): context = context or &#123;&#125; context.update(&#123;'method': 'build_context'&#125;) return contextif __name__ == '__main__': print(build_context(&#123;'name':'hello'&#125;)) # 结果为 &#123;'name':'hello', 'app_id': 6, 'method': 'build_context'&#125;]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客V5.0升级笔记]]></title>
    <url>%2F2019%2F09%2F30%2Fblog_upgrade_note%2F</url>
    <content type="text"><![CDATA[2019年9月30日，本博客升级了相关库，具体信息如下： 库 现有版本 原有版本 node 8.11.2 8.11.2 hexo-cli 2.0.0 1.1.0 hexo 3.9.0 3.2.2 hexo-theme-next 7.4.0 6.3.0 更新内容 博客新增版本记录 新增 pjax 特性 新增 github Banner 新增相关文章模块 更新正文字体大小 升级步骤依赖库更新和正常 Node 项目一致，使用 npm 更新即可。 更新全局 hexo-cli 1npm update -g hexo-cli 进入博客目录 查看可升级的包： 1234567891011121314151617&gt; npm outdatedPackage Current Wanted Latest Locationhexo 3.2.2 3.9.0 3.9.0 Kinegratii-bloghexo-deployer-git 0.2.0 0.2.0 2.0.0 Kinegratii-bloghexo-generator-archive 0.1.4 0.1.5 1.0.0 Kinegratii-bloghexo-generator-category 0.1.3 0.1.3 1.0.0 Kinegratii-bloghexo-generator-feed 1.2.0 1.2.2 2.0.0 Kinegratii-bloghexo-generator-index 0.2.0 0.2.1 1.0.0 Kinegratii-bloghexo-generator-searchdb 1.0.3 1.0.8 1.0.8 Kinegratii-bloghexo-generator-sitemap 1.1.2 1.2.0 1.2.0 Kinegratii-bloghexo-generator-tag 0.2.0 0.2.0 1.0.0 Kinegratii-bloghexo-renderer-ejs 0.2.0 0.2.0 1.0.0 Kinegratii-bloghexo-renderer-marked 0.2.11 0.2.11 2.0.0 Kinegratii-bloghexo-renderer-stylus 0.3.1 0.3.3 1.1.0 Kinegratii-bloghexo-server 0.2.0 0.2.2 1.0.0 Kinegratii-bloghexo-symbols-count-time 0.4.4 0.4.4 0.6.1 Kinegratii-bloghexo-wordcount 2.0.1 2.0.1 6.0.1 Kinegratii-blog 全局安装 npm-check工具 1npm install -g npm-check 更新所有包 1npm-check -u --registry https://registry.npm.taobao.org 升级后的版本如下： 123456789101112131415161718&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.9.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-feed&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;, &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;, &quot;hexo-related-popular-posts&quot;: &quot;^3.0.6&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^1.1.0&quot;, &quot;hexo-server&quot;: &quot;^1.0.0&quot;, &quot;hexo-symbols-count-time&quot;: &quot;^0.6.1&quot;, &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;&#125; Next主题更新几个文档采用手动合并更新： next主题配置文件：_config.yaml （必须以现有配置文件为基础） 中文翻译文件： zh-CN.yml 插件库：lib 插件库版本忽略文件：themes\next.gitignore]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译Python脚本]]></title>
    <url>%2F2019%2F04%2F25%2Fcompile-python-files%2F</url>
    <content type="text"><![CDATA[本文描述了将 python 源代码文件编译成相应的库文件。 1 文件类型python开发中文件类型如下： 序号 文件类型 描述 1 .py 源代码文件 2 .pyw 源代码文件 3 .pyi 存根文件，用于类、函数的声明；参见PEP 484 4 .pyc 字节码文档 5 .pyo 和pyc类似，优化后的字节码文件 6 .pyd 库文件，和dll 和 so 文件类似 和dll的区别关于 dll 和 pyd 的区别可以参见 官方文档 Is a *.pyd file the same as a DLL?。 编译pyd文件Cython 是一个静态编译器，也是 python语言的超集。 Cpython 将python代码转化为 c 语言代码，这个过程称为 Cythonizing 。和 原来的 python 代码相比，其执行速度将有较大的提高。 第一步，在windows下编译需要两个工具： 微软python编译器，在 https://visualstudio.microsoft.com/downloads/ 下载记可 cpython 包，使用 pip install cpython 第二步，提供源代码。以 hello.py 文件为例子，内容如下： 12345#!/usr/bin/env pythondef hello(): print("Hello world!") 第三步，编写一个 setup.py 文件，基本代码如下： 1234567#!/usr/bin/env pythonfrom setuptools import setupfrom Cython.Build import cythonizesetup( ext_modules=cythonize('module.py')) 第四步，使用以下命令开始编译 1python setup.py build_ext --inplace 会在同一个目录下生成 hell.pyd 文件，这个文件可以像正常的模块进行 import 。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语的那些大数字]]></title>
    <url>%2F2019%2F01%2F15%2Fenglish-big-numbers%2F</url>
    <content type="text"><![CDATA[Idle Aiport Tycoon 游戏中出现的那些大数字。 为了避免数字位数太多而无法看清它具体的数值，人们在数字中每隔3个数字加入一个分隔符，这就是千位分隔符，比如 1,000,000。 英式英文和美式英文在一些单词表示上有所不同，这里指的是英式英文。 单词 汉语 数字 缩写 million 百万 10^6 M billion 十亿 10^9 B trillion 万亿 10^12 T quadrillion - 10^15 q quintillion - 10^18 Q sextillion - 10^21 s septillion - 10^24 S octillion - 10^27 o nonillion - 10^30 N decillion - 10^33 d undecillion 涧 10^36 u duodecillion - 10^39 D tredecillion - 10^42 Td quattuordecillion - 10^45 qd quindecillion - 10^48 Qd exdecillion - 10^51 septendecillion - 10^54 octodecillion - 10^57 novemdecillion - 10^60 vigintillion - 10^63 centillion - 10^66]]></content>
      <categories>
        <category>知识与思维</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Borax.Lunardate:中国农历日期]]></title>
    <url>%2F2019%2F01%2F05%2Flunardate-module%2F</url>
    <content type="text"><![CDATA[本文简要介绍了我国传统的农历历法知识，并叙述了 Borax-Lunar 工具库开发背后的一些算法原理和技术资料。 1 农历概述农历是我国的传统历法，依据太阳和月球位置的精确预报以及约定的日期编排规则编排日期，并以传统命名方法表述日期。 2017年，我国已经颁布了国家推荐性标准《GB/T 33661-2017 农历的编算和颁行》。 1.1 编排规则农历属于一种阴阳合历，基本规则如下：其年份分为平年和闰年。平年为十二个月；闰年为十三个月。月份分为大月和小月，大月三十天，小月二十九天。一年中哪个月大，哪个月小，可由“置闰规则”计算决定。 若从某个农历十一月开始到下一个农历十一月（不含）之间有13个农历月，则需要置闰。置闰规则为：去其中最先出现的一个不包含中气的农历月为农历闰月。 除此之外，还有生肖纪年、干支纪年、二十四节气等。 1.2 表示方法农历日期通常有以下几种表示方法： 农历乙未年正月初一 农历牛年闰五月十一 农历甲午年七月庚戌日 公元2016年农历丙申年十一月廿九 1.3 二十四节气一个回归年内24个太阳地心视黄经等于15度的整数倍的时刻的总称，每个时刻成为一个节气。太阳每年运行360度，共经历二十四个节气，分别为立春（315度）、雨水（330度）、惊蛰（345度）、春分（0度、360度）、清明（15度）、谷雨（30度）、立夏（45度）、小满（60度）、芒种（75度）、夏至（90度）、小暑（105度）、大暑（120度）、立秋（135度）、处暑（150度）、白露（165度）、秋分（180度）、寒露（195度）、霜降（210度）、立冬（225度）、小雪（240度）、大雪（255度）、冬至（270度）、小寒（285度）、大寒（300度）。可以通过下面的儿歌记忆这些节气。 123456春雨惊春清谷天，夏满芒夏暑相连，秋处露秋寒霜降，冬雪雪冬小大寒，每月两节不变更，最多相差一两天 2016年11月30日，中国“二十四节气”被正式列入联合国教科文组织人类非物质文化遗产代表作名录。 2 数据结构农历月份大小、农历闰/平年、二十四节气的日期没有什么特定的规律，只能使用原始的“查表法”存储和查询这些信息。 2.1 大小月和闰月从香港天文台网站可以获取1900 - 2100年的农历信息，每一天包含公历日期、农历日期、星期、节气四项基本信息。日期范围的基本信息如下表： 项目 起始日 … 2100年 2101年 … 截止日 公历 1990年1月31日 … 2100年12月31日 2101年1月1日 … 2101年1月28日 农历 1900年正月初一 … 2100年十二月初一 2100年十二月初二 … 2100年十二月二十九 offset 0 … 73383 73384 … 73411 干支 庚午年丙子月壬辰日 … 庚申年戊子月丁未日 - … - 具体到一个农历年中，从中可以看出以下几点信息： 每个月有多少天；哪些是大月（30天），哪些是小月（29天） 本年是否有闰月；如果有，是哪个月份 如何使用精炼的数据结构表述这些信息，是一个重要的前提，主要要求算法简单、内存占用少。网上有许多种方式，一种比较通行的做法是使用5字节的数据，高3位总是“000”，实际使用的低17位二进制。 字段 闰月大小标志 月份大小标志 闰月月份 大小 4b 12b 4b 2017年示例 0001 0101 0001 0111 0110 描述 本年有闰月 2,4,8,10,11,12为大月 六月是闰月 2019年示例 0000 1010 1001 0011 0000 描述 无闰月 1,3,5,8,11,12为大月 无闰月 综上所述，2017年信息可以使用 0x15176 表示；2019年信息可使用 0x0a930 表示。 2.2 节气的数据结构36位字符串 二十四节气开始的日期，与通用的公历几乎一致，最多相差一两天，因为是按照地球一年绕太阳公转一周作为依据。比如小寒通常落在在1月5-7日，立春落在2月3-5日，冬至落在12月21-23日。即每个月都会有2个节气，1月只能有小寒、大寒这两个节气。 构建两个含有24元素的数组， 第一个数组以小寒为第1个节气重新排列这24个节气。 12小寒, 大寒, 立春, 雨水, 惊蛰, 春分, 清明, 谷雨, 立夏, 小满, 芒种, 夏至,小暑, 大暑, 立秋, 处暑, 白露, 秋分, 寒露, 霜降, 立冬, 小雪, 大雪, 冬至 第二个数组表示对应节气对应的日期数字。 16 20 4 19 6 21 5 20 6 21 6 22 7 23 8 23 8 23 9 24 8 23 7 22 结合这两个数组，可记录在一个公历年中，二十四个节气分别是在哪一天。比如上述的24个数字可解释为：1月6日是小寒、1月20日是大寒…12月7日是大雪、12月22日是冬至。 在 Python 语言层面，可以使用字符串（基本数据类型）代替上述数组（复合数据类型），即&quot;620419621520621622723823823924823722&quot; ，需要36位字符存储。 解析表中数据的 Python 代码实现如下： 123456def parse_term(year_info): result = [] for i in range(0, 36, 3): s = year_info[i:i + 3] result.extend([int(s[0]), int(s[1:3])]) return result 30位字符串 jjonline/calendar.js 提供了一种用更为简单的表示方法：利用十六进制压缩数字的位数，进一步简化为30位的字符串。具体计算过程如下： 12345679778397bd097c36b0b6fc9274c91aa # 按长度5分割，共6组97783 97bd0 97c36 b0b6f c9274 c91aa # 转化为十进制620419 621520 621622 723823 823924 823722 # 按长度1,2,1,2细分6 20 4 19 6 21 5 20 6 21 6 22 7 23 8 23 8 23 9 24 8 23 7 22 使用 Python代码实现上述算法如下： 12345678def parse_term(term_info): values = [str(int(term_info[i:i + 5], 16)) for i in range(0, 30, 5)] term_day_list = [] for v in values: term_day_list.extend([ int(v[0]), int(v[1:3]), int(v[3]), int(v[4:6]) ]) return term_day_list 24位字符串 从 Borax v1.2.0 开始使用算法。 统计1900-2100年之前节气日期统计可知，中气的日期都是在18-24日之间，这些均为两位数，可以通过线性变化转为一位数的数字，结合月份特点，可以通过减去一个固定偏移量15就是比较好的选择。 同样的按照上述处理，具体过程如下： 12345654466556667788888998877 # 按长度1分割6 5 4 4 6 6 5 5 6 6 6 7 7 8 8 8 8 8 9 9 8 8 7 7 # 增加偏移量，奇位置为0，偶位置为156 20 4 19 6 21 5 20 6 21 6 22 7 23 8 23 8 23 9 24 8 23 7 22 同样的使用Python 代码如下，和30位表示法相比，更为简单直接。 12def parse_term_days(term_info): return [int(c) + [0, 15][i % 2] for i, c in enumerate(term_info)] 3 Borax-Lunardate概述到2019年1月为止，关于农历的主题，github/PyPI 上已经有非常多的代码项目，语言有C、Java、Python等，具体的思路也不一样。综合来看，这些库有的功能单一，只覆盖某几个方面；有的已经很久没有更新了，主要是农历信息已在多年之前就采集完成，但是对于一些最新的数据修正未能及时涵盖；也有的在代码层面没有很好的适用最新的 Python 语言特性。 基于此，本人利用收集整理的一些技术资料开发出了 Borax-Lunar 这个库，主要的目标和特点有： 完整的农历信息 在开发过程中我收集网络上的几个重要农历数据，包含了干支、生肖、节气等事项，并同时将它们作为数据验证的参考标准。 另外，一些术语命名（比如天干、地支等）采用 《GB/T 33661-2017 农历的编算和颁行》 所规定的文字。 功能完备 Borax-Lunardate 库分为三个部分：1) 基于 LunarDate 的农历日期表示；2）类似于 datetime.strftime 的字符串格式系统；3） 一些常用的农历工具接口。 其中第2,3部分是网络上的农历库比较少涉及的，Borax-Lunardate 在这一方面非常有优势的。 对标datetime 在模块/类层面的组织和分类上，Borax-Lunardate 对标标准库的 datetime 和 calendar 模块，实现了这两个模块中与农历日期相联系的方法，LunarDate 和 date 类有许多相同的特性，包括不可变类、可比较性、时间加减等。 甚至有些命名也是一样的，比如 strftime 方法。 123lunardate.LunarDate &lt;------&gt; datetime.datelunardate.LCalendars &lt;------&gt; calendar.Calendar 4 模块设计4.1 LunarDate日期类4.1.1 初始化日期对象LunarDate 是一个重要的类，每一个对象表示一个农历日期，一个特定的农历日期可以由农历年、月、日、闰月标志4个字段唯一确定，可以使用这些字段初始化对象。 123&gt;&gt;&gt;from borax.calendars.lunardate import LunarDate&gt;&gt;&gt;LunarDate(2018, 7, 1)LunarDate(2018, 7, 1, 0) 对于一些特定的日期，也可以通过类方法创建这些日期对象。 123456&gt;&gt;&gt;LunarDate.today()LunarDate(2018, 7, 1, 0)&gt;&gt;&gt;LunarDate.yesterday()LunarDate(2018, 6, 29, 0)&gt;&gt;&gt;LunarDate.tomorrow()LunarDate(2018, 7, 2, 0) 4.1.2 基准日期LunarDate 类使用可表示范围的下限作为基准日期（即LunarDate(1990, 1, 1, False)）。对象的 offset 属性表示与基准日期相差的天数，这也是一种可以唯一确定日期的方法。 4.2 格式化显示该功能由 Borax-Lunardate 特有的功能，提供了与 datetime.date.strftime 相似的功能。 4.2.1 使用方法LunarDate 提供了 strftime 方法，可以将一个农历日期按照给定的格式转化为字符串。 12class LunarDate: def strftime(fmt:str) -&gt; str: pass 格式字符串使用 ‘%’ 加一个字母的描述符(Directive)表示日期对象的一个字段，常用的描述符见下表： 属性 类型 描述 示例值 格式描述符 备注 year int 农历年 2018 %y month int 农历月 6 %m day int 农历日 26 %d leap bool 是否闰月 False %l (1) offset int 距下限的偏移量 43287 - term str 或 None 节气名称 立秋 %t cn_year str 中文年 二〇一八年 %Y (2) cn_month str 中文月 六月 %M (2) cn_day str 中文日 廿六 %D (2) gz_year str 干支年份 戊戌 %o gz_month str 干支月份 庚申 %p gz_day str 干支日 辛未 %q animal str 年生肖 狗 %a - str 两位数字的月份 06 %A - str 两位数字的日期 26 %B 备注： (1) ‘%l’ 将闰月标志格式化为数字，如“0”、“1” (2) ‘%Y’、’%M’、’%D’ 三个中文名称不包含“年”、“月”、“日”后缀汉字 下面是几个使用 strftime 的例子： 12345&gt;&gt;&gt;today = LunarDate.today()&gt;&gt;&gt;today.strftime（&apos;%Y-%M-%D&apos;)&apos;二〇一八-六-廿六&apos;&gt;&gt;&gt;today.strftime(&apos;今天的干支表示法为：%G&apos;)&apos;今天的干支表示法为：戊戌年庚申月辛未日&apos; 4.2.2 源码解析strftime 的具体实现定义在 lunardate.Formatter 类。该类接受一个 %形式的格式字符串，转化为命名字段形式的格式字符串，并格式化给定的日期对象，如下图： 1&apos;%Y-%M-%D&apos; ==&gt; &apos;&#123;cn_year&#125;-&#123;cn_month&#125;-&#123;cn_day&#125;&apos; ==&gt; &apos;二〇一八-六-廿六&apos; 某个字段 field 的具体值，根据下列先后顺序确定具体的值。 Formatter.get_&lt;field&gt; obj.&lt;field&gt;() obj.&lt;field&gt; 核心代码如下： 1234567891011class Formatter: def resolve(self, obj, field): try: func = getattr(self, 'get_' + field) return func(obj) except AttributeError: attr = getattr(obj, field) if callable(attr): return attr() else: return attr 4.3 类型标注4.3.1 概述PEP 484 和 PEP526 提供了一种针对 Python 语言的类型标注方法。在 Python3.5+ 以上，可以使用 typing 标准模块实现这一目的，需要说明的是： 方便使用者了解所调用函数的参数类型和返回值类型 类型标注不会影响运行，不会抛出异常，只是警告 配合IDE的语法语义检查功能，增强智能提示功能 下面是一个参数和返回值都是字符串的函数标注： 12def greeting(name: str) -&gt; str: return 'Hello ' + name 除了一些基本类型，常用的符合数据类型还有 Any、Union、Tuple、List、Callable、TyVar、Generic 等。 需要注意的是，Python 的语言特性也可能给类型标准的使用带来了一些麻烦，比如变量在使用过程中其类型有所变化。基于目标用户是API使用者，大概可以整理出几条实用的原则： 只应用在公共接口（类、函数、方法、变量）加上类型标注。 全局常量不使用类型标注 魔术方法不使用类型标注 私有方法可以不使用类型标注 4.3.2 常用的使用示例类型标注学习起来也不困难，掌握几种常见的情形即可。 使用 :表示参数类型，使用 -&gt; 表示返回值类型，如上述的 greeting 函数 。 默认参数 1def foo(arg: int = 0) -&gt; None: pass 可选参数，需要使用 Optional，通常和上面的默认参数相互配合。 12def ndays(year: int, month: Optional[int] = None, leap: bool = False) -&gt; int: pass 自定义类型、混合类型，闰月标记可以使用布尔值或者整数。 1Leap = Union[bool, int] 后向引用，如果使用的类还没有定义，可以使用包含类名的字符串，以便后续实例化。一般用于创建对象的方法或者树形结构的定义。 1234class LunarDate: @classmethod def from_solar_date(cls, year: int, month: int, day: int) -&gt; 'LunarDate': pass 类型绑定。在后向引用的例子中，通常需要在多个地方使用字符串方式，为避免拼写错误，可以使用 TypeVar 的 bound 参数提前预定义。 T = TypeVar(&#39;T&#39;, bound=BaseClass) 使用父类创建类型变量以便所有子类均可匹配，这和 Java/C++ 语言中的 多态 相类似。 12345678from typing import TypeVarT = TypeVar('T', bound='LunarDate')class LunarDate: @classmethod def from_solar_date(cls, year: int, month: int, day: int) -&gt; T: pass 迭代器，使用 Iterator。 123def hello(n:int) -&gt; Iterator[int]: for i in range(n): yield i 5 参考资料 香港天文台农历信息 “农历”维基词条 jjonline/calendar.js lidaobing/python-lunardate Forward references - Stackflow]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>农历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordScapes(纵横填字母)游戏工具]]></title>
    <url>%2F2018%2F10%2F29%2Fword-scapes-helper-tool%2F</url>
    <content type="text"><![CDATA[WordScapes 是一个有关英文单词的简单游戏，游戏要求从打乱的字母选择若干个组成一系列有效的单词，填入图中的纵横框。 游戏链接： https://play.google.com/store/apps/details?id=com.peoplefun.wordcross 1 概述在玩游戏时，写了一个简单的脚本， 列出从给定的字母中排序组成和合法英文单词。 对于该局游戏，依次使用下面命令： 1234567891011121314$ python word_scapes.py dvmeo 3medemodoemodode$ python word_scapes.py dvmeo 4domemovemodedovedemo$ python word_scapes.py dvmeo 5moved 需要注意的是，脚本的输出包括了缩略词，但在 WordScapes 中，缩略词不被认为是一个有效的单词。 2 安装和部署脚本仅依赖 拼音检查库 PyEnchant 需要先安装Enchant，才能再安装 PyEnchant，可以使用下面的命令安装： 12apt-get install enchantpip install pyenchant 在 PyEnchant 中最主要的就是 Dict 对象，我们可以使用它来检查单词的拼写是否正确，使用的方式也很简单： 123456&gt;&gt;&gt; import enchant&gt;&gt;&gt; d = enchant.Dict("en_US")&gt;&gt;&gt; d.check("Hello")True&gt;&gt;&gt; d.check("Helo")False 3 API文档该脚本共有两种使用方式。 方式 1: 生成特定长度的英文单词命令 1$ python word_scapes.py LETTERS [LENGTH] 注意 LENGTH 默认为字母个数 LENGTH 的有效值为 1 ~ 字母个数 例子 12345678$ python word_scapes.py dvmeomoved$ python word_scapes.py dvmeo 4movedomedemomodedove 方式 2: 生成符合特定模式的单词命令 1$ python word_scapes.py &lt;LETTERS&gt; &lt;PATTERN&gt; 注意 PATTERN 由字母和 * 组成，一个 * 字符代表 LETTERS 中的任意一个字符 PATTERN 参数需要使用 &#39;&#39; 包裹起来 例子 12345$ python word_scapes.py dvmeo 'm**'modmed$ python word_scapes.py dvmeo '*e*'med 4 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# coding=utf8"""Usagescapes.py arestscapes.py arest 2scapes.py arest '**e**'"""import sysfrom itertools import permutationsimport enchantdef list_words_with_count(letters, count): for word in permutations(letters, count): yield ''.join(word)def list_words_with_pattern(letters, pattern): random_chars = list(letters) random_count = 0 for c in pattern: if c == '*': random_count += 1 else: try: random_chars.remove(c) except ValueError: raise ValueError('Invalid letter in pattern: &#123;&#125;'.format(c)) for chars in permutations(random_chars, random_count): _p = list(pattern) i = 0 for _i, _c in enumerate(_p): if _c == '*': _p[_i] = chars[i] i += 1 yield ''.join(_p)def list_words(letters, param): if param is None or isinstance(param, int): g = list_words_with_count(letters, param) else: g = list_words_with_pattern(letters, param) d = enchant.Dict('en_US') word_set = &#123;w for w in g if d.check(w)&#125; print('\n'.join(word_set))if __name__ == '__main__': args = sys.argv[1:] if len(args) == 2: letters, param = args try: param = int(param) except ValueError: pass else: letters = args[0] param = None list_words(letters, param)]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poetry 开发工具]]></title>
    <url>%2F2018%2F09%2F18%2Fpoetry-development-tool%2F</url>
    <content type="text"><![CDATA[poetry 是一个 Python 依赖管理和构建、发布的工具。 在 Python 中，对于初学者来说，打包系统和依赖管理是非常复杂和难懂的。即使对于经验丰富的开发者，一个项目总是要同时创建多个文件： setup.py ,requirements.txt,setup.cfg , MANIFEST.in ，还有最新的 Pipfile。 基于此， poetry 将所有的配置都放置在一个 toml 文件中，这些配置包括：依赖管理、构建、打包、发布。 poetry 的灵感来自于其他语言的一些工具： composer(PHP) 和 cargo (Rust) 。 TOML文件与配置TOML 的全称是 Tom’s Obvious, Minimal Language 。TOML是前GitHub CEO， Tom Preston-Werner，于2013年创建的语言，其目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换为一个哈希表(Hash table)。 12345678910111213title = "TOML 例子"[owner]name = "Tom Preston-Werner"organization = "GitHub"bio = "GitHub Cofounder &amp; CEO\nLikes tater tots and beer."dob = 1979-05-27T07:32:00Z[database]server = "192.168.1.1"ports = [ 8001, 8001, 8002 ]connection_max = 5000enabled = true 在 Python 中可以使用 toml 库读取和写入配置，该库使用非常方面，拥有和 json 一样的接口。 toml.load(f, _dict=dict) toml.loads(s, _dict=dict) toml.dump(o, f) toml.dumps(o) 在 Python 项目中，可以在根目录 pyproject.toml 定义相关配置，该名称由 PEP 518 所规定，可用于一般的开发工具，不仅仅是 poetry 。 命令 poetry 由一系列的命令所组成，这些命令能够覆盖项目开发的流程。 名称 功能 示例 new 创建一个项目脚手架，包含基本结构、pyproject.toml 文件 init 基于已有的项目代码创建 pyproject.toml 文件，支持交互式填写 install 安装依赖库 update 更新依赖库 add 添加一个或多个依赖库 poetry add six pytz remove 移除依赖库 show 查看具体依赖库信息，支持显示树形依赖链 poetry show --tree build 构建 tar.gz 或 wheel 包 publish 发布到 PyPI run 运行脚本和代码 poetry run python app.py 备注： 和 npm 一样， poetry 将依赖库分为 main 和 dev 两种渠道，使用 poetry add -D pyinstaller 添加为 dev 依赖包 示例：add 命令 123456789101112131415F:\ArgonApp&gt;poetry add -D pyinstallerUsing version ^3.4 for pyinstallerUpdating dependenciesResolving dependencies...Package operations: 4 installs, 0 updates, 0 removalsWriting lock file - Installing altgraph (0.16.1) - Installing macholib (1.11) - Installing pefile (2018.8.8) - Installing pyinstaller (3.4) 查看树形依赖链 12345678910111213141516171819202122232425pyecharts 0.5.11 Python echarts, make charting easier|-- future *|-- jinja2 *| `-- markupsafe &gt;=0.23|-- jupyter-echarts-pypkg 0.1.2| |-- lml 0.0.2| `-- pyecharts-jupyter-installer 0.0.3|-- lml 0.0.2|-- pillow *`-- pyecharts-javascripthon 0.0.6 `-- javascripthon &gt;=0.10 |-- dukpy * |-- macropy3 1.1.0b2 `-- setuptools *pyinstaller 3.4 PyInstaller bundles a Python application and all its dependencies into a single package.|-- altgraph *|-- macholib &gt;=1.8| `-- altgraph &gt;=0.15|-- pefile &gt;=2017.8.1| `-- future *`-- setuptools *pypiwin32 223`-- pywin32 &gt;=223pywin32 223 Python for Window Extensionspywin32-ctypes 0.2.0]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 6升级笔记]]></title>
    <url>%2F2018%2F07%2F23%2Fmigrate-to-hexo-next-6%2F</url>
    <content type="text"><![CDATA[博客V5.0已发布，参见 博客V5.0升级笔记 。 A 概述本文叙述了将 NexT 5.1.0 迁移到 6.3.0 的过程中的一些笔记。使用 NexT 6 的考虑在于： 优化配置项 支持 Valine 评论系统 代码快支持复制功能 其他从 v5.1.0 起内置的功能 B 准备工作如何安装 NexT 6 有多种选择，这里仅介绍的是一种简单机械的方法。 备份 : 将 themes\next 文件夹复制备份到另外一个目录下，然后删除原有的 next 文件夹。 下载：打开 代码仓库 ，切换到标签 v6.3.0 ，点击 “Download zip” 下载压缩包。 替换: 解压并重名为 next ，放入 themes 目录。 在 github 访问缓慢时，与 克隆代码 和 浏览器下载 相比，使用迅雷工具下载会提高不少的速度。 C 迁移步骤文件配置通常来说，需要改动一下几个文件： 博客配置文件 _config.yml 主题配置文件 themes\next_config.yml 语言翻译文件 themes\next\languages\zh-CN.yml 语言&amp;翻译在 NexT 6 中，简体中文的名称变为 zh-CN ，因此在 博客配置文件 里需要将原有的： 1language: zh-Hans 改为 1language: zh-CN 另外现在语言文件名称为 zh-CN.yaml ，格式没有变化，可以使用原有的 zh-Hans.yaml 覆盖。 菜单链接NexT 6 将分开的 链接 和 图标 配置合并在了一个配置项中，并使用 || 分割。受这一特性影响，以下配置项目有所变化，需手动修改： 菜单 theme.menu 社交 theme.social 代码Fork theme.github_banner Hexo 5 风格： 12345678910111213menu: home: / archives: /archives topics: /topics library: /library about: /aboutmenu_icons: enable: true home: home archives: archive topics: file library: book about: user Hexo 6 风格： 123456menu: home: / || home archives: /archives/ || archive topics: /topic/ || file library: /library/ || book about: /about/ || user 其他配置这些配置无任何变化，将配置内容复制到对应选项即可。 右下角的“回到顶部”按钮 打赏文字、图片 theme.reward_comment 网站 icon 图片 theme.favicon 本地搜索 theme.local_search D 插件这些功能之前是使用修改源代码方式，现在可以使用 “包/插件引入 + 选项配置” 的方式激活该功能。 插件路径定义在 themes\next\source\lib 目录下。 功能 插件 引入方式 配置项 字数统计 hexo-symbols-count-time 包 theme.symbols_count_time 图片浏览 theme-next-fancybox3 插件 theme.fancybox 顶部进度条 theme-next-pace 插件 theme.pace leancloud访问计数 leancloud-visitors 插件 theme.leancloud_visitors 引入方式 以包方式引入比较简单，使用 命令 npm install &lt;package-name&gt; -save 即可。 以插件方式引入，在 theme\next 目录使用代码克隆命令。 1git clone &lt;github-url&gt; source\lib\&lt;plugin-name&gt; 进度条 进度条使用 pace.js 插件，点此 查看每个配置的效果图。 E 评论系统NexT 6 已经集成这个功能了，可以使用和访问量同一个应用。 1 在云端的 leancloud 应用中创建一个名为 Comment 的类，使用默认的 ACL 权限设置。 2 在主题配置文件中设置 app_id 和 app_key 即可。 12345678910valine: enable: true appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail # custom comment header pageSize: 10 # pagination size F 部署修改 theme\next.gitignore 文件，将 theme\next\source\lib 下的文件也提交到版本库。 具体做法是删除以下内容： 1234567891011121314# Ignore optional external librariessource/lib/*# Track internal libraries &amp; Ignore unused verdors filessource/lib/font-awesome/less/source/lib/font-awesome/scss/!source/lib/font-awesome/*!source/lib/jquery/source/lib/ua-parser-js/*!source/lib/ua-parser-js/dist/!source/lib/velocity/ G 参考资料 hexo-theme-next]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>软件迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理和迁移遗留的代码]]></title>
    <url>%2F2018%2F06%2F27%2Fdealing-with-legacy-code%2F</url>
    <content type="text"><![CDATA[【书名】：Django Design Patterns and Best Practices 【主题】：Dealing with Legacy Code (处理遗留的代码) 【摘要】：本文以 Django项目为例子，叙述在处理遗留代码过程中所使用的多项技术。阅读代码库通常是容易被低估的一个基本技能。在实践过程中，我们应当尽可能使用原有的可以运行良好的代码，而不是重复地发明轮子。另外测试案例也是代码编程一个非常重要的组成部分。 A 概述参加一个项目的开发是一个令人激动人心的事情，在此过程中你可以了解和使用到一些强大的工具和前沿的技术。然而常常接收的却是一个已经存在的，甚至远古时期的项目。当然，Django 发行仅有十几年（2005年），和其他语言框架相比，算是比较年轻的项目。由于技术的迅速的发展，使用早期 Django 项目是一个巨大的挑战，仅仅使用源码和文档可能是不够的。 和项目维护相比，项目迁移更多涉及到是系统设计层面的内容，比如： 使用新版本的语言，比如 从 Python2 迁移到 Python3 使用新版本的库以具有更好的性能表现 使用 CBV（类视图） 改写项目中的 CBV （函数视图） 使用 django-rest-framework 实现项目的 Restful API B Django 版本确定项目使用了哪个版本的 Django 是一个重要的基础步骤。随着 Django 不断发展和完善，一些概念、规范和规则可能有所变化，比如 默认目录结构 和 最佳实践规则 。 依赖文件一般来说，每个项目的根目录会有一个 requirements.txt 或者 setup.py 的文件，表明了这个项目使用了哪些第三方库，它们的版本是多少，通常是类似下面格式的配置文件： 1django=1.11.2 使用 “=” 描述的依赖，是一个非常精确的版本。与此相对应的是类似 django&gt;=1.8 的形式 ，表示是一个范围， pip 安装时总是以符合该范围的最新版本为准。 延伸 固定依赖库的版本是一个最佳实践，这样会减少一些意想不到的错误，使得构建过程具有确定性。pipenv 是一个 Python 项目开发构建工具，为项目提供了单独的虚拟环境，使用 Pipfile.lock 文件产生确定性的构建过程。 在现实的项目则往往是没有 requirements.txt 文件或 setup.py 文件，这时候你可能需要尝试其他方式来确定它的 Django 版本。 虚拟环境在大多情况下，Django 项目可能部署在一个虚拟环境或者携带有构建环境，事实上，这种做法也是一个最佳实践额规则。当你位于一个虚拟环境时，可以按照下面的步骤查询 Django 版本。 第一步，激活该环境，在 Linux 中可以使用以下命令： 1$ source venv_path/bin/activate 第二步，使用下面的 Python 片段，查询版本。 123&gt;&gt;&gt; import django&gt;&gt;&gt; django.get_version()'1.11.1' 当然除了上述的方法外，也可以直接在 Django 源码查看版本。 123$ cd envs/foo_env/lib/python2.7/site-packages/django$ cat __init__.pyVERSION = (1, 11, 1, 'final', 0) 配置模块与Django版本特性项目的配置模块是一个项目的重要的模块，它包含了该项目的基本信息和所使用的一些组件、构件、外部资源等。一般来说，配置模块名称为 settings.py。有时根据不同的环境，使用不同的配置，比如一个符合最佳实践的文件布局可能如下： 1234567891011Fooo/ Foo/ __init__.py settings/ __init__.py base.py dev.py prod.py test.py urls.py wsgi.py 使用 django-admin startproject 命令生成的项目，在 settings.py 的顶部含有类似下面的注释文字，清楚地记载了该项目所使用的具体版本。 123Django settings for bws project.Generated by &apos;django-admin startproject&apos; using Django 1.8.3. 当然这只是表明项目创建时的版本，如果在开发过程中，项目有所更新，也可以通过 git 日志来获取版本的变更情况。 另外的，如果上述的注释被删除的话，需要根据项目的一些特性并结合版本发布日志可以大致确定版本范围。 下面是一些版本中比较大的变化： 版本 特性更新 1.4 LTS 新的默认项目文件布局 1.5 AUTH_PROFILE_MODULE 被废弃，使用 AUTH_USER_MODEL 1.7 支持数据库迁移，可以使用 migrate 命令 1.8 LTS 开始支持 Jinja2 模板引擎。 2.0 不再支持 Python2 Django 的版本发布采用语义化的规范，特性发布以 X.Y 的格式，具体可查看 The Release proccess。 C 阅读代码源文件和 PHP 不同的是， Python 项目源代码文件不是位于 web 服务器的文档根目录，比如 wwwroot 或 public_html 。将源代码和配置数据放置在公共访问目录之外，web 爬虫程序就无法访问这些文件，提高了安全性。 入口点 —— 路由通常来说，Python 程序的入口点类似于下面的代码段： 123if __name__ == '__main__': pass Django 使用的是 “模型 - 模板 - 视图” 的架构模式，简称为 MTV ，是 MVC 的一种变形。在项目中，路由 是一个很好的入口点，包含了从每个请求到响应的映射。代码上可能为一个模块文件(Module)，复杂的情况下也可能是一个包(Package)。但无论何种情况，总是存在 根路由 ，并且定义在项目配置模块中。 1ROOT_URLCONF = 'projectname.urls' 在 Linux 中，可以使用下面的命令寻找和定位 根路由： 1234$ find . -iname settings.py -exec grep -H 'ROOT_URLCONF' &#123;&#125; \;./projectname/settings.py:ROOT_URLCONF = 'projectname.urls'$ ls projectname/urls.pyprojectname/urls.py 文档代码本身以及测试案例是了解代码的最好的方法。 对于遗留的代码，旧有的文档可能会与之相匹配，但有时也无法覆盖未来的问题。 Django 的官方文档位于 https://www.djangoproject.com 。在右下角可以切换到不同的版本。 应用逻辑与可视化图表是了解一个了解程序最好的方法。 django-command-extensions 是一个工具扩展包，提供了 graph_models 命令，可以用图表的方式显示所有数据模型及其之间的关系。 1$ python manage.py graph_models -a -o myapp_models.png 在 PyCharm IDE 中也有类似的功能。右键选择模型文件 models.py，依次选择下面的菜单项。 1Diagrams -&gt; Show Diagram -&gt; Django Model Dependency Diagram 需要注意的是，图中的 str 是 settings.AUTH_USER_MODEL 指向的模型类。 显示的图表如下： 你还可以导出 uml 和 png 等不同的文件格式。 D 增量变化 OR 全新重写 代码是一个债务，而不是一个资产，更少的代码具有更好的可维护性。 在最好的情况下，遗留的代码，总是我们所期望的： 拥有测试代码 良好的文档 平稳地迁移新环境 在最坏的情况下，可能更希望放弃现有的代码，并且开始重新开始新的编码工作。 在具体工作的过程中，应当根据具体的情况，比如项目进度、时间要求、业务逻辑等不同因素采取不同的策略。 有时候，在重写的过程中，应用（业务）领域的复杂度将是一个巨大的障碍。这是因为在编写旧有代码过程中所学习的大量的知识可能会遗失。特别的是，代码逻辑设计差以至于很难从中了解具体的业务逻辑。 最差的重写是转换，比如将原来的 PHP 项目使用 Python 语言重写，在此过程中很可能会丢失原有 PHP 语言的一些最佳实践规则。 E 特征测试 编写测试案例应当在作任何改变之前。 使用测试，我们可以非常容易和正确地修改已有代码的行为。没有测试，则不可能知道我们的改变让代码变得更好还是更差。 特征测试描述了系统当前的实际行为。这是使用的一些步骤： 在测试用具中使用目标代码快 编写一个你会知道失败的断言 从失败的断言中知道代码的行为 修改测试，让它预期目标代码块的实际行为 重复上述步骤 当准备在遗留系统中使用一个方法之前，请查看一下是否已有针对它的测试，没有的话就自己写一个，始终保持这一习惯，你的测试就能起到信息传递媒介的作用。别人只要一看到你的测试就能够知道对于某方法他们该期望什么而不该期望什么，试图使一个类变得可测试这一行为本身往往能够改善代码的质量，于是人们能够发现什么是可行的，以及是如何可行的，他们可以进行修改，更正BUG，然后继续前进。 F 数据库在 Django 中，可以使用下面的命令导入旧有的数据库结构。 1$ python manage.py inspectdb &gt; models.py 以上命令会根据配置模块的配置内容生成 Python 代码，这些代码通常位于 models.py 文件。 这里有一些最佳实践规则： 了解 Django ORM 的一些限制，比如不支持多字段主键、NoSQL数据库等。 清理代码，比如移除不必要的 ID 字段，Django 将会自动创建。 外键处理，在某些数据库中，原始生成的外键可能是使用整数类型定义的。 模块划分，将其分散在不同的 APP 以符合具体的业务逻辑 在迁移的过程中，会创建额外的数据表，比如 django_* 等数据表 G 参考资料 Upgrading Django to a newer version Recommended Django Project Layout Working Effectively With Characterization Tests 《修改代码的艺术》]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>软件工程与实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.1新功能笔记]]></title>
    <url>%2F2018%2F06%2F19%2Ffeature-note-for-django-21%2F</url>
    <content type="text"><![CDATA[2018年8月1日，Django 2.1 正式版发布。 2018年7月18日，Django 2.1 RC 1发布。 2018年6月18日，Django 发布 2.1Beta1，这是 2.1 系列的第一个公测版本，正式版预计于8月初发布。 本文仅列出一些比较重要的改变，具体可详见 https://docs.djangoproject.com/en/2.1/releases/2.1/ 。 1 Python 版本支持Python 版本要求 3.5+ ，不再支持 3.4 。 2 查看(view)权限Django 2.1 新增了 查看(View) 权限。至此 Django 的模型默认有四种权限： 权限 Code 增加（Add） &lt;app_label&gt;.add_&lt;modelname&gt; 删除（Delete） &lt;app_label&gt;.delete_&lt;modelname&gt; 修改（Change） &lt;app_label&gt;.change_&lt;modelname&gt; 查看（View） &lt;app_label&gt;.view_&lt;modelname&gt; 正好和数据库原子操作 “CURD” 一一对应。需要注意的是，一个用户具有修改权限，自然也具查看权限。 这既符合实际逻辑，又保证了旧有版本的兼容性。 has_view_permission函数在 Admin 中新增了函数 ModelAdmin.has_view_permission() ，控制用户是否具有可读权限。函数签名为： 1ModelAdmin.has_view_permission(request:HttpRequest, obj:Model=None) -&gt; bool 该函数应当返回一个布尔值，表明 查看某个具体的模型对象 obj 的操作是否被允许。如果 obj 为 None ，则表示 该模型类型的所有对象的查看操作是否被允许。 默认实现上，如果一个用户具有 “Change” 或 “View” 权限，则返回 True 。 兼容性因为新的查看权限的权限码（code）使用了 &lt;app_label&gt;.view_&lt;modelname&gt; 的格式，因此如果之前你将该权限码用于自定义的权限并且和查看权限有冲突时，应当更新自己定义的权限的权限码。 另外，如果之前使用了 django-admin-view-permission 库，可能需要花费一定的时间完成整合工作。 3 Cookie 的 SameSite 配置SameSite-cookies 是一种安全机制，用于定义cookie如何跨域发送。SameSite-cookies的目的是尝试阻止CSRF（Cross-site request forgery 跨站请求伪造）以及XSSI（Cross Site Script Inclusion (XSSI) 跨站脚本包含）攻击。 配置模块新增 SESSION_COOKIE_SAMESITE 和 CSRF_COOKIE_SAMESITE 项，如下： 12345SESSION_COOKIE_SAMESITE = 'Lax'# SESSION_COOKIE_SAMESITE = 'Strict'# SESSION_COOKIE_SAMESITE = NoneCSRF_COOKIE_SAMESITE = 'Lax' 可选的值有三种（请注意下首字母大写）： (1) “Strict”： 表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。 举个例子，如果 Github 网站设置了这个值之后，已登录的用户点击协作邮件讨论中私有项目的链接，浏览器将不会接受 Cookie ，用户也将不能访问该项目主页。 (2) “Lax”：在安全性和使用性之间作了一个平衡。属性只会在使用危险HTTP方法发送跨域cookie的时候进行阻止，例如POST方式。 (3) None：禁用该特性。 4 用户 - 权限 - 动作 文档： https://docs.djangoproject.com/en/2.1/ref/contrib/admin/actions/#setting-permissions-for-actions 和模型一样，动作也拥有权限配置了，可以限制只有某些权限的用户使用该动作。例子： 123def make_published(modeladmin, request, queryset): queryset.update(status='p')make_published.allowed_permissions = ('change',) make_published() 仅对那些通过了 ModelAdmin.has_change_permission() 检测的用户可用。 在具体表现形式上，如果一个用户没有 change 权限，在对象列表页面的动作下拉菜单不会显示 “make_published” 项目。 allowed_permissions 中的多个权限是 “或” 的关系，只要通过任何一个即可，用户就可以使用该 动作（Action）。 5 模型初始化模型类支持 __init_subclass__ 函数重写。 1234567891011&gt;&gt;&gt; class QuestBase:... # this is implicitly a @classmethod (see below for motivation)... def __init_subclass__(cls, swallow, **kwargs):... cls.swallow = swallow... super().__init_subclass__(**kwargs)&gt;&gt;&gt; class Quest(QuestBase, swallow=&quot;african&quot;):... pass&gt;&gt;&gt; Quest.swallow&apos;african&apos; 这个特性提供了 metaclass 处理复杂类继承的另一种解决方案。当一个类需要使用两个以上的元类（Metaclass）时，需要手动创建一个新的 元类 以合并这几个元类。现在可以重写 __init_subclass__ 来自定义类的创建流程，而无需创建用于合并的元类。 一般来说，这个特性很少会用得到。，相关内容 参见 PEP 487。 6 验证类视图文档： https://docs.djangoproject.com/en/2.1/topics/auth/default/#all-authentication-views contrib.auth （用户验证登录模块）的函数视图 被移除 (Removed)，可以使用对应的类视图，比如 contrib.auth.views.LoginView 类。在更新到 Django 2.1 时，必须完成这一个改变。 比如函数视图： 12345678from django.urls import re_pathfrom django.contrib.auth import views as auth_viewsurlpatterns = [ re_path(r'^login/$', auth_views.login, &#123;'template_name': 'accounts/login.html'&#125;, name='account_login'), re_path(r'^logout/$', auth_views.logout, &#123;'template_name': 'accounts/logout.html'&#125;, name='account_logout')] 可以改写为： 12345678from django.urls import re_pathfrom django.contrib.auth import views as auth_viewsurlpatterns = [ re_path(r'^login/$', auth_views.LoginView.as_view(), &#123;'template_name': 'accounts/login.html'&#125;, name='account_login'), re_path(r'^logout/$', auth_views.LogoutView.as_view(), &#123;'template_name': 'accounts/logout.html'&#125;, name='account_logout')] 7 模型字段BooleanFieldBooleanField 允许 null=True 的设置，用以替代 NullBooleanField 的功能，这也意味着后者可能在未来的版本中移除。 JSONFielddjango.contrib.postgres.fields.JSONField 查询严格区分以下两种 “空值” 形式： 键 key 的值为 null ： 使用 Q(key=None) 缺少键 key ：使用 Q(key__isnull=True) 这个特性和之前有所变化，并且是第一次完整的列在文档中，因此需要按照最新的文档来检视现有的代码。 8 数据库查询高级特性文档 https://docs.djangoproject.com/en/2.1/ref/models/database-functions 2.1 新增了一系列的文本数据库函数，包含了 Chr, Left, LPad, LTrim, Ord, Repeat, Replace, Right, RPad, RTrim, and Trim 。 Django 数据库查询的高级特性通常包括： 自定义 Lookup 查询表达式 条件表达式 数据库函数 自 1.8 以来，Django 在数据库查询支持方面越来越完善，每个版本都会有新的类和函数被添加进来，使用这些特性的优点在于： 将复杂的数据处理放在数据库层，符合 web 开发的最佳实践 可以适应于不同的数据库类型 避免多线程下的 竞态条件 问题 这些特性通常是业务相关的，可以使用 extra 和 raw 这两个原始 SQL 调用函数。 一般来说，如果现有代码可以正常工作，可以不必立即使用这些新特性。 9 其他 基于内存的缓存使用 LRU 选择算法，而不是之前的 伪随机算法。 默认的 jQuery 版本从 2.3.3 更新至 3.3.1 10 参考文档 SameSite Cookie，防止 CSRF 攻击]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的 Python 第三方库]]></title>
    <url>%2F2018%2F06%2F10%2Fmy-python-packages-and-libraries%2F</url>
    <content type="text"><![CDATA[自己常用的 Python 第三方库。 six 2 x 3 = 6 地址： https://pythonhosted.org/six/ Python2和3的兼容库。 wheel / twine第三方库 构建 - 分发 工具。 使用姿势： github + travis CI + wheel + twine ，参考 python项目持续集成与包发布 。 Django地址：https://www.djangoproject.com/ Python web 领域两大框架之一，遵循 “大而全”、“开箱即用”的原则和规范。Django 源代码内部耦合度高、文档齐全、使用者众多。 在实际业务开发方面，有非常多的第三方库可以使用，具体可参见 Django Packages 和 Awesome Django。 使用姿势： Python 3.6 + Django 2.0 Graphviz地址：http://graphviz.org/ 图形可视化软件，支持 dot 格式文件。 Sphinx文档生成工具，使用 reStructuredText 作为标记语言，同时具有以下优点（引用自 中文官方网站）： 丰富的输出格式: HTML (包括M$帮助), LaTeX (为PDF输出), manual pages(man), 纯文本 完备的交叉引用: 语义化的标签,并对 函式,类,引文,术语以及类似片段消息可以自动化链接 明晰的分层结构: 轻松定义文档树,并自动化链接同级/父级/下级文章 美观的自动索引: 可自动生成美观的模块索引 精确的语法高亮: 基于 Pygments 自动生成语法高亮 开放的扩展: 支持代码块的自动测试,自动包含Python 的模块自述文档,等等 使用姿势： github + sphinx + readthedocs click地址： https://github.com/pallets/click 命令行工具，Pallets 出品。最大的特点是使用 装饰器 实现命名格式，和 argparse 相比，更加地 “所见即所用”。 示例 12345678910111213import click@click.command()@click.option('--count', default=1, help='Number of greetings.')@click.option('--name', prompt='Your name', help='The person to greet.')def hello(count, name): """Simple program that greets NAME for a total of COUNT times.""" for x in range(count): click.echo('Hello %s!' % name)if __name__ == '__main__': hello() construct地址：http://construct.readthedocs.io/en/latest/ 一个声明式(declarative)、对称式（symmetrical）二进制解析和构建工具，适用于建立大型复杂应用程序的通信协议。 第一，功能强大。能够解决的该领域的大多数问题，并且性能表现良好。 第二，通常应用于项目级，在总体设计、技术选型的步骤。如果只有一两个功能点使用到，就不要使用该库，“杀鸡焉用牛刀”。 第三，入门/学习比较难，它引入很多的自有概念，并且一系高级功能需要通读源码。 第四，在代码方面使用了很多 Python 技巧，比如 元类、魔术方法、设计模式等，源码非常值得学习。 PyInstaller 地址：http://www.pyinstaller.org/ 之前使用过几个打包工具（py2exe、cx_freeze），还是 PyInstaller 比较好用。程序打包主要难点在于： 含有C扩展的第三方库的打包，比如 Pillow、lxml 。 数据文件的路径处理 图标文件 可以参考 python打包工具 这篇文章。 tablib地址： http://docs.python-tablib.org/en/latest/ 表格型数据的导入/导出/处理库。支持 json/xls/xlsx/yaml/dbf 等多种文件格式。 123456789101112&gt;&gt;&gt; data = tablib.Dataset(headers=[&apos;First Name&apos;, &apos;Last Name&apos;, &apos;Age&apos;])&gt;&gt;&gt; map(data.append, [(&apos;Kenneth&apos;, &apos;Reitz&apos;, 22), (&apos;Bessie&apos;, &apos;Monke&apos;, 21)])&gt;&gt;&gt; print data.json[&#123;&quot;Last Name&quot;: &quot;Reitz&quot;, &quot;First Name&quot;: &quot;Kenneth&quot;, &quot;Age&quot;: 22&#125;, &#123;&quot;Last Name&quot;: &quot;Monke&quot;, &quot;First Name&quot;: &quot;Bessie&quot;, &quot;Age&quot;: 21&#125;]&gt;&gt;&gt; print data.yaml- &#123;Age: 22, First Name: Kenneth, Last Name: Reitz&#125;- &#123;Age: 21, First Name: Bessie, Last Name: Monke&#125;&gt;&gt;&gt; data.xlsx&lt;censored binary data&gt; networkx地址： http://networkx.github.io/ 网络图的处理库，包含了： 良好的数据结构 常用的图算法 可以与 matplotlib、ECharts 等配合良好 其他 Django Rest Framework - Django的Restful框架。 django-tenant-schemas - 通过PostgreSQL Schemas在Django中实现多租户特性。当初用的时候Django1.7刚刚发布，因为Migrations的缘故，这个库还不支持，只好乖乖的使用1.6了，系统一直运行良好，也就没有必要更新了。 django-crispy-forms - 渲染表单用的，支持Bootstrap2/3/4、Foundation、uni-form等UI框架，非常好用基本上一个模板tags或者filter就可实现，不用再在Python代码中写什么 {&#39;class&#39;:&#39;form-control&#39;} 了。Django 1.11 也引入了类似 crispy-form 的基于模板的控件渲染 - 目前API还没有稳定下来，估计要等到2.0了。 django-simple-captcha - 非常简单的表单验证码字段，支持随机字符串、算术题和自定义等不同验证方式。 pyserial - Python的串口访问库。 PyModus Modbus通信协议的Python实现。 qrcode - Python的生成二维码库，包括命令行工具和代码API。 Pelican - 静态站点生成器，之前博客就是用Pelican构建的，由于在windows上比较麻烦，改成Hexo了。 lxml - xml和html解析处理库。 python-gsmmodem - Python的GSM库，包括收发短信、电话处理等功能，支持常见型号的芯片。 python-lunardate - 纯Python实现的中国农历库。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圈复杂度和McCabe]]></title>
    <url>%2F2018%2F04%2F08%2Fcyclomatic-complexity-and-mccabe%2F</url>
    <content type="text"><![CDATA[【书名】：软件架构——Python语言实现 【主题】：圈复杂度 【摘要】：圈复杂度（Cyclomatic Complexity）是衡量计算机程序复杂程度的一种措施。它根据程序从开始到结束的线性独立路径的数量计算得来的。在 Python 中可以使用 mccabe 包测量程序的圈复杂度。 1 圈复杂度对于没有任何分支的代码，它的圈复杂度为 1 ，意味着代码只有一条路径。例如下面的函数： 123def add(a, b): return a + b 对于有一条分支的代码，它的圈复杂度为 2 ，比如下面递归计算阶乘的代码： 12345def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) 在 1976 年， Thomas J. McCabe 开发了使用有向图计算复杂的算法。为了得到这个指标，程序控制流程图可以画成一个有向图，其中： 节点表示一个程序块 边表示从一个程序块到另一个程序块的控制流 根据程序的控制图，McCabe 复杂度可以表示为 1M = E - N + 2P 其中： E：边的数量 N：节点的数量 P：连接组件的数量 2 McCabe的使用在 Python 中可以使用 McCabe 包测量程序的圈复杂度。它可以当作一个独立的模块，也可以当作程序的一个插件。可以使用 pip 安装模块 1pip install mccabe 2.1 作为命令行使用和 unittest 、flake8 等工具一样。 1234567$ python -m mccabe --min 5 mccabe.py("185:1: 'PathGraphingAstVisitor.visitIf'", 5)("71:1: 'PathGraph.to_dot'", 5)("245:1: 'McCabeChecker.run'", 5)("283:1: 'main'", 7)("203:1: 'PathGraphingAstVisitor.visitTryExcept'", 5)("257:1: 'get_code_complexity'", 5) 2.2 作为 flake8 插件当 flake8 版本在 2.0 以上和 McCabe 已经安装的情况下，该插件可用。 12$ flake8 --version2.0 (pep8: 1.4.2, pyflakes: 0.6.1, mccabe: 0.2) 在命令中使用 --max-complexity 选项即可。 123$ flake8 --max-complexity 10 coolproject...coolproject/mod.py:1204:1: C901 &apos;CoolFactory.prepare&apos; is too complex (14) 根据 McCabe 圈复杂度大于 10 ，就认为是 too complex ，需要进行重构以降低复杂度。 3 程序控制图3.1 生成程序控制图以上述 factorial 函数代码为例子，将其保存为一个 factorial.py 文件中，如下： 1234567# coding=utf8def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) 第一步 使用 python -m mccabe factorial.py -d 输出 dot 文本图形描述语言的有向图。 1234567891011121314graph &#123;subgraph &#123;node [shape=circle,label=&quot;If 4&quot;] 2187726207240;node [shape=circle,label=&quot;3:0: &apos;factorial&apos;&quot;] 2187726207016;node [shape=circle,label=&quot;Stmt 5&quot;] 2187726207408;node [shape=point,label=&quot;&quot;] 2187726207296;node [shape=circle,label=&quot;Stmt 7&quot;] 2187726207520;2187726207240 -- 2187726207408;2187726207240 -- 2187726207520;2187726207016 -- 2187726207240;2187726207408 -- 2187726207296;2187726207520 -- 2187726207296;&#125;&#125; 第二步，Graphviz渲染图片 Graphviz 是 AT&amp;T Labs Research开发的图形绘制工具软件.它使用一个特定的DSL(领域特定语言): dot作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。graphviz提供丰富的导出格式，如常用的图片格式，SVG，PDF格式等。 打开 Graphviz 编辑器，将上述文档保存为 factorial.gv 文档，生成程序控制图。 第三步，计算 McCabe 复杂度 根据公式，复杂度： M = 5 - 4 + 2 x 1 = 2 4 降低复杂度使用字典替代复杂的 if-else 分支代码是 Python 中降低复杂度一个有效的方法。 比如可以将下面的分支代码： 12345678def f(x): if x == 'a': return 1 elif x == 'b': return 2 else: return 9 改为下面的字典映射代码 123456def f(x): return &#123; 'a': 1, 'b': 2 &#125;.get(x, 9) 复杂度也从 3 降低到 1 。 5 参考资料 Software Architecture with Python The Architecture of Open Source Applications]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-echarts v0.3 系列发布日志]]></title>
    <url>%2F2018%2F02%2F25%2Fdjango-echarts-030-release-note%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 v0.3.5 发布日志django-echarts v0.3.5 于 2018 年 5 月 4 日正式发布。版本日志为： NamedCharts 命名图表访问改为字典访问方式 v0.3.4 发布日志django-echarts v0.3.4 于 2018 年 4 月 23 日正式发布。版本日志为： 适配 pyecharts v0.4.x 发布独立的 borax.fetch 工具包，django_echarts.datasets.fetch 将在 v0.4 后移除 新增 django_echarts.datasets.NamedCharts 的多图表类，支持图表可命名 原有的 pyecharts.custom.page.Page 类不再推荐使用 v0.3.3 发布日志django-echarts v0.3.3 于 2018 年 4 月 3 日正式发布。版本日志为： 发布独立的 fetch 模块文档 重写 example 项目的部分逻辑 v0.3.2 发布日志django-echarts v0.3.2 于 2018 年 3 月 13 日正式发布。版本日志为： 移除 Django 的显示依赖 移除对 numpy.Array 的默认json编码 v0.3.1 发布日志django-echarts v0.3.1 于 2018 年 3 月 8 日正式发布。版本日志为： 恢复对 Django 1.11 LTS 的支持 改善 fetch 模块调用方式，ifetch_multiple 函数的关键字参数不再需要重复指定默认值 fetch 模块函数支持自定义 getter 参数 ECharts 默认版本更新至v4.0.4 支持 ECharts 4.0 SVG渲染器的配置 1 fetch 模块改进v0.3.1 基于 PEP 3102 调整了 fetch 模块所有函数的定义形式。由 12def ifetch_multiple(iterable, defaults, getter, *keys): pass 更改为 12def ifetch_multiple(iterable, *keys, defaults=None, getter=None): pass 其中 default / defaults / getter 三个可选参数均要求以关键字形式传入。 之前无论是否使用自己的 defaults 均必须传入以符合位置参数的要求，现在无需这种做法。 之前： 1ifetch_multiple(DICT_LIST_DATA, &#123;&#125;, None, 'name', 'age') 现在： 1ifetch_multiple(DICT_LIST_DATA, 'name', 'age') 2 增加自定义 getter 回调函数一个简单的例子： 12345678910class MockItem: def __init__(self, x, y, z): self._data = &#123;'x': x, 'y': y, 'z': z&#125; def get(self, key): return self._data.get(key)my_getter = lambda item, key: item.get(key)data_list = [MockItem(1, 2, 3), MockItem(4, 5, 6), MockItem(7, 8, 9)]xs, ys, zs = fetch(data_list, 'x', 'y', 'z', getter=my_getter) getter 必须是一个回调函数，函数符合以下的要求： 必须含有名称为 item 和 key 的两个参数 item 表示单个实体类对象；key 表示索引、属性、键值名称 3 支持 ECharts SVG 配置django-echarts 新增了一个名为 renderer 的项目配置项，可选值包括 &#39;canvas&#39; 和 &#39;svg&#39; 。 django-echarts 按照以下顺序选择渲染方式： 图表属性 Chart.renderer 项目配置的 DJANGO_ECHARTS[‘renderer’] 的设置 django-echarts 默认使用 canvas 渲染器，可以通过以下方式更改为 svg 渲染。 1234DJANGO_ECHARTS = &#123; 'echarts_version':'4.0.4', 'renderer': 'svg'&#125; 注意的是只有 echarts_version 大于 4 时，才可以使用 svg 渲染。django-echarts 并不会强制检查这一点，请使用者自行确认。 v0.3.0 发布日志django-echarts v0.3.0 正式发布。该版本将 仅支持 Python3.5+ 以及 Django2.0+ 的环境，同时该增加了若干个功能特性： 移除对 Python2 的支持 新增计数模块 datasets.section_counter 部分函数增加 Key-Only Arguments ( PEP 3102 ) 限定 下载命令增加 --fake 选项，支持预览调试 整合单元测试 发布数据构建文档 1 Python3迁移django-echarts 使用了更为激进的迁移策略，v0.3之后将仅支持 Python3.5+ 以及 Django2.0+ 的运行环境，不再支持 Python2 ，django-echarts v0.3 将在 Python2 环境中出现语法层面的错误。 具体来说就是 PEP 3102 的应用，在3.X中新增了强制关键字参数传递（Keyword-Only Arguments）中，定义的形式为使用 * 单独占用一个参数，表示之后的参数必须以关键字方式传入参数，否则将引发TypeError异常。 例子： django_echarts.plugins.host.HostStore 12345class HostStore(object): HOST_DICT = &#123;&#125; def __init__(self, *, context=None, default_host=None): pass django_echarts.plugins.store.SettingsStore 123class SettingsStore(object): def __init__(self, *, echarts_settings=None, extra_settings=None, **kwargs): pass 是否使用 Keyword-Only Arguments ，自己根据实际情况总结了一些应用场景。 函数有两个以上的可选参数（提供了默认参数） 这些参数的功能意义是平等的，通常可任意调换位置 比如 django_echarts.datasets.section_counter.BSectionIndex 类的 __init__ 就没有使用这个特性，因为 [lower, upper] 更符合实际表达形式。 123class BSectionIndex(BIndex): def __init__(self, lower=None, upper=None): pass 2 计数模块 section_counter该模块针对常见的数据计数业务场景进行的封装，该模块基于内置 collections.Counter 模块，并基于此进行了一些扩展。 BSectionCounter 库用于计算符合一系列条件的数目计数类。 先看一个例子 123456789101112data_list = list(df['stars'])labels = ['00~00', '01~10', '11~50', '51~100', '101~500', '501~1000', '&gt;1000']sizes = []sizes.append(len([pp for pp in data_list if pp == 0]))sizes.append(len([pp for pp in data_list if pp &gt;= 1 and pp &lt;= 10]))sizes.append(len([pp for pp in data_list if pp &gt;= 11 and pp &lt;= 50]))sizes.append(len([pp for pp in data_list if pp &gt;= 51 and pp &lt;= 100]))sizes.append(len([pp for pp in data_list if pp &gt;= 101 and pp &lt;= 500]))sizes.append(len([pp for pp in data_list if pp &gt;= 501 and pp &lt;= 1000]))sizes.append(len([pp for pp in data_list if pp &gt;= 1001]))stargazer_bar = Bar("stars", "stars hist graph of users", width=CHART_WIDTH)stargazer_bar.add("", labels, sizes, is_label_show=True, mark_line=["average"]) 使用 BSelectionCounter 后，简化为 12345678910111213data_list = list(df['stars'])rc1 = BSectionCounter( BValueIndex(0), BSectionIndex(1, 10), BSectionIndex(11, 50), BSectionIndex(51, 100), BSectionIndex(101, 500), BSectionIndex(501, 1000), BSectionIndex(1001))labels, sizes = rc1.feed_as_axises(data_list)stargazer_bar = Bar("stars", "stars hist graph of users", width=CHART_WIDTH)stargazer_bar.add("", labels, sizes, is_label_show=True, mark_line=["average"]) 3 下载命令支持预览调试增加 --fake 后，命令将仅打印出对应文件的下载路径、引用路径、存储位置，而 不会进行任何实际的下载操作 ，可用于预览调试。 例子： 123456789&gt;&gt;&gt;python manage.py download_echarts_js echarts.min china --fake[Info] Download Meta for [echarts.min] Remote Url: https://cdn.bootcss.com/echarts/3.7.0/echarts.min.js Local Url: /static/echarts/echarts.min.js Local Path: E:\projects\django-echarts\example\static\echarts\echarts.min.js[Info] Download Meta for [china] Remote Url: http://echarts.baidu.com/asset/map/js/china.js Local Url: /static/echarts/china.js Local Path: E:\projects\django-echarts\example\static\echarts\china.js fake 命名灵感来自于 migrate命令 。 4 发布数据构建文档v0.3.0 开始，有关数据构建的文档将独立出来。一方面，从功能上来说，数据构建模块仅是数据创建和渲染过程中可能使用到的工具性代码，并不是核心功能。 另一方面，由于该模块的工具特性使其具有更为一般的通用性，因此在后续开发中，有考虑将其纳入 正在编写的 “pyecharts-contrib计划’’之中。 pyecharts-contrib 计划旨在于构建通用、简单的脚手架模板，和提供解决数据可视化领域中一些常见问题的工具集合。使用者可以迅速地基于 contrib 开始新的项目。pyecharts-contrib 将追求遵循“batteries included” philosophy 。pyecharts-contrib 命名的灵感来自于 django.contrib 。 目前，该计划正在紧张有序的进行中。 5 其他功能改进其他部分功能改进。 FieldValuesQuerySet.fetch_values 类和方法重名为 AxisValuesQuerySet.as_axis_values 更加符合实际意义 整合测试样例]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，2018！]]></title>
    <url>%2F2017%2F12%2F30%2Fhappy-2018%2F</url>
    <content type="text"><![CDATA[12345 ____ ___ _ ___|___ \ / _ \ / | ( _ ) __) | | | | | | | / _ \ / __/ | |_| | | | | (_) ||_____| \___/ |_| \___/ echo “2018” | figlet 2017年技术大事记又到了一年总结的时间了，总的来说，2017年是平平淡淡的，按部就班地完成各项任务。 （按时间先后排序） 第一次参加 OSC源创会 主持并完成公司 NMS v2.0 项目的重构和试运行工作 维护 HydrantDeviceSystem 项目 完成个人项目《水资源费征收工作平台》，发布v1.2.X系列版本 阅读《构建之法》等技术书籍 加入 pyecharts开源项目团队 撰写26篇博客文章 2017年博客总结2017年是博客重建后的第一年，一共写了 26 篇文章，大概每个月写两篇，主要围绕基础技术而展开的。 按照年份统计数据见下表： 分类 数目 占比 2017 26 68.42% 2016 9 23.69% 2015 3 7.89% 目前总计达到38篇文章，其中15和16年的文章是从其他地方精选整合而来的，数量相对就比较少了。 按照分类统计如下表： 分类 数目 占比 编程 24 63.15% 技术研究 10 26.32% 生活 4 10.53% 使用 Echarts 渲染图表如下： 目前还是偏重于语言基础技术层次，系统设计和原理性的文章还是偏少。希望自己2018年在这方面需要一定的加强。 2018年期望与规划 本职工作 pyecharts项目 https://github.com/pyecharts/pyecharts django-echarts项目 https://github.com/kinegratii/django-echarts 系统架构设计师资格考试 （2018年11月10-11日） 技术书籍阅读 继续撰写博客文章，总结工作项目经验 BWS v2.0 重构工作 系统架构设计师考试考试目标 系统架构设计师是一个最终确认和评估系统需求，给出开发规范，搭建系统实现的核心构架，并澄清技术细节、扫清主要难点的技术人员。 系统架构设计师考试合格人员能够根据系统需求规格说明书，结合应用领域和技术发展的实际情况，考虑有关约束条件，设计正确、合理的软件架构，确保系统架构具有良好的特性；能够对项目的系统架构进行描述、分析、设计与评估；能够按照相关标准编写相应的设计文档；能够与系统分析师、项目管理师相互协作、配合工作；具有高级工程师的实际工作能力和业务水平。 考试要求 （1）掌握计算机硬软件与网络基础知识； （2）熟悉信息系统开发过程； （3）理解信息系统开发标准、常用信息技术标准； （4）熟悉主流的中间件和应用服务器平台； （5）掌握软件系统建模、系统架构设计技术； （6）熟练掌握信息安全技术、安全策略、安全管理知识； （7）了解信息化、信息技术有关法律、法规的基础知识； （8）了解用户的行业特点，并根据行业特点架构合适的系统设计； （9）掌握应用数学基础知识； （10）熟练阅读和正确理解相关领域的英文文献。 考试科目设置 （1）信息系统综合知识，考试时间为150分钟，笔试，选择题； （2）系统架构设计案例分析，考试时间为90分钟，笔试，问答题； （3）系统架构设计论文，考试时间为120分钟，笔试，论文题。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>里程碑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts 开发笔记]]></title>
    <url>%2F2017%2F11%2F23%2Fpyecharts-development-note%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 本文记录了在 pyecharts 开发过程中的一些想法思路和具体问题分析解决的方案。写作本文的目的主要有两个：一是工作总结，每完成一项工作需要静下心来总结工作得失，这就是一种进步和成长；二是技术分享，对于同一个知识和技术，每个人的理解和思考都是不同的，博客提供了一个很好的分享平台。 本文基于 PR 自定义模板 整理。 总体思想最初的想法大约七八月份的时候就尝试了写了 django-echarts 这个项目，发现一些细节性问题处理起来不太方便，更为主要的是一个整体的架构没有完整的建立起来。直到十月份的时候才腾下时间思考这个问题。 因为本人是主要从事 Django 开发的，因此代码风格和思想难免受到 Django 的影响，比如基于类的代码、Mixin模式，还有一些变量命名等等。 从 OPP 到 OOP面向过程和面向对象是两种不同的设计和编码方法。在我看来，虽然二者互有优劣，但并不是排他的。在前期开发过程中，使用面向过程的方法更有助于我们描述功能，把场景活动翻译成程序语言，因为我们自己就是一个过程性的思维，“先做什么，再做什么”。 随着开发不断推进，我们逐渐了解其内在的联系，抽象出对象、动作、接口等概念，进而能够应用继承、多态等面向对象的思想。 Python 之所以称之为万能胶水，我觉得一个原因是 Python 在面向过程和面向对象之间切换自由。描述同一语言 Python 不像 Java 那些，一上来就各种类，各种继承。 规则、公开、API这个主要是和 Python 语言特点有关，Python 是比较灵活的。比如 Python 对于属性权限限制是“约定俗称”的。下面的 js_dependencies 属性应当被看成是私有的。 123456class Chart(object): def __init__(self): self._js_dependencies = &#123;&#125; @property def js_dependencies(self): return self._js_dependencies 但是，你也可以直接使用 chart._js_dependencies 来访问，只不过： IDE 可能会发出警告（warnings） 变更无法预料，从开发者的角度，无需为此语句有效性提供任何保障 使用 @property 语法公开了该类的一个访问接口。 当然，何时公开、怎么公开又是另外一个问题了。 持续开发与废弃策略这里的持续性开发指的的公共API的稳定性，更为确切的说是废弃策略。随着项目的不断推进，新代码不断加入，旧代码不断淘汰。但由于开源项目的公开性和考虑其稳定性，无用的代码并总是立即被删除，而是经过一段时间后再删除，在这方面，个人 Django 项目做的比较好，将旧有代码按照淘汰进程分几个等级(链接) ，我自己在此基础上增加了一个等级：Not Recommend ，通常用于重大变更，涉及到核心代码 不再推荐使用(Not Recommend)：仅在更新日志和文档中表明 废弃(Deprecated)：使用 warnings 模块表明 移除(Removed)：删除相关代码 功能设计与实现html转义与Python实现转义字符串（Escape Sequence）也称字符实体(Character Entity)。在HTML中，定义转义字符串的原因有两个：第一个原因是像“&lt;”和“&gt;”这类符号已经用来表示HTML标签，因此就不能直接当作文本中的符号来使用。为了在HTML文档中使用这些符号，就需要定义它的转义字符串。当解释程序遇到这类字符串时就把它解释为真实的字符。在输入转义字符串时，要严格遵守字母大小写的规则。第二个原因是，有些字符在ASCII字符集中没有定义，因此需要使用转义字符串来表示。 字符串安全 如果启用了手动转义，按需转义变量就是 你的 责任。要转义什么？如果你有 一个 可能 包含 &gt; 、 &lt; 、 &amp; 或 &quot; 字符的变量，你必须转义 它，除非变量中的 HTML 有可信的良好格式。转义通过用管道传递到过滤器 |e 来实现: 。 当启用了自动转移，默认会转移一切，除非值被显式地标记为安全的。可以在应用中 标记，也可以在模板中使用 |safe 过滤器标记。这种方法的主要问题是 Python 本 身没有被污染的值的概念，所以一个值是否安全的信息会丢失。如果这个信息丢失， 会继续转义，你最后会得到一个转义了两次的内容。 显示地标记值安全的有两种方式： 在模板中使用 safe 过滤器 传递给模板的值用 Markup 类包裹下 根据 官方文档 ，Markup 可以无需转义即可标记一个字符串为安全的。这是通过实现 __html__ 接口来实现的。Markup 是 unicode 的直接子类，拥有其众多的方法和属性。核心代码如下： 123class Markup(text_type): def __html__(self): return self 其使用方式如下： 12345678&gt;&gt;&gt; Markup("Hello &lt;em&gt;World&lt;/em&gt;!")Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!')&gt;&gt;&gt; class Foo(object):... def __html__(self):... return '&lt;a href="#"&gt;foo&lt;/a&gt;'...&gt;&gt;&gt; Markup(Foo())Markup(u'&lt;a href="#"&gt;foo&lt;/a&gt;') Jinja2 的 Markup 类至少与 Pylons 和 Genshi 兼容。预计不久更多模板 引擎和框架会采用 __html__ 的概念。 Django 目前也支持 __html__ 接口协议。其数据实体定义在 django.utils.safestring.SafeData 。源代码如下： 12345678class SafeData(object): def __html__(self): """ Returns the html representation of a string for interoperability. This allows other template engines to understand Django's SafeData. """ return self js 内嵌引入的正则替换主要指的是 pyecharts.utils.freeze_js 的原理是先渲染生成 html 文件字符串，再使用正则替换，这在之前是没有问题，引入自定义模板后，模板文件也有可能引用其他文件（如 bootstrap.min.js），这样的话，碰到该行直接出现错误。 改进的办法是在渲染的过程就根据配置决定是否替换，因此该函数也可移除。 和 Flask 整合问题 此种方式是整合过程中产生一个代码版本，后来发现会破坏 Flask 原有的功能，因此改写为下一节的代码版本。但此种整合方式也是思考的一个过程，因此没有将此删除。 这是上周末刚刚完成的内容，解决在 Flask 框架中使用模板函数的问题。主要代码摘抄如下： 12345678910111213from jinjia2 import Environment as BaseEnvironmentclass Environment(BaseEnvironment): """Works like a regular Jinja2 environment but has some additional knowledge of how Flask's blueprint works so that it can prepend the name of the blueprint to referenced templates if necessary. """ def __init__(self, app, **options): if 'loader' not in options: options['loader'] = app.create_global_jinja_loader() BaseEnvironment.__init__(self, **options) self.app = app pyecharts 模板引擎 1234567891011121314151617181920212223242526272829from jinjia2 import Environmentclass EchartsEnvironment(Environment): """Built-in jinja2 template engine for pyecharts """ def __init__(self, pyecharts_config=None, *args, **kwargs): self._pyecharts_config = pyecharts_config or PyEchartsConfig() loader = kwargs.pop('loader', None) if loader is None: loader = FileSystemLoader( self._pyecharts_config.echarts_template_dir) super(EchartsEnvironment, self).__init__( keep_trailing_newline=True, trim_blocks=True, lstrip_blocks=True, loader=loader, *args, **kwargs) # Add PyEChartsConfig self.globals.update(&#123; 'echarts_js_dependencies': echarts_js_dependencies, 'echarts_js_dependencies_embed': echarts_js_dependencies_embed, 'echarts_container': echarts_container, 'echarts_js_content': echarts_js_content, 'echarts_js_content_wrap': echarts_js_content_wrap &#125;) 代码解析要点如下： Flask.Environment 新增了两点扩展： 增加了一个必要的 app 成员变量，这是一个 Flask 实例 同时提供了默认的 loader 。 pyecharts.engine.EchartsEnvironment 也有两点扩展： 增加了一个可选 pyecharts_config 成员变量 同时提供了默认的 loader。 整合的目标是实现一个类，使得同时具有以上四个特点。 主要整合方式： 第一种：Mixin 方式。这种方式是实现最为简单，但是在此种情况下却无法使用，这是因为二者都重写了 __init__ ，都涉及到对象的创建过程，不建议使用。 第二种是代码混合方式：让一个直接继承 jinja2.Environment ，将另外一个的代码搬入。因为 Flask.Environment 的代码比较少，继承 EchartsEnvironment 是更为优化的。 下面是使用第二种方式整合的最终代码及其使用方法： 123456789101112131415161718# ----- Adapter ---------class FlaskEchartsEnvironment(EchartsEnvironment): def __init__(self, app, **kwargs): EchartsEnvironment.__init__(self, **kwargs) self.app = app# ---User Code ----class MyFlask(Flask): jinja_environment = FlaskEchartsEnvironment jinja_options = &#123;'pyecharts_config': PyEchartsConfig( jshost='https://cdn.bootcss.com/echarts/3.7.2', echarts_template_dir='templates' )&#125;app = MyFlask(__name__) 因为 EchartsEnvironment 显式传入了 loader 参数，抵消了 Environment 类 loader 的重写逻辑。 目前该代码放在 demo 内，没有整合为 pyecharts 一部分。 web框架整合优化上一节实现有个重大问题，表面上看会覆盖原有模板目录功能，导致必须现实设置 echarts_template_dir 。因此必须继承 flask.templating.Environment 以保全全部功能。 12345678910111213141516171819202122232425from __future__ import unicode_literalsimport randomimport datetimefrom flask import Flask, render_templatefrom flask.templating import Environmentfrom pyecharts import HeatMapfrom pyecharts.engine import PyEchartsConfigMixin, ECHAERTS_TEMPLATE_FUNCTIONSfrom pyecharts.conf import PyEchartsConfigclass FlaskEchartsEnvironment(Environment, PyEchartsConfigMixin): pyecharts_config = PyEchartsConfig( jshost='https://cdn.bootcss.com/echarts/3.7.2' ) def __init__(self, *args, **kwargs): super(FlaskEchartsEnvironment, self).__init__(*args, **kwargs) self.globals.update(ECHAERTS_TEMPLATE_FUNCTIONS)class MyFlask(Flask): jinja_environment = FlaskEchartsEnvironmentapp = MyFlask(__name__) 之后和标准的 Flask 项目一样使用。 命名借鉴比如 Page.from_charts 借鉴了 django.db.models.Manager.from_queryset 。又比如类 Mixin 模式变量方法的命名。 12345678clas DemoMixin(object): foo1 = None foo2 = None def get_foo1(self): return self.foo1 def get_foo2(self): return self.foo2 Python 2/3json.dumps 输出结果12345import jsonc = &#123;'date':'2017-01-01', 'a':'1'&#125;data = json.dumps(c, indent=0)print(len(data))print('*'.join(data)) 上述代码在 2 和 3 环境下运行结果是不同的，结果如下： 环境：Python 3.6.3 (v3.6.3:2c5fed8, Oct 3 2017, 18:11:49) [MSC v.1900 64 bit (AMD64)] 1234534&#123;**&quot;*d*a*t*e*&quot;*:* *&quot;*2*0*1*7*-*0*1*-*0*1*&quot;*,**&quot;*a*&quot;*:* *&quot;*1*&quot;**&#125; 环境：2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:25:58) [MSC v.1500 64 bit (AMD64)] 1234535&#123;**&quot;*d*a*t*e*&quot;*:* *&quot;*2*0*1*7*-*0*1*-*0*1*&quot;*,* **&quot;*a*&quot;*:* *&quot;*1*&quot;**&#125; 简而言之，将字典转化为json字符串时，python2 在每一对键值分割符“,”增加了一个空格 下面是测试 pyecharts.utils.json_dumps 功能的测试代码（使用 nosetests 框架）。影响到的是最后测试的时候直接使用表达式结果作为 assert 语句的第一个参数，这是一个取巧的方法，因为目前没有引入 six 等兼容库，代码需要多写。 1234567891011121314151617181920212223242526272829303132import jsonfrom datetime import date, datetimeclass UnknownTypeEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, (datetime.datetime, datetime.date)): return obj.isoformat() else: try: return obj.astype(float).tolist() except Exception: try: return obj.astype(str).tolist() except Exception: return json.JSONEncoder.default(self, obj)def json_dumps(data, indent=0): return json.dumps(data, indent=indent, cls=UnknownTypeEncoder)def test_json_encoder(): """ Test json encoder. :return: """ data = date(2017, 1, 1) eq_(json.dumps(&#123;'date': '2017-01-01', 'a': '1'&#125;, indent=0), json_dumps(&#123;'date': data, 'a': '1'&#125;)) data2 = &#123;'np_list': np.array(['a', 'b', 'c'])&#125; data2_e = &#123;'np_list': ['a', 'b', 'c']&#125; eq_(json.dumps(data2_e, indent=0), json_dumps(data2)) 上述测试代码是一个不好的实践方法，把测试目标改变了，上面测试的是 data2_e 和 data2 的 json 输出是否一致，而不是 data2 的 json 是否符合预期的 json 格式，这二者是截然不同的，显然我们要测试的是后者。 假设 json.dumps 输出不是符合标准的 json 数据，上述测试案例可以通过，但在之后的功能测试是不能通过的。 上述的测试代码已经蕴含了 json.dumps 一定能输出标准的 json 数据，这当然是。 按照测试原则，assert 语句的第一个应当是表征字面量，下面就是一个简单的对比。 123456DEFAULT_HOST = 'https://chfw.github.io/jupyter-echarts/echarts'def test_pyecharts_remote_jshost(): target_config = PyEchartsConfig(jshost=DEFAULT_HOST) eq_('https://chfw.github.io/jupyter-echarts/echarts', target_config.jshost) # 良好的实践 eq_(DEFAULT_HOST, target_config.jshost) # 糟糕的实践 函数不定参数定义与调用在 Python3 中，函数定义时允许常规变量(regular argument)出现在一个不定参数(varargs argument)之后，如下面的函数。 12def sortwords(*wordlist, case_sensitive=False): ... 需要注意的是，调用的时候 case_sensitive 必须以关键字形式传入，类似 sortwords(&#39;Apple&#39;, &#39;Orange&#39;, case_sensitive=True) 。 更多的资料可以参考 PEP 3102 。 之前在考虑 page.from_charts(cls, *charts) 是否添加 jshost 相关参数的时候碰到这个问题，最后考虑不添加这个特性，主要基于下面两个原因： 1 如果添加这个参数，会再调用时引起歧义，有以下两种种定义形式： 第一种： Page.from_charts(jshost=None, *args) 这种方式有个问题，就是即使 jshost 无意设置，也需使用 None 占位。 Page.from_charts(chart1, chart2) 调用从字面上是将两个图表合并，实际上只有一个，调用时会把 chart1 传给 jshost 第二种：Page.from_charts(*args, jshost=None) 这个将可选的参数放置在最后，可以解决 Page.from_charts(chart1, chart2) 字面和实际效果一致，但是仅Python3.5+支持 2 从功能上来看，该方法只是 __init__ 方法的补充，不一定非要和其等价。 致谢非常感谢 @chenjiandongx 和 @chfw 两位提供问题讨论和代码复查方面的经验。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑开发软件的5个清单]]></title>
    <url>%2F2017%2F10%2F09%2Fpc-software-checklist%2F</url>
    <content type="text"><![CDATA[长假后的第一天，把电脑换成win10 64位，也重装了一些软件。本文将记录一些其中使用的软件，包含基本软件和开发工具。 清单1：基本软件 微软自带输入法 好压：压缩软件 美图看看 everything：文件搜索 驱动精灵 福昕PDF阅读器 ： 比较好用；支持下本地的企业 google：浏览器 adblock 广告去除插件 octree 代码浏览插件 bing 搜索引擎设置 书签导入 Fences桌面整理软件 ：主要是图标分类分区显示 OneDrive文件存储 网易云音乐 closeAD 弹窗广告拦截器 清单2：基本开发工具 notepad++:记事本 atom 代码编辑器 typora:Markdown编辑器 git：代码管理库 git账号设置 SSH公钥部署到 github 和 码云 清单3：社交工具 邮箱客户端 : 使用自带的 Windows Mail 即可 公司邮箱 个人邮箱 微信电脑版 QQ 电脑版 TIM 电脑版 清单4：语言及其环境 Java运行环境 JRE环境变量配置 python2.7 ：基本上不再安装了 python3.6：追求最新的版本 Pycharm：Python开发环境 pip源设置 nodejs 8 npm源设置 常用全局包 hexo ：博客构建工具 docsify ： 文档生成工具 ionic ： 混合 APP 开发框架 vuejs ： 前端开发主力框架 hexo：博客构建 清单5：项目环境 Hexo博客 Hexo安装 依赖重新安装 Graphviz 可视化工具]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django2笔记:路由path语法]]></title>
    <url>%2F2017%2F09%2F25%2Fdjango2-url-path%2F</url>
    <content type="text"><![CDATA[9月23，Django 发布了2.0a1版本，这是一个 feature freeze 版本，如果没有什么意外的话，2.0正式版不会再增加新的功能了。按照以往的规律，预计正式版将在12月发布。 备注：Django 2.0 于12月2日已经正式发布。 （链接） 2.0无疑是一个里程碑版本，移除了对 Python2.7 的支持，最少需要 3.4 以上，建议使用3.5以上的版本。 What’s new in Django2.0 文档中一共列出了三个新的特性： 更简单的URL路由语法 (Simplified URL routing syntax) admin应用的针对移动设备的优化改进(Mobile-friendly contrib.admin) 支持SQL开窗表达式(Window expressions) 第一个特性，主要用于动态路由定义上。在Django2.0代码实现中，主要的变化是新增了 django.urls.path 函数，它允许使用一种更加简洁、可读的路由语法。比如之前的版本的代码： 1url(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$', views.year_archive), 在新版本中也可以写为： 1path('articles/&lt;int:year&gt;/', views.year_archive), 新语法支持类型转化，在上述的例子中， year_archive 函数接收到的year参数就变成整数而不是字符串。 如果你有接触过 Flask 框架，就会发现和 Variable-Rules 的语法形式和功能都是相类似的。 一 问题引入下面是 Django1.X 的一段代码： 123456789101112131415161718192021from django.conf.urls import urldef year_archive(request, year): year = int(year) # convert str to int # Get articles from databasedef detail_view(request, article_id): passdef edit_view(request, article_id): passdef delete_view(request, article_id): passurlpatterns = [ url('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/', year_archive), url('article/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/detail/', detail_view), url('articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/edit/', edit_view), url('articles/(?P&lt;article_id&gt;[a-zA-Z0-9]+)/delete/', delete_view),] 考虑下这样的两个问题： 第一个问题，函数 year_archive 中year参数是字符串类型的，因此需要先转化为整数类型的变量值，当然 year=int(year) 不会有诸如如TypeError或者ValueError的异常。那么有没有一种方法，在url中，使得这一转化步骤可以由Django自动完成？ 第二个问题，三个路由中 article_id 在业务中表示同一个字段，使用同样的正则表达式，但是你需要写三遍，当之后 article_id 规则改变后，需要同时修改三处代码，那么有没有一种方法，只需修改一处即可？ 在 Django2.0 中，可以使用 path 解决以上的两个问题。 二 使用示例这是一个简单的例子： 12345678910from django.urls import pathfrom . import viewsurlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;int:year&gt;/', views.year_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug&gt;/', views.article_detail),] 基本规则： 使用尖括号(&lt;&gt;)从url中捕获值。 捕获值中可以包含一个转化器类型（converter type），比如使用 &lt;int:name&gt; 捕获一个整数变量。若果没有转化器，将匹配任何字符串，当然也包括了 / 字符。 无需添加前导斜杠。 以下是根据 2.0官方文档 而整理的示例分析表： 请求URL 匹配项 视图函数调用形式 /articles/2005/03/ 第3个 views.month_archive(request, year=2005, month=3) /articles/2003/ 第1个 views.special_case_2003(request) /articles/2003 无 - /articles/2003/03/building-a-django-site/ 第4个 views.article_detail(request, year=2003, month=3, slug=”building-a-django-site”) 三 path转化器 文档原文是Path converters，暂且翻译为转化器。 Django默认支持以下5个转化器： str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式 int,匹配正整数，包含0。 slug,匹配字母、数字以及横杠、下划线组成的字符串。 uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。 path,匹配任何非空字符串，包含了路径分隔符 四 自定义转化器4.1 定义对于一些复杂或者复用的需要，可以定义自己的转化器。转化器是一个类或接口，它的要求有三点： regex 类属性，字符串类型 to_python(self, value) 方法，value是由类属性 regex 所匹配到的字符串，返回具体的Python变量值，以供Django传递到对应的视图函数中。 to_url(self, value) 方法，和 to_python 相反，value是一个具体的Python变量值，返回其字符串，通常用于url反向引用。 先看看默认的 IntConverter 和 StringConverter 是怎么实现的： 123456789101112131415161718class IntConverter: regex = '[0-9]+' def to_python(self, value): return int(value) def to_url(self, value): return str(value)class StringConverter: regex = '[^/]+' def to_python(self, value): return value def to_url(self, value): return value 第二个例子，是自己实现的4位年份的转化器。 12345678class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value 4.2 注册使用register_converter 将其注册到URL配置中： 1234567891011from django.urls import register_converter, pathfrom . import converters, viewsregister_converter(converters.FourDigitYearConverter, 'yyyy')urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;yyyy:year&gt;/', views.year_archive), ...] 五 使用正则表达式如果上述的paths和converters还是无法满足需求，也可以使用正则表达式，这时应当使用 django.urls.re_path 函数。 在Python正则表达式中，命名式分组语法为 (?P&lt;name&gt;pattern) ，其中name为名称， pattern为待匹配的模式。 之前的示例代码也可以写为： 12345678910from django.urls import path, re_pathfrom . import viewsurlpatterns = [ path('articles/2003/', views.special_case_2003), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/', views.year_archive), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/', views.month_archive), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[^/]+)/', views.article_detail),] 这段代码和之前的代码实现了基本的功能，但是还是有一些区别： 这里的代码匹配更加严格，比如year=10000在这里就无法匹配。 传递给视图函数的变量都是字符串类型，这点和 url 是一致的。 无命名分组 一般来说，不建议使用这种方式，因为有可能引入歧义，甚至错误。 六 Import变动django.urls.path 可以看成是 django.conf.urls.url 的增强形式。 为了方便，其引用路径也有所变化，请注意下 urls 包路径的变更，不再是 conf 的子包了，目前和 views 、conf 一样，被认为是 Django 的核心组件。 1.X 2.0 备注 - django.urls.path 新增，url的增强版 django.conf.urls.include django.urls.include 路径变更 django.conf.urls.url django.urls.re_path 异名同功能，url不会立即废弃 七 代码改写将“问题引入”一节的代码使用新的path函数可以改写如下： 12345678910111213141516171819202122232425262728293031323334from django.urls import path, register_converterfrom django.urls.converters import SlugConverterclass FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % valueregister_converter(SlugConverter, 'article_id')register_converter(FourDigitYearConverter, 'year')def year_archive(request, year): print(type(year)) # &lt;class 'int'&gt; # Get articles from databasedef detail_view(request, article_id): passdef edit_view(request, article_id): passdef delete_view(request, article_id): passurlpatterns = [ path('articles/&lt;year:year&gt;/', year_archive), path('article/&lt;article_id:article_id&gt;/detail/', detail_view), path('articles/&lt;article_id:article_id&gt;/edit/', edit_view), path('articles/&lt;article_id:article_id&gt;/delete/', delete_view),] 八 总结第一，目前 路由（url）到视图（View）的流程可以概括为四个步骤： url匹配 正则捕获 变量类型转化 视图调用 Django2.0 和之前相比多了 变量类型转化 这一步骤。 第二，新的path语法可以解决一下以下几个场景： 类型自动转化 公用正则表达式 问题描述可参考 “问题引入” 一节。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-Echarts系列：js依赖文件管理]]></title>
    <url>%2F2017%2F09%2F06%2Fdjango-echarts-js-manage%2F</url>
    <content type="text"><![CDATA[本文已收录于 《pyecharts 开发专辑》 。 django-echarts 是本人正在开发的一个开源项目，该项目旨在将 pyecharts 库整合到Django web框架中，从而形成echarts-python-django 大整合的项目。 继之前简单的一个使用示例之后，最近花了几天完成了一种的一个功能插件：js依赖文件管理。 1 Django-Echarts概述django-echarts这个项目的目标和pyecharts是一致的，即在目标html页面上渲染图表。要完成一个Echarts图表，从最后渲染完成的HTML结构来看，至少应当包含以下三个部分： 图表容器控件，比如&lt;div id=&quot;id_mycharts&quot;&gt;&lt;/div&gt; js依赖文件，比如 &lt;script src=&#39;/static/echarts/echarts.min.js&#39;&gt;&lt;/script&gt; 图表初始化代码,代码中 myCharts.setOptions(Foo) 所在的script标签。 这个排序按照一般出现的顺序，将所有 script 标签放置在body标签的最后，有利于页面的加载。 在这一过程中，pyecharts 项目为此做了大量的工作，使得我们能够快速地依据功能要求构建出模板渲染所需的数据，这些数据在Django模板系统中称之为 Context。 在实际应用过程中，每个页面的结构都是各式各样的，不能一概而论，因此django-echarts的主要职责： 如何创建上述三个标签（代码片段）。 上述标签在目标html的位置和结构由用户选择。 对于一些简单的页面，可以提供一些shortcut工具。 2 设计思路2.1 目标三者之前没有太大的关联性，是可以单独拿出来讨论其设计思想和实现方式的。js 依赖文件管理最终的目标是构建js文件路径字符串。 12&lt;script src='/static/echarts/echarts.min.js'&gt;&lt;/script&gt;&lt;script src='/static/echarts/map/china.js'&gt;&lt;/script&gt; 虽然最后生成的是一个或多个script标签，但依据 Django MTV 原则，标签的构建应当由模板系统负责。 核心的src属性由路径和js文件名两部分组成。路径的意义在于，对于同一个 echarts.min.js 可以由不同的地方提供，这称之为repository。而文件名是由用户输入提供的。使用代码表示如下： 123def generte_js_link(js_name): host = '' # TODO Where to pick a host according the settings return '&#123;host&#125;/&#123;js_name&#125;.js'.format(host=host, js_name=js_name) 2.2 问题综上所述，js 依赖文件管理解决的问题： 需要管理哪些依赖文件 哪些repository可以提供js文件，其中哪些可以实现对其的支持。 如何在不同repository之间尽可能平稳的切换，即它们之间必须提供统一的API 需要对外提供哪些API，即在哪些情况下可能使用到这个功能 3 仓库(repository)与文件按照正常逻辑，文件名由用户根据实际功能需求指定，其有效性应当交由用户确保。在实际过程不同repository可提供的文件是不一样。js文件分为核心库文件和地图数据文件两种。pyecharts能够提供本地和远程两种类型的repository，加上Django整合时，项目静态文件也可以作为一种repository存在，因此共有三种。 将repository和文件类型进行交叉分析，可整理出以下的一张表格： 仓库 核心库文件 地图数据文件 核心库版本支持 远程/ 本地 pyecharts本地 可提供 可提供 无，不可控 本地 pyecharts远程 可提供 可提供 无，不可控 远程 官方CDN 不提供 提供 - 远程 公共CDN 可提供 不提供 支持 远程 项目静态目录 可自定义 可自定义 可自定义 本地 分析如下： 首先的是pyecharts本地作为存储仓库是不太合适，同为本地文件存储，Django项目静态库显然是一个更为合适的选择。 pyecharts远程库，路径为 https://chfw.github.io/jupyter-echarts/echarts， 该库的优势在于提供了一些列的自定义地图，但弱势是核心库文件没有版本管理，而且 github 仓库不建议作为静态文件托管服务。 官方CDN：其实指的是地图文件数据下载的源地址。 公共CDN：优势在于支持版本管理，缺点是不提供地图数据文件。公共CDN仅选择Echarts官方教程提及的三个CDN，其余的已经很久没有更新了。 项目静态目录：通常由 setttings.STATIC_URL指定。 这是开发者自己从零开始构建的，因此自由度最大。为了方便，可开发从其他远程仓库下载文件的功能。 一个通常的使用场景如下： 试验django-echarts，仅使用远程仓库，这样不必配置静态文件设置等。 如果可用，通过下载工具下载到本地，并进行一系列开发。 部署上线时，根据需要切换到CDN。 4 配置4.1 基本配置配置是项目初始化需要使用的。默认的配置如下： 123456DEFAULT_SETTINGS = &#123; 'echarts_version': '3.7.0', 'lib_js_host': 'bootcdn', 'map_js_host': 'echarts', 'local_host': None&#125; 在实际运行之前，会将用户自定义配置和默认配置进行合并，并向外提供统一的模块变量用于访问。 关于这一部分可以期待之后的《django-echarts系列：配置模块》一文。 由于核心库文件和地图数据文件需要分开托管，因此需要使用两个变量分别指定和设置。二者都有自己有效的可选值。 4.2 远程/本地切换 local_host的作用有两点： 提供公用变量，当 lib_js_host 和 map_js_host 同时指定本地仓库时，可以借助该变量 下载工具的目标目录。 5 运行分析5.1 分开托管和文件识别由于不同仓库提供的文件不同，通常分为可提供核心库文件和地图数据文件，因此需要分别两个查询表（在Python使用一个dict表示即可）。 这就带来了一个问题：用户输入的是 js_name，只有这个参数，而且由于自定义地图文件，理论上可以是任何一个有效的文件名字符串，如何识别为核心库文件还是地图数据文件，即从哪个字典查询，成了一个待解决的问题。 这个没有一个百分百正确的答案。目前采用一个简单办法：由于公共CDN提供的核心库文件是一定的，可提供一个核心库文件列表，判断js_name是否在其中即可。 5.2 输出URL当确定完某一个仓库后，之后的url构建就比较简单了，本质上来说是python string format的一些封装。仓库路径具体和一些因素有关，这些因素都需要在项目初始化就已经确定了，放在 settings 模块是最为合适了。目前支持以下字段： echarts_version：版本字符串，一些公共CDN需要指定版本号。 STATIC_URL：静态文件目录，通常用于项目本地仓库，该值等于settings.STATIC_URL. 在实现过程中，也有两点问题需要注意： 字段的大小写问题，为了和settings.STATIC_URL一致，也采用了大写变量 目录后缀/ ,依据Django规范 STATIC_URL是带有/的，而pyecharts的远程路径没有带有/，以及自己设置的第三方CDN中，这个问题需要作统一处理。目前是按照pyecharts没有带有/，不排除之后会依照Django规范，但是对外部使用是没有任何影响的。 基本代码 1234567891011121314151617181920class Host(object): HOST_LOOKUP = &#123;&#125; def __init__(self, name_or_host, context=None, host_lookup=None, **kwargs): context = context or &#123;&#125; host_lookup = host_lookup or self.HOST_LOOKUP host = host_lookup.get(name_or_host, name_or_host) try: self._host = host.format(**context).rstrip('/') except KeyError as e: self._host = None raise KeyError('The "&#123;0&#125;" value is not applied for the host.'.format(*e.args)) @property def host_url(self): return self._host def generate_js_link(self, js_name): return '&#123;0&#125;/&#123;1&#125;.js'.format(self._host, js_name) 5.3 渲染html这一过程是Django模板系统负责的，为了方面可以自定义一个模板标签echarts_js_dependencies解决这个问题。 以下是基本代码 123456789101112131415@register.simple_tag(takes_context=True)def echarts_js_dependencies(context, *args): links = [] for option_or_name in args: if isinstance(option_or_name, Base): for js_name in option_or_name.get_js_dependencies(): if js_name not in links: links.append(js_name) elif isinstance(option_or_name, six.text_type): if option_or_name not in links: links.append(option_or_name) links = map(DJANGO_ECHARTS_SETTING.host_store.generate_js_link, links) return template.Template('&lt;br/&gt;'.join(['&lt;script src="&#123;link&#125;"&gt;&lt;/script&gt;'.format(link=l) for l in links])).render( context) 有几个注意点： 标签是支持多个script渲染的。 为了方便，列表的每一项支持 文件名或者 pyecharts.base.Base对象。 在多个标签输出时，需要去掉那些重复的文件。 因为html结构简单，所以使用register.simple_tag 就可以了。 6 CLI与Django命令基于 django manage command 实现一个简单的 CLI，其核心功能是js文件下载。 下载工具提供将远程的js文件同步到本地静态文件目录中。该功能为manage命令，需符合其的一些用法规范。 12345usage: manage.py download_echarts_js [-h] [--version] [-v &#123;0,1,2,3&#125;] [--settings SETTINGS] [--pythonpath PYTHONPATH] [--traceback] [--no-color] [--js_host JS_HOST] js_name [js_name ...] 远程仓库的选择和限制条件可以使用伪代码表示如下： 12345678910111213host = &apos;&apos;if(命令提供了--js_host参数)&#123; host = js_host参数值&#125;else&#123; if(js_name是否和核心库文件)&#123; host = settings.DJANGO_ECHARTS[&apos;lib_js_host&apos;] &#125;else&#123; host = settings.DJANGO_ECHARTS[&apos;map_js_host&apos;] &#125;&#125;if(host不是本地仓库)&#123; 执行后续操作&#125; 本地仓库的选择：只有一个限制条件就是符合本地仓库的要求，即必须以 settings.STATIC_URL 开头。 在配置方面（源目录、目标目录）仅支持 DJANGO_ECHARTS ，暂时还不支持命令行参数传入。这是下一阶段的重点内容。 7 和pyecharts的异同7.1 扩展和取舍Django-Echarts是pyecharts在Django环境的适配，在此过程中难免有所扩展和舍弃。 在本地存储（离线模式）中，使用Django项目静态目录取代pyecharts本地js存储，并提供一个下载工具将远程js文件下载到Django静态目录，以便平稳过渡。 提供一些常用CDN。 分析ECharts组成，提供一些模板标签渲染Echarts的每个部件。 由于 pyecharts 尚未实现本地 js 库的完全独立，django_echarts 只是从形式上实现独立，在实际运行过程中还会引用js相关内容，期待pyecharts在这方面有所发展。 7.2 展望 本项目是基于 pyecharts 而发展的。pyecharts是一个非常棒的项目，解决在Python中使用echarts的问题，加强了Python在数据可视化方面的应用。 另一方面pyecharts刚刚面世两三个，目前着重于Echarts实例创建这一问题上，对于外围环境的问题涉及有所不足。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript声明文件]]></title>
    <url>%2F2017%2F08%2F27%2Ftypescript-declaration-file%2F</url>
    <content type="text"><![CDATA[TypeScript声明文件。 if you want to use relative path in the import, you will need: put the add.d.ts next to add.js define the file as an external module: 123// add.d.tsdeclare function add(n1: number, n2: number): number;export = add; i.e. loose the “declare module “add”” part. There are two ways to define declarations for a .js module: 1 using declare module &quot;foo&quot; and then you can have multiple module definitions in the same file: 123456789101112// mydefinitions.d.tsdeclare module &quot;mod1&quot; &#123; export var x = 0;&#125;declare module &quot;mod2&quot; &#123; export var y = 0;&#125;declare module &quot;mod3&quot; &#123; export var z = 0;&#125; and consuming them would have to be using absolute names: 123456// main.ts/// &lt;reference path=&quot;myDefintions.d.ts&quot; /&gt;import * as mod1 from &quot;mod1&quot;;import mod2 = require(&quot;mod2&quot;);import &#123;z&#125; from &quot;mod3&quot;; 2 alternatively you can define as a file, where the name of the file is the name of the module 1234// myModule.d.tsdeclare var m = 0;export = m; and consume it as a normal .ts module: 12import m = require(&quot;./myModule&quot;);m.toString();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【项目】高德地图位置选择器]]></title>
    <url>%2F2017%2F08%2F09%2Famap-position-picker%2F</url>
    <content type="text"><![CDATA[基于高德地图的位置选择jQuery插件。该项目结合了个人相关开发经验，分离功能独立的构件，严格遵守javascript开发规范。现已收录于开源中国中，主页为 https://www.oschina.net/p/amappositionpicker 。 从v0.9.0起，项目名称由 bootstrap.AMapPositionPicker 更改为 AMapPositionPicker。 主要特性有： AMD &amp; CMD 引入 data-* 属性配置 初始位置数据 浏览器定位 字段显示格式、验证 数据控件绑定 支持地理逆编码 POI搜索 工具：显示点标记 基本使用1 依次引入高德地图JS、jQuery、Bootstrap和bootstrap.AMapPositionPicker.min.js文件。 1234&lt;script type="text/javascript" src="http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="./dist/bootstrap.AMapPositionPicker.min.js"&gt;&lt;/script&gt; 2 在目标输入框初始化选项。 html代码 1&lt;input type="text" id="id_address_input" name="address"/&gt; JS代码 1$("#id_address_input").AMapPositionPicker(); 更多示例可查看 文档&amp;示例。 项目开发在开发过程中，参考了Eonasdan / bootstrap-datetimepicker等项目的模块结构。遵循标准通用的代码结构，以适应于多种环境。 构建项目使用gulp工具构建。 生成 release 文件 1gulp release]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>高德地图</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django项目全栈笔记]]></title>
    <url>%2F2017%2F07%2F31%2Fdjango-full-stack-note%2F</url>
    <content type="text"><![CDATA[概述BWS项目是自己一年来在开发的项目。本文就项目中一些技术选型、功能实现、项目流程做一些简单的总结。 python3虽然Python3发布已经10年之久，但是2和3之争直到今天依旧存在，对于如何学习，每个人都有自己的理解和学习策略。我个人看法： 果断学习面向未来的3； 3和2的差别对于学习过程没有太多的影响，学好了3自然也能够很快上手2了； 常见的第三方库大多数（80%以上）是支持Python3的； 不过在系统安装的时候总是23共存的，可以自由切换； 今年4月份重新开发的时候做了一个比较激进的做法：完全抛弃对Python2的支持。当时的考量，把这个项目作为Django持续学习的一个示范项目，毕竟 Django的下一个大版本2.0（预计2017年12月发布），也已经要求最低版本为3.5了。 其实在项目中使用几个Python2不支持的语法和没有的标准库，就可以达到以上目的，具体来说，在代码中使用了以下几个语法： 字典合并创建语法（PEP448） 强制关键字传参（PEP3102） 根据 PEP448，在Python3.5中可以使用更加简洁明了的代码实现合并多个字典。 123456# 3.5+combination = &#123;**first_dictionary, "x": 1, "y": 2&#125;# 3.5以下combination = first_dictionary.copy()combination.update(&#123;"x": 1, "y": 2&#125;) 另外Python3在文本和二进制方面作了比较大的改变，这对文件导入导出功能开发提供了便利，不用再纠结2的编码问题，可以集中解决业务层面的问题。 Django我也算是Django的忠实用户了，从1.4到1.11都有用到，不断看到Django的成长和壮大。1.4/1.8/1.11是LTS版本，项目使用的是1.10。这些年来Django比较大的变更有： 自定义用户类型：这个是1.5就有的功能了，之前只能使用内置的用户类，连使用邮箱作为用户名也不能直接支持； 数据库迁移：1.7借鉴 South 实现的，这个是开发的利器，修改用户模型时候可以使用命令一键将修改同步到数据库，而忽略具体的数据库类型； 自定义过滤查询：1.7，这个主要用于封装一些业务数据库查询。 多模板支持：1.8引入的，Django自己的模板引擎效率历来为人们所诟病，现在可以在Django中使用Jinja2这样的模板了。 表单控件支持模板渲染：Django表单其实是着重于后端验证，前端相对薄弱，导致定制起来没有那么顺手。最新的1.11引入的可以通过模板文件定制控件样式等等。 CBV强烈建议使用 Class-Based-View 组织视图处理函数。 Class-Based-View 是相对于Function-Based-View而言，主要支持封装，减少重复的代码编写工作，逻辑流程清晰，经过测试过的。在具体编写代码还是一定要查看源代码，才能理解其中的功能实现。 CBV的核心是Mixin模式。 Mixin是一种将多个类中的功能单元的进行组合的利用的方式，这听起来就像是有类的继承机制就可以实现，然而这与传统的类继承有所不同。通常mixin并不作为任何类的基类，也不关心与什么类一起使用，而是在运行时动态的同其他零散的类一起组合使用。 使用mixin机制有如下好处：可以在不修改任何源代码的情况下，对已有类进行扩展；可以保证组件的划分；可以根据需要，使用已有的功能进行组合，来实现“新”类；很好的避免了类继承的局限性，因为新的业务需要可能就需要创建新的子类。 现在也基本上不写视图函数了，项目上能见到的也就是 django.contrib.auth.login 等几个函数了，不过现在也要改成视图类形式了。 是否启用admin虽然admin是Django的主要优势所在，但是它的使用场景有限，主要由于整合许多功能，比如分页、过滤、搜索、增删改查和批量操作等等，相互之间具有非常高的耦合度。在没有提供公开的API下去实现一些定制往往是“牵一发而动全身”，最后基本上也改的是不成样子。 由于项目中没有使用内置的admin组件，增删改查的页面就需要多花一点时间自己去适配。 日志模型也要自己去设计，项目中我自己添加了ip这个字段，这个是原来所没有的。 后端数据API - DRF后端数据采用的是 Django Rest Framework 这个框架，覆盖了大多数需求，包括： 搜索/分页 访问权限 请求限制（频率、IP） 表单验证 前端 Amaze UI前端UI用的是 Amaze UI这个框架。不过从后来的发展形势来看，这是最为错误的决定了，主要原因在于无法和后端比较平稳地整合。 Django表单中有一个比较大的问题，如何需要定制控件样式，需要在Python代码中修改，而且需要应用的每一处都需要更改，灵活度不够。目前主要有两种解决方式： 使用Django1.11版本的模板功能，这个功能刚刚推出，文档也只有一页的内容，不太建议使用。 使用 django-crispy-forms 第三方库，这个库的思路也是使用模板html文件渲染控件，已经有一定的使用规模，但是支持 Bootstrap这样常见的UI框架，不支持 Amaze UI。 导入导出实现导入导出功能主要使用的是 tablib 和 django-import-export 这两个库，其中后者依赖前者。 导出编写 Resource， 几点值得注意的地方： 需要设置表头，不仅需要指定字段Meta.fields，同时也要显示指定 Meta.export_order 的值，通常和 Meta.fields一样即可。 Meta.fields 里的元素必须是模型的数据库字段，不能是自定义的 property，这一点和 ModelAdmin.list_display 不一样。 可以使用 dehydrate_FOO 函数重写导出内容 1234567891011class BillResource(resources.ModelResource): def get_export_headers(self): return ['流水号','月份', '类型','单价','用量', '金额'] def dehydrate_price(self, obj): return obj.get_price_display class Meta: model = models.Bill fields = ('id', 'month', 'resource_type','price', 'amout', 'total') export_order = fields 导入django-import-export也提供了几个Mixin，但问题这些和admin组件耦合很高，不利于一些自定义操作，所以直接使用tablib库比较好。根据官方文档，可以使用以下代码实现文件导入 1imported_data = Dataset().load(open('data.csv').read()) 但其实load还有几个比较重要的参数： format：文件格式，如果不写，使用自动识别，但有出错的机率，之前试验过一个xlsx文件在不同环境下识别为json文件的，因此建议这个参数也留给用户输入 headers：表示第一行是否是表头，这个参数在文档中没有表明，需要自行查看源代码获取相关信息。 所以最后就写成下面这个样子 12345678class BillUploadForm(form.Form): import_file = forms.FileField() format = forms.ChoiceField(choices=(('xlsx', 'xlsx'), ('xls', 'xls')))# 导入tablib.Dataset().load(form.cleaned_data['import_file'].read(), format=form.cleaned_data['format'], headers=False) 数据库查询优化select_related函数select_related是 django.db.models.QuerySet 类的一个方法，它解决了 ORM中常见的N+1查询效率问题，关于这一部分可以参考我之前写过的一篇文章《select_related函数性能基本测试》。 更新记录在更新记录时可以使用 update_fields 参数指定只需更新的字段列表。这个参数在只更新一两个字段的时候特别有用。 12product.name = 'Name changed again'product.save(update_fields=['name']) 如果不指定参数的值，将更新所有字段。 测试和部署分离配置文件Django使用 settings 模块配置相关参数，这使得其很好的区分开发/测试/生产。 1234567- BillWorkingSystem - BillWorkingSystem - __init__.py - settings.py - test_settings.py - urls.py - wsgi.py 一个简单的test_settings.py如下，可以配置一些仅用于测试的项目，如数据目录 FIXTURE_DIRS 。 12345678910111213141516from BillWorkingSystem.settings import *class DisableMigrations(object): def __contains__(self, item): return True def __getitem__(self, item): return "notmigrations"MIGRATION_MODULES = DisableMigrations()FIXTURE_DIRS = ( os.path.join(BASE_DIR, 'fixtures').replace('\\', '/'),)UPLOAD_TEST_DATA_DIR = os.path.join(BASE_DIR, 'fixtures', 'test_data').replace('\\', '/') MIGRATION_MODULES 设置表示是否运行数据迁移脚本。上述例子设置为空，表示测试无需运行这些迁移脚本。 单元测试单元测试主要测试那些返回为实际数据（如json/yaml）的视图。 测试采用标准的 django.test.TestCase，按照文档所描述的步骤，一步一步的编写。 1234567891011121314151617181920class BillCreateTestCase(TestCaseBase): url = '/api/bill/create/' def test_success(self): data = &#123; 'enterprise': 1, 'year': 2017, 'month': 1, 'amount': 4000, 'create_name': 'Test' &#125; rsp = self.client.post(self.url, data) self.assertEqual(201, rsp.status_code) # 其他assert语句 def test_with_error_enterprise(self): data = &#123; &#125; # 参数 rsp = self.client.post(self.url, data) self.assertEqual(400, rsp.status_code) # 其他assert语句 一个基本模式， 一个TestCase表示一个主要功能，如一个POST请求 每个 test_FOO 函数表示一种情况，包括正确和无效参数 依次对响应对象的状态码和内容、数据变更进行断言(Assert)测试 docker部署之前采用的是daocloud这个平台的工具。具体可参考《使用DaoCloud部署Django项目》这篇文章。由于对docker这方面没有一个完整的学习，加上daocloud.io更新到3版本，作了一些比较大的改变，后来就决定搬迁到阿里云服务器上，这样相对比较容易把握。 后记轮子什么是轮子 wheel，写多了代码就会发现一些代码具有共同之处，将其抽象并提取，慢慢地就形成了一个库，可以和别人分享。本质上来说，Django也是一个轮子。 持续开发由于是个人项目，因此一些版本升级方面就比较随意，基本上新版本出来就完全废弃旧有版本。 第三方库稳定才是真，不要为追求标新立异而盲目升级。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驾考点滴]]></title>
    <url>%2F2017%2F07%2F28%2Fdriver-exam%2F</url>
    <content type="text"><![CDATA[驾考记录 今天考完了科目四，一切变得那么轻松了，坐等驾照快递上门。 （2017年8月17日） 科二今天（28号），一起考四个全满贯。 四个只有我是补考的，总结一下 “技术(30%) + 心态(60%) + 运气(10%)”。 运气 今天是1道1号，路线相对比较简单，道上的车比较少。在考试的时候异常地顺利，项目之间没有作什么停顿，(一个项目完成后可以停车空档，等前面的人做完或者自己休息思考一下)。 技术 的确经过依次挂科的经历，技术上有所提升，掌握的就比较平稳了。 上车准备 调整坐姿和后视镜。考场的车真是不能比，调了很久才稍微完成； 离合器下面榻了一块，需要用泡沫垫子垫一下； 还有要说的是，轮到号的时候车可能还没回到起点（报告合格的地方离起点还有一段距离），所以在上车之前可以大概问下前一个人这车性能如何，自己心里有个底。 坡道停车和起步 停车时右前轮距边缘线30厘米以上，扣10分; 学车的时候教练说不要管右侧边线，一步留神，有可能是不合格，就不是扣10分这么简单了； 考场的车动力比较差，教练嘱咐可以加点油门，后来想想还是不加，让车乌龟慢慢爬上坡去。 直角转弯 在练习的一直掌握的比较好，主要是右侧对边线，上次考试前一天被拉了去练习十几分钟的对边线。 其次是打死方向盘的时机。 侧方停车 这个相对比较简单，进入的时候也是要对边线的，道理同直角转弯。 要注意的是车库由坡度和方向盘打死时会速度停顿下，所以要掌握离合器以便控制好车速。 曲线行驶 其实头是可以伸出窗外看看轮胎调整的，第一次考试的时候由于注意力不集中，忘了这一点，考试前几天，交管所通知说头不能伸出窗外； 基本上按照教练的，左侧铆钉和右侧喷水点沿着边线就可以了。 倒车入库 入库的时候，回正不够导致左侧空间比较大，后来还是有惊无险的完成入库了。 考试的标准通常是可以在一个范围，而教练要求是准确的一个点，按照教练的标准肯定又要训斥一顿了。] 返回起点 这时候就比较轻松了，稳稳当当开回起点就可以了。 小插曲1：经过公共车道的时候，发现前面的车在等最后的倒车入库，其中这时候靠左一点可以过去的，但为了保险起见就没有直接过去； 小插曲2：最后完全放开离合，汽车动力好像也不是很足，加点油门就可以了。 心态 心态很重要。 要放轻松，需要有“大不了当去考场走一遭”，其实驾校的场地和练习一般都会比考试的时候更加难一点。 考试的时候注意力要集中，一共就那么十几分钟。上次考试（6月20日）第一把坡道起步熄火了，可以认为是技术不熟练；第二次在曲线行驶的时候，旁边另一道的人前几秒曲线行驶挂掉了，注意力不集中，过不了几秒自己也中枪了，压到右侧黄线了。哎，可惜已经没有机会了。 练车是一个很苦逼的过程，特别是考试前几天，基本上是天天练习，顶着三十七八度的大热天，人也超级多，一个早上下来也练不了几圈。 练车能认识各种各样的人，可以互相聊聊天，缓解练车过程的无趣。 周末台风又要来了，总算这炎热的天气会变凉快一些了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驾考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select_related函数性能基本测试]]></title>
    <url>%2F2017%2F07%2F11%2Fdjango-select-related-performance%2F</url>
    <content type="text"><![CDATA[缴费项目主体功能完成的差不多了，写前端JS写的都快吐了，把所有的通用的代码封装在一个文件里差不多有1500行。接下去应该主要是Bug修正和性能优化了。性能优化方面，数据库访问效率是重要的环节，使用ORM遇到的一个很常见的是 “N+1”问题，自然Django也不例外。 N+1问题以一个简单的例子说明。假设你有一个包含若干辆汽车(Car)的集合（数据库记录），每个车辆有若干个轮胎(wheel)。也就是说，汽车和轮胎是一个一对多的关系。 如果你需要，迭代出所有的汽车信息，并且对于每辆汽车打印它的轮胎信息。则可以使用以下SQL实现： 1SELECT * FROM Car; 然后对于每辆车，使用以下的SQL语句： 1SELECT * FROM wheel WHERE CarId = ? 也就是说，在此过程中进行了N+1次数据库查询操作，其中N为汽车的数目。 但是，另一种更为效率的方式，在查出所有车辆信息后，直接查询所有的轮胎的记录，在内存中查找之间的联系。 1SELECT * FROM wheel; 该例子来自于 https://stackoverflow.com/questions/97197/what-is-n1-select-query-issue 。 在Django中可以使用 select_related和 prefetch_related 查询API解决这个问题。标准查询如下： 1234# 访问数据库e = Entry.objects.get(id=5)# 再次访问数据b = e.blog 如果使用 select_related 函数后： 12345# 访问数据e = Entry.objects.select_related('blog').get(id=5)# 下面语句不会访问数据库b = e.blog 表定义123456789101112131415161718192021222324class Organization(models.Model): name = models.CharField(max_length=100) remark = models.TextField(max_length=500, null=True, blank=True)class Enterprise(models.Model): name = models.CharField(verbose_name='名称', max_length=100) catalog = models.CharField(verbose_name='分类', max_length=10, null=True, blank=True) address = models.CharField(verbose_name='地址', max_length=100, null=True, blank=True) organization = models.ForeignKey(Organization, on_delete=models.CASCADE, verbose_name='组织', null=True, blank=True) remark = models.TextField(verbose_name='备注', max_length=500, null=True, blank=True) price = models.DecimalField(verbose_name='单价', max_digits=15, decimal_places=3, default=0) unit = models.CharField(verbose_name='单位', max_length=10, null=True, blank=True) charge_type = models.CharField(verbose_name='收费类型', max_length=10, choices=ChargeType.choices) objects = EnterpriseManager()class Bill(models.Model): enterprise = models.ForeignKey(Enterprise, verbose_name='企业', on_delete=models.CASCADE) year = models.IntegerField(verbose_name='年份') month = models.IntegerField(verbose_name='月份') # month=0表示年度抄表 price = models.DecimalField(verbose_name='单价', max_digits=15, decimal_places=3) unit = models.CharField(verbose_name='单位', max_length=10) amount = models.DecimalField(verbose_name='用量', max_digits=15, decimal_places=3, default=0) total = models.DecimalField(verbose_name='应收金额', max_digits=15, decimal_places=2) 数据库有 组织(Organization)、企业(Enterprise)和账单(Bill)三张表，它们的关系如下： 每个企业可以隶属于一个组织，也可以不隶属于任何一个组织 每个企业可以有按年缴费和按月缴费两种缴费类型，使用charge_type区分 每个企业在同一月份或者同一年度（由缴费类型决定）只能有一条唯一的记录，该特性由业务层限制 测试代码测试场景：获取所有账单数据，并且需要包括他们的企业基本信息，如名称、地址等。 测试是否使用 select_related 函数对查询耗时的影响。 1234567891011121314151617def test_normal(): t1 = time.time() el = [] bill_qs = models.Bill.objects.all() for bill in bill_qs: el.append(bill.enterprise) t2 = time.time() print('Normal &#123;0&#125;'.format(t2 - t1))def test_select_related(): t1 = time.time() el = [] bill_qs = models.Bill.objects.all().select_related('enterprise') for bill in bill_qs: el.append(bill.enterprise) t2 = time.time() print('Select &#123;0&#125;'.format(t2 - t2)) 规模定义假设 N 表示按年缴费和按月缴费的企业数目，即总企业数为 2N，则一年Bill账单总数为 12 x N + N = 13N，即测试代码中 models.Bill.objects.all().count() 返回的值。 结果以下是在Windows 10 64位 / Python3.5 / Django1.10.3 / 内存数据库 所测的数据： | N= | 1 | 10 | 100 | 1000 | 10000 || —— | —— | —— | —— | —— || Bill Total | 13 | 130 | 1300 | 13000 | 130000 || Normal | 0.017008 | 0.157611 | 1.892831 | 16.585734 | 224.317318 || Select | 0.004504 | 0.027019 | 0.310722 | 2.259590 | 26.342256 || 相比 | 3.7744 | 5.8333 | 6.0917 | 7.3401 | 8.5154 | 使用折线图描绘更为直观： 从以上结果可以看成耗时差距随着规模增加越来越大，N大于1000时，两者耗时已不在一个数量级上了。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在树莓派安装lxml]]></title>
    <url>%2F2017%2F05%2F14%2Finstall-lxml-on-respberry-pi%2F</url>
    <content type="text"><![CDATA[安装和配置是最令人费劲的： 经常在解决一个问题过程又出现另外一个不得不先解决问题，有点像栈(stack)，忘记了最先要解决的问题 网上的解决方法只是一个参考，时间和环境不一定一样，需要自己去阐释 Google搜索/Bing搜索/stackoverflow是搜索的利器，错误信息一复制粘贴基本上可以找到一些结果，当然和搜索技巧也是有很大关系的 本文记录在树莓派安装lxml的过出现的一些问题和解决方案，本来lxml安装过程比较简单，安装依赖和pip安装两条命令即可。但是由于各种各样的状况和环境导致这过程花费的时间有点长。 12$ sudo apt-get install libxml2-dev libxslt-dev python-dev$ sudo pip3 install lxml lxml的标准安装过程 安装python3.6树莓派3默认安装的是python3.4，版本有点旧，决定自己安装python3.6，从官网下载源代码并自己编译，步骤如下： 1234567wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgztar xvf Python-3.6.1.tgzcd Python-3.6.1./configure --enable-optimizationsmakesudo make altinstallpython3.6 安装完后python3.6路径为 /usr/local/bin/python3.6，另外使用软连接将python3指向3.6， 12sudo ln -s -f /usr/local/bin/python3.6 /usr/local/bin/python3sudo ln -s -f /usr/local/bin/python3.6 /usr/bin/python3 问题: py3clean: permission denied由于安装python3.6没有完全配置好，导致使用apt-get安装任何包都会出现这个错误信息。从字面上是权限的问题，使用chmod命令或者root用户也无效。 后来定位并查看该执行文件的内容,发现是一个python脚本。问题出现在第一行的linux shabang符号，需要 将 #! /usr/bin/python3 改成 #! /usr/local/bin/python3，同时修改的还有同义目录下的py3compile脚本。 123456pi@raspberrypi:~ $ which py3clean/usr/bin/py3cleanpi@raspberrypi:~ $ sudo nano /usr/bin/py3clean GNU nano 2.2.6 File: /usr/bin/py3clean#! /usr/bin/python3 问题：找不到libxslt-devlibxml2-dev包很快就安装成功了，但是libxslt-dev包却却提示找不到。 12345pi@raspberrypi:~ $ sudo apt-get install libxslt-develReading package lists... DoneBuilding dependency treeReading state information... DoneE: Unable to locate package libxslt-devel 在Debian源找到了 libxslt-devel2 包页面，地址是 https://packages.debian.org/jessie/libxml2-dev ，按照页面提示添加apt源并安装。 1W: GPG error: http://ftp.cn.debian.org jessie Release: The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 8B48AD6246925553 NO_PUBKEY 7638D0442B90D010 NO_PUBKEY CBF8D6FD518E17E1 该消息显示这个源未经过验证，所以需要添加plublic key到系统中，如果显示 imported 1 字样就是导入成功了. 123456pi@raspberrypi:~ $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 8B48AD6246925553Executing: gpg --ignore-time-conflict --no-options --no-default-keyring --homedir /tmp/tmp.5TjGyQBYus --no-auto-check-trustdb --trust-model always --keyring /etc/apt/trusted.gpg --primary-keyring /etc/apt/trusted.gpg --keyserver keyserver.ubuntu.com --recv-keys 8B48AD6246925553gpg: requesting key 46925553 from hkp server keyserver.ubuntu.comgpg: key 46925553: public key &quot;Debian Archive Automatic Signing Key (7.0/wheezy) &lt;ftpmaster@debian.org&gt;&quot; importedgpg: Total number processed: 1gpg: imported: 1 (RSA: 1) 使用apt安装libxslt-dev。 123456pi@raspberrypi:~ $ sudo apt install libxslt-devReading package lists... DoneBuilding dependency treeReading state information... DoneNote, selecting &apos;libxslt1-dev&apos; instead of &apos;libxslt-dev&apos;... 另外要说的是apt源如果连接不上，树莓派直接死机，使用局域网扫描工具没找到树莓派设备，这个问题也困扰了好几天，没找到直接的解决方法（比如跳过或者设置超时），最后直接注释。 成功安装最后使用pip3安装，大功告成！ 12345678910pi@raspberrypi:~ $ sudo pip3 install lxmlCollecting lxml Using cached lxml-3.7.3.tar.gzBuilding wheels for collected packages: lxml Running setup.py bdist_wheel for lxml ... done Stored in directory: /root/.cache/pip/wheels/df/32/5f/0acd510ac7d66ebe5f35155508972fa732ec45acd5f79146d2Successfully built lxmlInstalling collected packages: lxmlSuccessfully installed lxml-3.7.3]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>lxml</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德地图热力图和设备监测]]></title>
    <url>%2F2017%2F04%2F29%2Famap-heatmap%2F</url>
    <content type="text"><![CDATA[A 热力图热力图以高亮形式显示数据密集程度。根据密集程度的不同，图上会呈现不同的颜色，以直观的形式展现数据密度。 在设备检测领域，采用热力图可以直观地显示哪些区域的设备具有很高的报警率，为监控决策和提前介入提供了数据依据。 AMap.Heatmap 是高德地图热力图插件，基于heatmapjs。高德地图API引用了heatmap.js最新版本v2.0，v2.0基于新的渲染模型，具有更高的渲染效率和更强的性能。支持chrome、firefox、safari、ie9及以上浏览器。 B 后端数据API根据热力图的文档，后端API需要返回的数据格式如下： 12345678910111213141516[ &#123; "device_serial": "F023D02900010002", "lng": 119.368489, "lat": 25.729161, "address": "XXX", "count": 830 &#125;, &#123; "device_serial": "F023D02900010003", "lng": 119.53378, "lat": 26.206372, "address": "XXX", "count": 220 &#125;] 总体为一个列表，每个元素表示一个设备，包括了设备序列号、设备经纬度、地址和报警数目。其中 lng 、 lat 和 count 是必要的数据，其他两个是可选的。 C 页面布局设计页面布局包括两大部分： 地图控件(div#id_map_container)，放置地图的控件，必须设置其高度。 时间选择器， 使用 position: absolute;z-index: 2;等样式，将时间段选择控件(div#id_time_radio_panel)以绝对定位方式放置在地图控件的右上角。 最外层使用Bootstrap Panel作为容器，并实现了折叠(collapse)效果。 时间选择器只提供了 “最近一年”和“全部”两个时段，时间段太短数据量偏少，不具有很好的代表性。 12345678910111213141516171819202122232425&lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;strong&gt;报警区域分布图&lt;/strong&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div id="id_map_container" style="height: 655px;"&gt; &lt;div id="id_time_radio_panel" class="panel panel-default" style="position: absolute;width:23%;z-index: 2;top:5px;right: 5px;"&gt; &lt;div class="panel-heading"&gt; &lt;a data-toggle="collapse" href="#id_time_radio"&gt;时间段设置&lt;/a&gt; &lt;/div&gt; &lt;div id="id_time_radio" class="collapse in"&gt; &lt;div class="panel-body"&gt; &lt;input type="radio" name="timeDelta" value="365d" checked/&gt;最近一年&amp;nbsp; &lt;input type="radio" name="timeDelta" value=""/&gt;全部时间 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; D js实现主要步骤如下： 首先引入高德地图js库文件，使用注册好的API KEY。 通过 isSupportCanvas 判断是否支持canvas，否则提示相关信息。 创建地图对象，并初始化工具插件。 编写时间选择器切换响应函数，在函数中请求远程数据，并渲染热力图层。 setDataSet 除了数据链表外，还需要设置热力图数值最大最小值。 渲染完成后将地图移动到数值最大的点上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function loadHeatmapData() &#123; var heatmap; $.get('/api/alarm/heatmap/?timeDelta=' + $("input[name=timeDelta]:checked").val(), function (data) &#123; gMapObj.plugin(["AMap.Heatmap"], function () &#123; //初始化heatmap对象 heatmap = new AMap.Heatmap(gMapObj, &#123; radius: 20, opacity: [0, 0.8] &#125;); var maxVal = 0, minVal = 10000; var cIndex = -1; for (var i = 0; i &lt; data.length; i++) &#123; if (data[i].count &gt; maxVal) &#123; maxVal = data[i].count; cIndex = i; &#125; if (data[i].count &lt; minVal) &#123; minVal = data[i].count; &#125; &#125; heatmap.setDataSet(&#123; data: data, max: maxVal, min: minVal &#125;); if (cIndex &gt; -1) &#123; gMapObj.setCenter(new AMap.LngLat(data[cIndex].lng, data[cIndex].lat)); &#125; &#125;); &#125;);&#125;function isSupportCanvas() &#123; var elem = document.createElement('canvas'); return !!(elem.getContext &amp;&amp; elem.getContext('2d'));&#125;var gMapObj = new AMap.Map("id_map_container", &#123; zoom: 15&#125;);AMap.plugin(['AMap.ToolBar', 'AMap.Scale'], function () &#123; gMapObj.addControl(new AMap.ToolBar()); gMapObj.addControl(new AMap.Scale()); gMapObj.addControl(new AMap.OverView());&#125;);if (!isSupportCanvas()) &#123; alert("'热力图仅对支持canvas的浏览器适用,您所使用的浏览器不能使用热力图功能,请换个浏览器试试");&#125; else &#123; loadHeatmapData(); $(":radio").click(function () &#123; loadHeatmapData(); &#125;);&#125; E 示例这是系统经过一个月运行后生成的热力图，虽然数据量还是偏少，但设备之间还是有很好的区分度，比如国惠大酒店旁的设备报警次数就比其他多了几个等级。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
        <tag>Javascript</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python项目持续集成与包发布]]></title>
    <url>%2F2017%2F04%2F25%2Fpython-project-ci-publish%2F</url>
    <content type="text"><![CDATA[本文依据《Python Packaging User Guide (Python打包用户手册)》，以 ConfStruct 为例子描述了Python项目的持续集成和包发布等开发流程，并了解 Travis CI、wheel和twine等工具的使用。 ConfStruct是一个使用类似ORM声明式描述特定场景下的协议数据结构，并提供Python对象和二进制数据之间的转化的Python库。该库解决了使用若干个“类型-长度-值”无序二进制片段传输字典的问题。 主要步骤 准备项目代码 运行本地单元测试 Travis持续集成 编写setup.py文件 生成wheel安装包 发布到PyPI 添加徽章 1 准备项目代码首先准备好项目代码和文本，包括： 源代码 完全通过的测试用例代码 requirements.txt依赖文件 .gitignore文件 [可选] README文件 [可选] 开源协议文件 2 运行本地单元测试依据开发规范，测试代码放置在tests包下，每个测试文件以test_开头。Python的测试框架有： unittest pytest nose tox 本博客使用的是最简单自带的unittest。执行以下命令以运行测试用例。 1python -m unittest discover 结果如下，完全测试通过。 123456E:\projects\ConfStruct&gt;python -m unittest discover.......----------------------------------------------------------------------Ran 7 tests in 0.002sOK 3 Travis持续集成Travis是一个在线持续集成的平台，支持github登录。 第一步，在项目根目录下创建 .travis.yaml文件，写入相关配置。 123456789language: pythonpython: - "2.7" - "3.4" - "3.5" - "3.6"install: - pip install -r requirements_dev.txtscript: python -m unittest 该.travis.yaml文件表明ConfStruct项目需在python2.7和python3.4+环境下使用unittest进行单元测试，测试环境使用不同的依赖文件requirements_dev.txt。 第二步，在github创建一个空项目。并使用github登录Travis,打开这个项目的自动构建开关，每当有新的push或者PR时就会自动触发，并给出是否构建成功的消息。 第三步，使用git将本地代码上传到github，过一两分钟后可在Travis查看相关构建信息，下面是构建成功的结果： 4 编写setup.py文件使用 setuptools来分发写好的模块。在项目目录下新建一个setup.py，主要内容类似如下： 12345678910111213141516171819202122232425262728293031from __future__ import unicode_literalsfrom setuptools import setuplib_classifiers = [ &quot;Development Status :: 4 - Beta&quot;, &quot;Programming Language :: Python :: 2&quot;, &quot;Programming Language :: Python :: 2.7&quot;, &quot;Programming Language :: Python :: 3&quot;, &quot;Programming Language :: Python :: 3.4&quot;, &quot;Programming Language :: Python :: 3.5&quot;, &quot;Programming Language :: Python :: 3.6&quot;, &quot;Intended Audience :: Developers&quot;, &quot;License :: OSI Approved :: MIT License&quot;, &quot;Topic :: Software Development :: Libraries&quot;, &quot;Topic :: Utilities&quot;,]setup(name=&quot;ConfStruct&quot;, version=&apos;0.5.0&apos;, author=&quot;kinegratii&quot;, author_email=&quot;kinegratii@gmail.com&quot;, url=&quot;https://github.com/kinegratii/ConfStruct&quot;, keywords=&quot;struct binary pack unpack&quot;, py_modules=[&quot;conf_struct&quot;], install_requires=[&apos;six&apos;], description=&quot;A parser and builder between python objects and binary data for configure parameters.&quot;, license=&quot;MIT&quot;, classifiers=lib_classifiers ) setuptools.setup 函数，它描述了项目的一些基本信息，主要参数如下表 名称 描述 name 名称，PyPI的唯一标识，不能与已有的冲突。 version 版本字符串，可以使用常量或者从库的 __VERSION__ 导入。 author 作者 author_email 邮箱 url 项目主页 py_modules 源代码模块 install_requires 安装依赖，格式与requirements.txt相同 license 开源协议类型，如 MIT lib_classifiers 分类标签，设置Python版本支持、操作系统支持、面向开发者或使用者、软件分类等信息。可用的选项在这里 可以找到 5 生成wheel安装包wheel 实际上是一个zip压缩包，是Python最新标准分发格式，用于替代eggs。和源代码编译相比，安装wheel无需经过 构建 这个流程，对于终端使用用户来说速度有了实质上的提升。 在使用之前需要安装相关包，运行命令 pip install wheel 即可。 wheel包按照是否纯Python包和23兼容性可分为三种，每种包所需运行的命令和生成的文件名称也有所不同。 Universal Wheels：纯Python，无C扩展；直接(natively)支持Python2和Python3，通常会使用 six 、futures等兼容库或者 __future__ 模块。 Pure Python Wheels：纯Python，无C扩展；无法直接支持Python2和Python3，需要通过 2to3 工具转化 Platform Wheels：针对特定的平台模块，通常是因为需要包含已编译的扩展。 除了第一种Universal Wheels使用以下命令： 1python setup.py bdist_wheel --universal 而 Pure Python Wheels 和 Platform Wheels无需添加 --universal 选项，该命令会检测是否是纯Python包。 1python setup.py bdist_wheel 在这里要发布的是 Universal Wheels，需要添加 --universal 选项。 运行后在dist目录下多了个 ConfStruct-0.5.0-py2.py3-none-any.whl 安装包，使用pip install 命令即可安装成功。根据 PEP425 该安装包文件名遵守这样的规定： 1&#123;distribution&#125;-&#123;version&#125;(-&#123;build tag&#125;)?-&#123;python tag&#125;-&#123;abi tag&#125;-&#123;platform tag&#125;.whl 6 发布到PyPIPyPI目前有两个可用的网址: 旧版 PyPI https://pypi.python.org/pypi 新版 Warehouse https://pypi.org/。Warehouse目前还处于开发状态(pre-production developement)，可以显示项目页面，但是页面内容简单，很多链接还是处于不可用状态。 twine 是一个专门用于发布项目到PyPI的工具，可以使用 pip install twine 来安装，它的主要优点： 安全的HTTPS传输 上传过程中不要求执行setup.py脚本 上传已经存在的文件，支持在发布前进行分发测试 支持任意包格式，包括wheel 最新版本的twine无需注册这一步骤，可直接上传，执行命令 twine register 将显示 HTTPError: 410 Client Error: This API is no longer supported, instead simply upload the file. for url: https://upload.pypi.org/legacy/的错 上传命令如下，在此过程中可能需要输入PyPI的用户名和密码，当然也可以使用 .pypirc 文件来避免多次输入。。 123456twine upload dist/*Uploading distributions to https://upload.pypi.org/legacy/Enter your username: kinegratiiEnter your password:Uploading ConfStruct-0.5.0-py2.py3-none-any.whl[================================] 4259/4259 - 00:00:08 当上传新版本时，最好指定新版本的安装包文件，如 twine upload dist/ConfStruct-0.6.0-py2.py3-none-any.whl，否则会出现文件已存在的错误。 7 添加徽章在 https://badge.fury.io 中输入项目名称并查找，把markdown格式复制到README.md文件。 点击Travis控制台build pass 图片并复制图片链接到README.md。如 12![travis](https://travis-ci.org/kinegratii/ConfStruct.svg?branch=master)[![PyPI version](https://badge.fury.io/py/ConfStruct.svg)](https://badge.fury.io/py/ConfStruct) 效果图]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>构建</tag>
        <tag>测试</tag>
        <tag>PyPI</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Construct：二进制数据解析器和构建器]]></title>
    <url>%2F2017%2F04%2F07%2Fconstruct-python-binary-parse-build%2F</url>
    <content type="text"><![CDATA[Construct是一个强大的二进制数据解析和构建Python库，适用于建立大型复杂应用程序的通信协议，类似于二进制数据的ORM库。 1 标准库structstruct是用于二进制数据的解析和构建，处理Python对象和二进制数据之间的转化。它的API非常简单： stricut.pack(fmt, v1, v2, *) 打包，Python对象到二进制数据 struct.unpack(fmt, buffer) 解包，二进制数据到Python对象 struct.calcsize(fmt) 计算格式字符串数据大小 2 Construct库在开发大型应用程序中，比如实现NMS协议，直接使用 struct 模块需要写大量的代码。和数据库访问库相类比， struct 相当于 mysql-python 底层连接的角色。 - 二进制数据 数据库访问 ORM ? Django ORM / sqlalchemy Connection struct mysql-python / pysycopg2 在 Pypi 使用 “struct + binary” 搜索相关Python库，比较后，Construct是比较合适： github star数目为287 开发活跃，最新发布版本是2.8.11，时间2017-04-05。 支持Python3.6。 文档完备。 按照文档要求下载、安装、测试，基本上符合大部分需求。 声明式定义 使用 Struct 类定义数据结构。 12345678910&gt;&gt;&gt; format = Struct(... &quot;signature&quot; / Const(b&quot;BMP&quot;),... &quot;width&quot; / Int8ub,... &quot;height&quot; / Int8ub,... &quot;pixels&quot; / Array(this.width * this.height, Byte),... )&gt;&gt;&gt; format.build(dict(width=3,height=2,pixels=[7,8,9,11,12,13]))b&apos;BMP\x03\x02\x07\x08\t\x0b\x0c\r&apos;&gt;&gt;&gt; format.parse(b&apos;BMP\x03\x02\x07\x08\t\x0b\x0c\r&apos;)Container(signature=b&apos;BMP&apos;)(width=3)(height=2)(pixels=[7, 8, 9, 11, 12, 13]) 组合和继承 Construct 支持原子结构和自定义结构的组合。使用 Adapter 自定义，下面为4字节存储IPv4数据的解决方案。 1234567&gt;&gt;&gt; class IpAddressAdapter(Adapter):... def _encode(self, obj, context):... return list(map(int, obj.split(&quot;.&quot;)))... def _decode(self, obj, context):... return &quot;&#123;0&#125;.&#123;1&#125;.&#123;2&#125;.&#123;3&#125;&quot;.format(*obj)...&gt;&gt;&gt; IpAddress = IpAddressAdapter(Byte[4]) 使用方法 1234&gt;&gt;&gt; IpAddress.parse(b&quot;\x01\x02\x03\x04&quot;)&apos;1.2.3.4&apos;&gt;&gt;&gt; IpAddress.build(&quot;192.168.2.3&quot;)b&apos;\xc0\xa8\x02\x03&apos;]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ORM</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NMS协议包识别引擎]]></title>
    <url>%2F2017%2F04%2F02%2Fthe-design-of-packet-identify-engine%2F</url>
    <content type="text"><![CDATA[基于工厂模式的包识别引擎设计，和一般工厂模式不同是： 匹配规则查询表中是一个树形结构，既有精确规则，又有模糊规则，匹配的过程需要多次查询的操作，从精确到模糊直至无法匹配。 匹配规则查询表能够支持添加新规则操作 1 问题描述A NMS基础协议 NMS是服务器与硬件设备(具体为RTU或者网关)工作的通信协议，协议格式描述如下： 网关地址 节点地址 源类型 包序号 包类型 负载长度 负载 gateway_mac rtu_mac source_type packet_id packet_type payload_length payload 8 8 1 4 1 1 - 前23字节为包头部，各个字段描述如下： 网关地址：64位长整型，显示为十六进制形式。 节点地址：64位长整型，显示为十六进制形式。 源类型：表示哪一种设备，主要有 Gateway/GPRS-RTU/Mesh-RTU 三种类型的设备。 包序号：32位整数，0 - 4294967295 。 包类型：该包的类型。 负载长度：整数0-255，表示后面的负载长度，实际中负载长度小于255。 源类型取值定义如下： 设备分类 设备类型取值 描述 网关 0x03 自组网网关 0x06 以太网网关 Mesh-RTU 0x01 自组网RTU，通过自组网关与服务器相连 GPRS-RTU 0x02 GPRS-RTU，与服务器直连 web服务器 0x04 由服务器或者上层应用发起 B 应用协议 NMS可承载多种设备应用协议，比如Modbus协议、DTU低功耗设备协议、远程抄表协议等，每个应用协议使用1字节的整数标识，称之为应用类型(app_id)。由于一些类型的包与上层应用无关，所以在设计中，NMS协议头部没有专门的应用类型字段。 它的规则如下： 应用类型存储在payload中，并且位置不一定相同，但由包类型决定，即由packet_type和payload两个参数可计算出具体应用类型数值 在应用协议扩展过程中，属于统一应用协议的设备（网关或节点）既可以使用现有的设备类型取值，也可申请新的设备类型取值。这取决于具体应用场景，比如Modbus协议中，网关设备只起数据转化的功能，可以部署通用网关，设备类型取值为0x03，远程抄表协议中，网关也能响应服务器的动作，申请新的设备类型取值。 在上述描述中，设备类型(source_type)和设备分类(source_catalog)的概念是不一样的。加入上层应用协议后，它们的关系， 设备分类 设备分类取值 设备类型取值 应用协议 描述 网关 gateway 0x03 通用 自组网网关 0x06 通用 以太网网关 0x07 抄表应用(0x01) 网关 … … … Mesh-RTU mesh_rtu 0x01 通用 自组网RTU，通过自组网关与服务器相连 GPRS-RTU gprs_rtu 0x02 通用 GPRS-RTU，与服务器直连 0x08 报警(0x0A) … … … web服务器 - 0x04 - 由服务器或者上层应用发起 以具体到NMS协议， 包类型与应用类型的对应关系（部分）如下： | 包类型 | 取值 | 是否应用协议相关 | 是否设备相关 | 描述 || —— | —— | —— | —— || 数据包 | 0x01 | 是 | 无 | 设备自动上报的数据 || 心跳包 | 0x04 | 否 | 设备分类相关 | 维持在线状态 || 时间同步包 | 0x06 | 否 | 否 | 由服务器发送 | 问题： 设计基于树结构的包结构体系。 实现给定一段符合格式NMS的包二进制字节数组，识别所对应的包种类，返回实例化的包对象。 支持扩展已有的应用协议。 2 基本识别过程基于(packet_type, source_type, app_id)的识别引擎主框架代码如下。 packet.py 12345678910111213141516class PacketBase(object): packet_type = None source_catalog = None source_type = None app_related = False app_id = None def __init__(self, gateway_mac, rtu_mac, source_type, packet_id, packet_type, payload_length, payload, **kwargs): self.gateway_mac = gateway_mac self.rtu_mac = rtu_mac self.source_type = source_type or self.source_type self.packet_id = packet_id self.packet_type = packet_type or self.packet_type self.payload_length = payload_length self.payload = payload engine.py 12345678910111213141516171819202122232425262728import structclass AppProtocolBase(object): app_id = Noneclass Engine(object): def __init__(self): self._packet_lookup = &#123;&#125; # 包类对象查询表，为(packet_type, source_type, app_id)到包类对象的映射 self._protocol_lookup = &#123;&#125; def register_protocol(self, protocol_class): pass def add_lookup_item(self, packet_type, source_catalog, source_type, app_id, packet_class): # 添加匹配规则 pass def identify(self, packet_binary): header, payload = packet_binary[:23], packet_binary[23:] gateway_mac, rtu_mac, source_type, packet_id, packet_type, payload_length = struct.unpack('&gt;QQBIBB', header) cls = self._identify_class(packet_type, source_type, payload) if cls: return cls(gateway_mac, rtu_mac, source_type, packet_id, packet_type, payload_length, payload) def identify_class(self, packet_type, source_type, payload): # 输入为包索引(packet_type, source_type, app_id) # 在查询过程中，可能需要经过精确到模糊的查找过程，并不是简单的 dict.get 调用 pass 3 查询表(lookup)3.1 构建基本查询表包索引即为查询表中的键 packet.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 构建class DataPacket(PacketBase): packet_type = 0x01 app_related = Trueclass GatewayHeartbeatPacket(PacketBase): packet_type = 0x04 source_catalog = 'gateway'class MeshRTUHeartbeatPacket(PacketBase): packet_type = 0x04 source_catalog = 'mesh_rtu'class GPRSHeartbeatPacket(PacketBase): packet_type = 0x04 source_catalog = 'gprs_rtu'class TimeSyncPacket(PacketBase): packet_type = 0x06 source_catalog = 0x04 def build_lookup(*args): packet_lookup = &#123;&#125; app_related_packet_type_set = &#123;&#125; for packet_class in args: packet_lookup[(packet_class.packet_type, packet_class.source_type or packet_class.source_type, None)] = packet_class if packet_class.app_related: app_related_packet_type_set.add(packet_class.packet_type) return packet_lookup, app_related_packet_type_set# 两个查询表计算过程# PACKET_LOOKUP, APP_RELATED_PACKET_TYPE_SET = build_lookup(# DataPacket,# GatewayHeartbeatPacket,# GPRSHeartbeatPacket,# MeshRTUHeartbeatPacket,# TimeSyncPacket# )# 为了下面示例方面，直接给出最后结果PACKET_LOOKUP = &#123; (0x01, None, None): DataPacket, (0x04, 'gateway', None): GatewayHeartbeatPacket, (0x04, 'gprs_rtu', None): GPRSHeartbeatPacket, (0x04, 'mesh_rtu', None): MeshRTUHeartbeatPacket, (0x06, 0x04, None): TimeSyncPacket&#125;# 所有与应用相关的包类型集合APP_RELATED_PACKET_TYPE_SET = &#123; 0x01 &#125;SOURCE_TYPE_CATALOG_LOOKUP = &#123; 0x01: 'mesh_rtu', 0x02: 'gprs_rtu', 0x03: 'gateway', 0x04: 'gateway'&#125;SOURCE_CATALOG_SET = &#123;'gateway', 'mesh_rtu', 'gprs_rtu'&#125; 3.2 基于应用协议扩展识别规则查询表注册应用协议实际为上述查询表增加了更加精确的匹配规则，当本应用协议的包类对象无法使用才会使用基本的包类对象。在添加匹配规则时： 应用类型：应用类型不能与已有的冲突 包类型：只能注册那些与应用相关的类型的包(类型存储在 APP_RELATED_PACKET_TYPE_SET)，因为与应用无关的包没有存储应用类型字段，识别时无法分发。 源类型和源分类 使用已有的设备分类，对应于若干种设备 使用已有的设备类型 使用新的设备类型，不能和已有的相冲突，同时必须指定设备分类 实现过程如下： 123456789101112131415161718192021222324252627import copyfrom .packet import PACKET_LOOKUP, APP_RELATED_PACKET_TYPE_SET, SOURCE_CATALOG_SET, SOURCE_TYPE_CATALOG_LOOKUPclass Engine(object): def __init__(self): self._packet_lookup = copy.copy(PACKET_LOOKUP) # 包类对象查询表，为(packet_type, source_type, app_id)到包类对象的映射 self._source_type_catalog_lookup = copy.copy(SOURCE_TYPE_CATALOG_LOOKUP) self._protocol_lookup = &#123;&#125; def register_protocol(self, protocol_class): if protocol_class.app_id in self._protocol_lookup: raise ValueError('The app_id value &#123;&#125; in the &#123;&#125; has conflicted!'.format(protocol_class.app_id, protocol_class.__name__)) self._protocol_lookup[protocol_class.app_id] = protocol_class for packet_class in protocol_class.packet_lookup: self.add_lookup_item(packet_class.packet_type, protocol_class.source_catalog, protocol_class.source_type, protocol_class.app_id, protocol_class) def add_lookup_item(self, packet_type, source_catalog, source_type, app_id, packet_class): if packet_type not in APP_RELATED_PACKET_TYPE_SET: raise ValueError('Protocol Register with packet_type &#123;&#125; is not supported!'.format(packet_type)) if source_type in self._source_type_catalog_lookup: self._packet_lookup[(packet_type, source_type, protocol_class.app_id)] = packet_class else: if source_catalog in SOURCE_CATALOG_SET: self._packet_lookup[(packet_type, source_catalog, protocol_class.app_id)] = packet_class else: raise ValueError('Invalid source_catalog') 3.3 使用方法和测试案例123456789101112131415161718class HydrantDataPacket(DataPacket): passclass HydrantProtocol(AppProtocolBase): app_id = 0x0A packet_lookup = &#123; HydrantDataPacket &#125;engine = Engine()engine.register_protocol(HydrantProtocol)payload = struct.pack('&gt;BBBBB', 0x0A, 3, 4, 5, 6)test_binary = struct.pack('&gt;QQBIBB', 70971071088567232, 70971071088567240, 13, 0x01, 5) + payloadpacket = engine.indentfity(test_binary)assert isinstance(packet, HydrantProtocol) == True 4 识别匹配 查询 (packet_tpye, source_type, None) 是：计算app_id，查询(packet_tpye, source_catalog, app_id) 是：使用(packet_tpye, source_catalog, app_id) 否：使用(packet_tpye, source_type, None) 否：当前packet_tpye是否有app_id 是：计算app_id，查询 (packet_tpye, source_catalog, app_id) 是：使用 (packet_tpye, source_catalog, app_id) 否：无法识别 否：查询 (packet_tpye, source_catalog, None) 是：使用(packet_tpye, source_catalog, None) 否：无法识别 12345678910111213141516171819class Engine(object): def identify_class(self, packet_type, source_type, payload) cls = self._packet_lookup.get((packet_type, source_type, None)) if cls: source_type_or_catalog = source_type else: source_catalog = self._source_type_catalog_lookup.get(source_type) cls = self._packet_lookup.get((packet_type, source_catalog, None)) if cls: source_type_or_catalog = source_catalog else: source_type_or_catalog = None if packet_type in APP_PACKET_TYPE_LOOKUP and cls: app_id = cls.parse_app_id() t_cls = self._packet_lookup.get((packet_type, source_type_or_catalog, app_id)) if t_cls: cls = t_cls return cls]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习（一） —— 准备工作]]></title>
    <url>%2F2017%2F03%2F29%2Fstart-machine-learning%2F</url>
    <content type="text"><![CDATA[使用Python开发web已经有一两年的时间了，是时候在业余时间接触下其他领域了。Python被称为“胶水语言”，在各个领域都占有一席之地，除了web开发之外，近年来在人工智能/机器学习也得到了广泛的应用。随着信息技术的不断发展，人工智能/机器学习也越来越受到欢。另一方面和web开发不同的是理论研究在机器学习中占有很大的比重。 入门资料在决定入机器学习这个领域，自己也大致搜索了各方面的资料，从以下教程入门，网上也有相关的电子资源。 《离散学习机器应用（原书第6版）》：图论、命题逻辑 《algorithms-in-python》：Python的算法书 《数据科学入门》：线性代数、统计概率等一些基础知识 《Python科学计算》：numpy等包的使用 《机器学习实战》：基于Python的各种算法实现 《机器学习导论》：理论阐述 昨晚刚读完《机器学习实战》第二章有关k近邻算法的内容，感觉这本书对于理论部分讲述的很少，后来又找来了《机器学习导论》这本书，两本书一起看，理论和实践相结合，应该会发挥更好地效果。 库安装Python3下安装一些基本库就比较简单了，matplotlib和numpy都可以用pip命令安装。 后记这是万里旅行的第一步，谨此记录，期许有个美好的开始。]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSC乱弹歌曲列表]]></title>
    <url>%2F2017%2F02%2F13%2Fosc-daily-blog-music%2F</url>
    <content type="text"><![CDATA[OSC乱弹歌曲列表，爬虫源码：https://git.oschina.net/kinegratii/codes/hjug0mlicztve9yd18xn553 보여줄게（给你看） - Ailee 风再起时 - 张国荣 風になる - つじあやの 青春贵族 - 中村雅俊 难得 - 安来宁 闷 - 王菲 锤子之歌 - 菠萝橙 追梦赤子心 - GALA 这么近那么远 - 张学友 身骑白马 - 徐佳莹 被风吹过的夏天 (Live) - live林俊杰/金莎 行かないで - 玉置浩二 给自己的情书 - 王菲 终于等到你 - 张靓颖 纷飞(live版) - 徐怀钰 童话镇 - 陈一发儿 百恋歌 - 高杉さと美 白色球鞋 - 陈奕迅 玫瑰花的葬礼 - 许嵩 猫になりたい - つじあやの 爱情 - 郭富城 温柔 (2013混音版) - 五月天 深海少女 - nero/ゆう十 深い森（TV动画《犬夜叉》片尾曲 第二弹） - Do As Infinity 流川枫与苍井空 - 黑撒 流れ星（小幸运 (日语版)） - 荒木毬菜 泣けない君へのラブソング - 前田亘辉 河 - 张雨生 極楽浄土 - GARNiDELiA 梦回唐朝 - 唐朝 月光下的凤尾竹 - 葫芦丝 暗涌 - 王菲 春风十里 - 鹿先森乐队 春风十里 - 鹿先森乐队 散了吧 - 林志炫 摄影艺术 - 许嵩 我们的歌 - 王力宏 情人 - 许巍 思ひで（深夜食堂 片头曲） - 鈴木常吉 幻听 - 许嵩 幸福的旁边 - 花儿 娃娃脸 - 后弦 好久不见 - 张学友 天空之城 - 李志 大鱼（动画电影《大鱼海棠》印象曲） - 周深 吻得太逼真 - 张敬轩 南方姑娘 - 赵雷 十二楼 - 杨宗纬 初恋 - 玉置浩二 刚刚好 - 薛之谦 分手快乐 - 冰淇 光辉岁月 - Beyond 你还要我怎样 - 薛之谦 为爱痴狂 (Live) - 刘若英 一辈子的孤单 (Live)（电视剧《涩女郎》片尾曲） - 刘若英 一起走过的日子 (粤)（电影《至尊无上Ⅱ之永霸天下》主题曲） - 刘德华 一剪梅（电影《夏洛特烦恼》主题曲） - 黄渤/左小祖咒 ムーンライト伝説（テレビアニメ『美少女戦士セーラームーン』オープニングテーマ主題歌） - Dali ポケットにファンタジー - じゅり ハーフムーン・セレナーデ（月半小夜曲） - 河合奈保子 ニッポン笑顔百景（TV动画《女子落语》ED / TVアニメ『じょしらく』EDテーマ） - 桃黒亭一門 スカイクラッドの観测者 - いとうかなこ グッバイ・デイ - 来生たかお おくりびとon record - 久石譲 いつも何度でも(主题歌) - 木村弓 あなただけ见つめてる - 大黒摩季 《어디부터 어디까지》- 泫雅/梁耀燮 《너에게》- 成时京 《閃光の行方》- 小寺可南子 《铁血丹心》- 罗文/甄妮 《那么骄傲》- 金海心 《遇见》- 言叶之庭 《追梦赤子心》- GALA 《路过蜻蜓》- 林忆莲 《贝加尔湖畔》- 李健 《请不要对我说sorry》- 何洁 《苦笑》 - 汪苏泷 《花香》- 林志炫 《终身美丽》- 郑秀文 《离歌》- 信 《神啊，救救我》- 陈小春 《相守》- 栗先达 《生如夏花》- 朴树 《理想三旬》- 陈鸿宇 《牡丹江》- 南拳妈妈 《爱你十分泪七分》 - 裘海正 《烟花三月(烟花三月XRCD)》- 童丽 《海の见える街》- 久石让 《泪海》- 徐茹芸 《没有舍不得》- 花漾年华 《朋友的酒》 - 李晓杰 《曲终人散》- 张宇 《春季自救指南》 - 上海彩虹室内合唱团 《星降る夜のリストランテ》- コーコーヤ 《明日への鼓動》- 小寺可南子 《无までの30分》- andymori 《文学少女で“文学少女”》 - Audio Highs 《我知道你很难过》- 蔡依林 《我梦见我梦见我》- 本兮 《我不要被你记住》- 周柏豪 《愿(Live) - live》- 莫文蔚 《家》- 许巍 《好久不见》- 陈奕迅 《太多》- 陈冠蒲 《夢のつづき》- 玉置浩二 《啜泣》- 李克勤 《南山南》- 马頔 《勇敢一点》- 薛之谦 《分裂(离开)》- 周杰伦 《冬天不会再冷》- 徐盼. 《再等几天 (Live)》- 陈奕迅 《其实我不快乐》- 钟嘉欣 《低回》- 杨宗纬 《东京不太热》- 洛天依 《一生所爱 》- 舒淇 《一生守候》 - 王若琳 《ただひたすらに、前へ》 - Falcom Sound Team jdk 《warriors》- Imagine Dragons 《secret base》- 茅野愛衣 / 戸松遥 / 早見沙織 《dream it possible》- Delacey 《Young And Beautiful》 - Lana Del Rey 《What Are Words》- Chris Medina 《We Don’t Talk Anymore (原唱：Charlie Puth)》- 莫文蔚 《Victory》- Two Steps From Hell 《Turnin’》- Young Rising Sons 《Today My Life Begins》 - Bruno Mars 《To Be Free》 - 华晨宇 《Stay Gold》- 大橋トリオ 《Some Dreams》- Allan Taylor 《Ring Off The Hook》- w-inds 《Radioactive》- William Joseph 《Por Una Cabeza (一步之遥)》- Elvins.J 《Parachute》- Sean Lennon 《PG家长指引(Live) - live》- 陈奕迅 《One more time, One more chance》- 山崎まさよし 《No ones saves us but ourselves》- Kraddy 《Love Is A Waste Of Time》- Sonu Nigam / Shreya Ghoshal 《Kong》- 侧田 《Jenny》- Robert de Boron / Daichi Diez / Shaira 《I Hate myself for loving you》- Joan Jett 《I Am You》- Kim Taylor 《Hotel California》- Eagles 《Fade(钢琴版)》- 马里奥赛德 / Alan Walker 《Eyes On Me》- 王菲 《Closer》- The Chainsmokers/Halsey 《Christmas Lights》- Coldplay 《California Dreaming (重庆森林)》- The Papas / The Mamas 《&nbsp;神经病之歌 》- 洛天依 / 言和 《 時の過ぎゆくままに 》- 沢田研二 《 みちゆき 》- 引田香織 sugar - Maroon 5 Young For You - GALA Yellow - Coldplay What Makes You Beautiful - One Direction Viva La Vida - Coldplay There You’ll Be (Album Version)（电影《珍珠港》片尾曲） - Faith Hill TO BE - 浜崎あゆみ Somebody That I Used To Know - Gotye/Kimbra Sledgehammer (From The Motion Picture “Star Trek Beyond”)（ 电影《星际迷航3：超越星辰》主题曲） - Rihanna Simple Life - Young Rising Sons Shots (feat. Broiler) [Broiler Remix] - Imagine Dragons / Broiler Shots (feat. Broiler) [Broiler Remix] - Imagine Dragons / Broiler Roads - Portishead PG家长指引(Live) - live - 陈奕迅 Opening - 黄英华 One Night In 北京 - 信乐团 Numb - Linkin Park Mariage d’amour（梦中的婚礼） - 理查德.克莱德曼 Maps - Maroon 5 Lost stars - Keira knightley Je m’appelle Hélène（我的名字叫伊莲） - Hélène Rolles It’s only the fairy tale - 宮村優子 I Am You - Kim Taylor Hymn For The Weekend [Remix] - Alan Walker/Coldplay Hey, Soul Sister - Train Here We Are （电影《使徒行者》主题曲） - 华晨宇 Hello World - Lady Antebellum HTML - The Hot Toddies HTML - The Hot Toddies Gate of steiner -piano- 阿保剛 GRACE KELLY - 大橋トリオ Dearest - 浜崎あゆみ Counting Stars - OneRepublic Cheapest Flight - PREP Bressanone（布列瑟农） - Matthew Lien]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>开源中国</tag>
        <tag>爬虫</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取OSC每日乱弹的音乐]]></title>
    <url>%2F2017%2F02%2F13%2Ffetch-music-of-daily-blog-in-oschina%2F</url>
    <content type="text"><![CDATA[使用aiohttp + lxml/爬取OSC乱弹的歌曲 一 原理分析爬取路径与结果 爬取路径：博客列表 =》 提取博客链接 =》 获取博客内容 =》 提取歌曲信息，最后获取的结果包含了博客链接、博客标题、歌曲链接，歌曲标题的一个列表。 1234[ &#123;'blog_url': 'xxx', 'blog_title': 'xxx', 'music_url': 'xxx', 'music_title': 'xxx'&#125;, &#123;'blog_url': 'xxx', 'blog_title': 'xxx'&#125;,# 该博客歌曲提取失败] 起点url 爬取的起点url为博客列表的页面链接。 1https://my.oschina.net/xxiaobian/blog?catalog=547834&amp;sort=time&amp;p=&#123;page&#125; 其中page表示页码，范围取值为1-24,25页之后的乱弹就没有网易云音乐的歌曲了。 歌曲链接 歌曲链接的格式为：http://music.163.com/#/song?id=5038302或者http://music.163.com/#/song/187747/，可归纳为以http://music.163.com/#/song开头的均符合要求。 歌曲标题 首先在博客中查找。歌曲标题通常为 - 分割的一整个段落，表示歌曲和歌手。比如最新博客使用“单独段落+书名号”（如&lt;p&gt;《Victory》- Two Steps From Hell&lt;p&gt;）这种就比较好匹配，没有书名号的就很少能够提取到。 在博客文档中无法找到（通常是由于匹配规则无法覆盖所有情况），向云音乐网站获取数据，注意两点： 需要将 http://music.163.com/#/song?id=28285557 转换成 http://music.163.com/song?id=28285557 格式 网页标题去掉末尾的字符串“- 网易云音乐”即是所需要的歌手歌曲信息。 二 实现协程并发执行 程序的核心利用协程实现并发执行，和多线程不同，所有代码都在一个线程执行，减少上下文切换，无需要线程之间的锁机制，效率可大大提高。 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 —— 《协程 - 廖雪峰的官方网站》 程序主要使用了以下几个库： asyncio：Python3标准库，异步IO， aiohttp:异步HTT库，类似于requests的异步实现 lxml：html解析，使用xpath语法 re：正则表达式 按照aiohttp的文档将每一个HTTP请求和内容解析都包装成一个协程函数： fetch_music_title(song_url)获取歌手歌曲信息 fetch_music(blog_url) 获取歌曲信息 fetch_blog_list(page) 获取博客列表 根据逻辑将这三个协程包裹新的协程fetch_page_music(page)，用于获取每一页博客中的歌曲信息列表。程序运行时，为每一页创建一个fetch_page_music协程并放进事件循环，待所有协程执行完整后处理相关数据并显示。 代码注释 loop.run_until_complete() 返回值为各个协程函数的返回值组成的列表 //a[@class=&quot;blog-title&quot;]表示获取class为blog-title所有a元素 //a[starts-with(@href, &quot;http://music.163.com/&quot;)]表示获取href值以http://music.163.com/ 开头的所有a元素。 itertools.chain.from_iterable(iterable)将数组“压平”，如 [[1,2], [3,4],[5,6]] 返回 [1,2,3,4,5,6] 三 运行原理结果 四 其他源代码 链接：爬取OSC乱弹的歌曲 （要求Python3.5+） 爬取结果 一共爬取了185首歌曲，码云代码片段没有md功能，存自己博客上了，点击访问链接。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>开源中国</tag>
        <tag>异步IO</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript农历库]]></title>
    <url>%2F2017%2F01%2F28%2Ftypescript-calendars%2F</url>
    <content type="text"><![CDATA[本文描述了自己写了一个 Typescript 日历库。 1 数据结构一个日期使用 CalendarDate 类表示，其属性如下： 1234567891011121314151617181920CalendarDate &#123; lYear: 2016, lMonth: 11, lDay: 8, animal: '猴', lMonthCn: '冬月', lDayCn: '初八', sYear: 2016, sMonth: 12, sDay: 6, gzYear: '丙申', gzMonth: '己亥', gzDay: '壬戌', isToday: false, isLeap: false, nWeek: 2, nWeekCn: '星期二', isTerm: false, term: null, astro: '射手座' &#125; 2 创建日期对象1import &#123; CalendarDate,Calendars &#125; from 'calendars'; 2.1 公历转农历使用 Calendars.solar2lunar() 或者 Calendars.fromSolarDate() 从农历日期创建 CalendarDate 对象。 12let date:CalendarDate = Calendars.solar2lunar();date.format('&#123;sYear&#125;年&#123;sMonth&#125;月&#123;sDay&#125;日') // '2016年12月5日' 2.2 农历转公历使用 Calendars.lunar2solar() 或者 Calendars.fromLunarDate() 从农历日期创建 CalendarDate对象。 12let date2:CalendarDate = Calendars.lunar2solar(2017, 6, 1, true); // 2017年农历闰六月初一date.format('&#123;sYear&#125;年&#123;sMonth&#125;月&#123;sDay&#125;日') // '2017年7月23日' 2.3 从通用字符串创建12let date3:CalendarDate = Calendars.fromDateString('2017060111'); // 2017年农历闰六月初一date3.format('&#123;sYear&#125;年&#123;sMonth&#125;月&#123;sDay&#125;日') // '2017年7月23日' 3 工具类3.1 日期间隔123456// 230，距离今天还有230天date2.delta()date2.delta(date)date2.delta(&#123;sYear:2017,sMonth:7,sDay:23&#125;)Calendars.delta(date, date2);Calendars.delta(&#123;sYear:2016,sMonth:12,sDay:5&#125;, &#123;sYear:2017,sMonth:7,sDay:23&#125;) 3.2 日期推算1234567891011//两天之后date2.offset(2)//或date2.after(2)//两天之前date2.offset(-2)//或date2.before(2)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows+django+apache+wsgi项目部署]]></title>
    <url>%2F2016%2F12%2F09%2Fwindows-django-apache-wsgi%2F</url>
    <content type="text"><![CDATA[基本环境 Windows 7 32位 Python 2.7 32位 Django 1.10 Apache 2.2 目录文件位置 名称 文件目录 virtualenv D:/env/dj110/ Django项目目录 D:/nms wsgi.py D:/nms/nms/wsgi.py 静态文件目录 D:/static/nms/ 上传文件目录 D:/upload/nms/ Apache目录 C:/Apache22/ 步骤1 下载 Apache 2.2 32位，并解压至 C:\Apache22\ 。 2 下载mod_wsgi模块文件，将 mod_wsgi 放入 C:\Apache2.2\modules 目录。 3 编写 http.conf 文件。 12345678910111213141516171819202122232425262728293031WSGIPythonPath D:/nms;D:/env/dj110/Lib/site-packages;#----------------------------------------------------------------------#virtual host for nms&lt;VirtualHost *:8020&gt;ServerAdmin test@163.comDocumentRoot D:/nmsAlias /static/ D:/static/nms/Alias /upload/ D:/upload/nms/&lt;Directory D:/static/nms&gt;Order deny,allowAllow from all&lt;/Directory&gt;&lt;Directory D:/upload/nms&gt;Order deny,allowAllow from all&lt;/Directory&gt;WSGIScriptAlias / D:/nms/nms/wsgi.py&lt;Directory D:/nms/nms/&gt;&lt;Files wsgi.py&gt;Order deny,allowAllow from all&lt;/Files&gt;&lt;/Directory&gt;&lt;/VirtualHost&gt; Q&amp;A静态文件404 使用django 的collectstatic 命令将所有的静态文件收集到一个目录下，可以不在Django项目下，然后使用Alias由Apache接管/static/的访问。 静态文件403 Alias /static/ D:/static/nms/中static文件目录最后需要加上目录分隔符 /。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>部署</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic2杂记]]></title>
    <url>%2F2016%2F12%2F02%2Flearning-ionic2%2F</url>
    <content type="text"><![CDATA[1 技能链 Typescript –&gt; Angular2 –&gt; ionic2 ionic2是基于Angular2开发，Angular2是使用Typescript重新改写的。Typescript是Javascript类型的超集。学习之前先列出相关中文文档。 Typescript中文网 Angular2中文文档 ionic2 2 Typescript和Javascript相比，在函数、接口、类、泛型都有很大的变化，总的来说，会使得程序更加明确，加强了面向对象的一些设计规范。 interface是接口，class是类。类可以实现接口。 3 第三方js库与d.ts声明文件对于现有第三方js库，根据不同情况采取不同的策略。 下载d.ts声明文件 自己编写d.ts声明文件 实现对应TypeScript的版本 一些常用库诸如underscope.js可在DefinitelyTyped/DefinitelyTyped下载到对应的d.ts文件。 中国家庭称谓计算器，该项目的接口只有一个顶级函数 relationship，相应的d.ts文件可以自己编写。以下是一种写法。 文件 relationship.d.ts 12345678interface RelationshipOptions &#123; text:string; sex:number; type:string; reverse?:boolean;&#125;declare function relationship(relationshipOptions:RelationshipOptions):string;export = relationship; 调用示例 demo.ts 1234567891011/// &lt;reference path="relationship.d.ts" /&gt;import relationship = require('./relationship');let s = relationship(&#123; text:'爸爸的弟弟', sex:1, type:'default', reverse:true&#125;)console.log(s); //侄子 而项目引用的另一个库《1900年至2100年公历、农历互转Js代码》，API也比较简单，但ionic1项目中对其进行了比较多的扩展（日期加减），因此采用重写自己的Typescript版本。项目地址 https://github.com/kinegratii/ts-calendars。 4 版本与开发IDE目前ionic2版本为rc3，还未发布正式版，但按照版本规律，许多API已经稳定下来了，不像Beta的时候有项目布局那样大的改变，因此可以开始使用和迁移了。 习惯了JetBrain系列的IDE，因此使用WebStorm进行开发，当然是用VS Code也是大家极力推荐的。 5 创建项目ionic2和ionic1相比，项目布局变化比较多，决定重新创建一个项目，不在原有的项目进行更改，使得一开始就符合ionic2的开发规范。 使用下面的命令行创建一个ionic2项目。 1ionic start FamilyApp --v2 默认使用tabs界面，创建了三个页面。 6 页面使用以下命令创建新的页面。 1ionic generate page more 在src/pages/创建以下三个文件。 more/more.html 模板文件 more/more.scss css样式 more/more.ts 组件代码 并且将新页面加入模块app.module.ts文件中。 12345678910@NgModule(&#123; declarations:[ # ... MorePage, ], entryComponents:[ # ... MorePage, ]&#125;) 7 导航习惯先创建所有的页面，完成跳转逻辑，最后再写各个页面的逻辑。 ionic2的导航类似于Android，像一个简单的栈，可以进行push和remove操作。不建议使用url来决定导航，当然从底层也支持这么做。 1no component factory found for AboutPage 在刚使用导航（MorePage -&gt; AboutPage）时出现了这个错误，解决的方案是将AboutPage加到app.module.ts的declarations和entryComponents，两个都要添加。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django实践：数据库查询]]></title>
    <url>%2F2016%2F11%2F18%2Fdjango-models-practice%2F</url>
    <content type="text"><![CDATA[1 概述本文总结了一些Django数据库查询的实践经验。 基本的增删改查 分类统计：aggregate和annotate的使用 实现按年/月/日统计 Manager和QuerySet的混合使用 编写迁移文件 根据Django官方文档，本人整理出与数据库相关的话题列表， 基本的增删改查 外键访问 (Accessing related objects) 管理器和查询集 (Manger &amp; QuerySet) 原生SQL (raw SQL) 事务 (Transactions) 统计、聚合和分组 (Aggregation) 搜索 (Search) 自定义字段 (Custom fields) 多数据库 (Multiple databases ) 查询表达式和自定义查询表达式(Lookup expressions &amp; Custom lookups) 条件表达式 (Conditional Expressions) 数据库函数 (Database Functions) 数据库优化 (Optimize database access) 数据库迁移 (Migrations) 其中一部分是在数据库有对应的内容，另外一部分则是Django框架自有的特性。涉及的代码主要包括以下三个包： django.db.connections: 底层数据库连接对象操作 django.db.migrations: 迁移相关 django.db.models: 模型定义、数据库查询 2 查询API2.1 模型描述以一个设备管理系统的简易系统为例，该项目包含了设备描述和报警记录。 设备以序列号唯一确定该设备，可默认为“主键”。 longitude latitude和address表示设备的地理位置，创建后可认为不可更改。 设备含有使用和报警两个状态标识变量。 Alarm.catalog表示警报类型，定义在choices上。 123456789101112131415161718192021222324252627class Device(models.Model): serial = models.CharField(verbose_name='序列号', max_length=100, unique=True) name = models.CharField(verbose_name='名称', max_length=100, null=True, blank=True) longitude = models.FloatField(verbose_name='经度', null=True, validators=[validators.MaxValueValidator(180), validators.MinValueValidator(-180)]) latitude = models.FloatField(verbose_name='纬度', null=True, validators=[validators.MaxValueValidator(90), validators.MinValueValidator(-90)]) address = models.CharField(verbose_name='地址', max_length=100, null=True) is_active = models.BooleanField(verbose_name='使用标识', default=True) is_alarm = models.BooleanField(verbose_name='报警标识', default=False) latest_alarm_time = models.DateTimeField(verbose_name='最新报警时间', null=True, blank=True) latest_alarm_remark = models.CharField(verbose_name='最新报警内容', max_length=200, null=True, blank=True) def __str__(self): return self.serialclass Alarm(models.Model): ALARM_CATALOG_CHOICES = ( ('low_battery', '低电量'), ('fail_connection', '通信故障'), ('location_moved', '位置移动') ) device = models.ForeignKey(Device, verbose_name='设备') create_time = models.DateTimeField(verbose_name='创建时间', default=timezone.now) catalog = models.CharField(max_length=30, null=True, choices=ALARM_CATALOG_CHOICES) content = models.CharField(verbose_name='内容', max_length=30, null=True, blank=True) read = models.BooleanField(verbose_name='已读', default=False) 2.2 查询一览表2.2.1 检索、过滤、外键查询、分页1234567891011121314151617# 查询mac地址为'0FFFFFFF561C4030'的设备try: device = models.Device.objects.get(serial='0FFFFFFF561C4030')except models.Device.DoesNotExist: device = None&lt;Device:0FFFFFFF561C4030&gt;# 查询地址包含“小区”的设备。&gt;&gt;&gt; device_list = models.Device.objects.filter(address__icontains='小区')&lt;QuerySet [&lt;Device: 0FFFFFFF5BC91F87&gt;, &lt;Device: 0FFFFFFF561C4030&gt;, ...]&gt;# 查询设备'0FFFFFFF5BC91F87'的所有报警记录models.Alarm.objects.filter(device__serial='0FFFFFFF5BC91F87')# 假设设备列表每页20项，查询第3页的数据。device_list = models.Device.objects.all()[20:30] 2.2.2 更新12345678910111213# 单记录更新try: device = models.Device.objects.get(serial='0FFFFFFF561C4030') device.is_active = False device.save()except models.Device.DoesNotExist: pass# 多记录更新models.Device.objects.filter(serial__in=['0FFFFFFF561C4030', '0FFFFFFF56174CA0']).update(is_active=False)# 去掉所有设备地址中“福建省”的前缀，比如“福建省厦门市Xxxx”改为"厦门市Xxxx"。models.Device.objects.filter(address__isnull=False).update(address=F('address').strip('福建省')) 2.2.3 删除123456789101112# 删除单条记录try: device = models.Device.objects.get(serial='0FFFFFFF561C4030') device.delete()except models.Device.DoesNotExist: pass# 批量删除models.Alarm.objects.filter(serial='0FFFFFFF561C4030').delete()# 由于delete只是QuerySet的方法，并没有向Manager公开，需要先调用all方法models.Alarm.objects.all().delete() # OKmodels.Alarm.objects.delete() # Fail 2.2.4 基础统计：数据、最值和平均值12345678910111213141516171819202122# 计算设备0FFFFFFF561C4030所有的报警数目。models.Alarm.objects.filter(device__serial=&apos;0FFFFFFF561C4030&apos;).count()# 165# 计算每个设备的报警数目。&gt;&gt;&gt; device_list = models.Device.objects.annotate(num_alarms=Count(&apos;alarm&apos;))&gt;&gt;&gt; device_list&lt;QuerySet [&lt;Device: 0FFFFFFF561C4021&gt;, &lt;Device: 0FFFFFFF561C4030&gt;, ...]&gt;&gt;&gt;&gt; device_list [0].num_alarms34# 查询2016年报警次数最多的前5个设备models.Alarm.objects.filter(create_time__year=2016).values(&apos;serial&apos;).annotate(num_alarms=models.Count(&apos;serial&apos;)).order_by(&apos;-num_alarms&apos;)[:5][ &#123;&apos;serial&apos;:&apos;0FFFFFFF9FFC15F9&apos;, &apos;num_alarms&apos;:38&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF71281152&apos;, &apos;num_alarms&apos;:32&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF5992B723&apos;, &apos;num_alarms&apos;:27&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF05E20356&apos;, &apos;num_alarms&apos;:21&#125;, &#123;&apos;serial&apos;:&apos;0FFFFFFF66DDF14D&apos;, &apos;num_alarms&apos;:12&#125;,] 2.2.5 分类统计分类统计有以下两种方法。 aggregate + 条件表达式Case，返回一个字典形式的结果，未出现的分类值默认为None，需要使用Coalesce函数设置默认值 annotate + 分组GROUP BY，返回一个列表形式的结果，未出现的分类值不会出现在最后的结果中 下面是两种方式查询最近30天中每个报警类型的报警数目为例。 123456789101112131415161718192021latest_week_qs = models.Alarm.objects.filter(create_time__gt=timezone.now()-timedelta(days=30).# aggregate方式latest_week_qs.aggregate( fail_connection=Coalesce(Sum( Case(When(catalog='fail_connection', then=1), output_field=models.IntegerField()), ), 0), low_battery=Coalesce(Sum( Case(When(catalog='low_battery', then=1), output_field=models.IntegerField()), ), 0), location_moved=Coalesce(Sum( Case(When(catalog='location_moved', then=1), output_field=models.IntegerField()), ), 0))# 结果&#123;‘fail_connection’：12， 'low_battery'：34, 'location_moved': 0&#125;# annotate方式latest_week_qs.values('catalog').annotate(count=Count('catalog'))# 结果[&#123;'catalog':'low_battery', 'count':34&#125;,&#123;'catalog':'fail_connection'， 'count': 12&#125;] 2.2.6 日期统计实现按年、月、日统计通常有两种方法： 数据库函数 django.db.connection.ops.date_trunc_sql 对第一种的封装类DateExtra，仅Django 1.10+可用 以上两种结果中日期类型不一样，第一种返回时datetime对象，第二种只返回其中的分类字段，为整数类型。 12345678910111213141516171819# 查询mac地址为`0FFFFFFF561C4030`的设备最近一周每天报警次数。models.Alarm.objects.filter(serial='0FFFFFFF561C4030', create_time__gt=timezone.now()-timedelta(days=7)).extra( select=&#123;'dt': connection.ops.date_trunc_sql('day', 'create_time')&#125;).values('dt').annotate(count=models.Count('create_time')).order_by('dt')[ &#123;'count':4, 'dt':datetime.datetime(2016, 11, 08, 0, 0, 0,0)&#125;, &#123;'count':2, 'dt':datetime.datetime(2016, 11, 11, 0, 0, 0,0)&#125;, &#123;'count':1, 'dt':datetime.datetime(2016, 11, 12, 0, 0, 0,0)&#125;]# 在Django 1.10+ 还可以使用`DateExtra`相关类models.Alarm.objects.filter(serial='0FFFFFFF561C4030', create_time__gt=timezone.now()-timedelta(days=7)) annotate(day=ExtractDay('create_time'))# 结果&#123; 'count':4, 'day': 8, 'count':2, 'day': 11, 'count':1, 'day': 12&#125; 2.3 数据库函数 django.db.models.Q: 与、或、非条件组合查询 django.db.models.F: F()表示数据库中相应字段的值，用于计数器更新等。 django.db.models.Functions.Coalesce:接收一组参数，返回第一个不为None的数据， 更多函数可参考Database Functions。 3 管理器和查询集3.1 管理器与模型的关系管理器是Django数据库查询的接口。查询语法 models.XxModels.objects.filter(*kwargs) 。 一个模型可以拥有一个或多个管理器。 默认情况下，每个模型都有名为objects的管理器，默认返回数据表中所有记录。 管理器来源于默认管理器、外键管理器和自定义管理器。 3.2 自定义管理器当一些查询逻辑复杂而且经常使用时，往往是在管理器上添加自定义函数封装相关查询逻辑，一方面减少重复代码，另一方面对view层透明，有利于MVC职责分工。 自定义管理器有三种方法 3.2.1 继承 models.Manager这是默认出现的方式，以下 period_date函数封装了日期时间段查询函数 1234567891011121314151617181920212223242526272829303132333435class AlarmManager(models.Manager): def period_date(self, field, start_date=None, end_date=None, fmt='%Y-%m-%d'): """封装日期开始结束时间段查询""" def to_datetime(val): if isinstance(val, (datetime, date)): return val else: try: return datetime.strptime(val, fmt) except (TypeError, ValueError): pass kvs = &#123;&#125; start_date = to_datetime(start_date) end_date = to_datetime(end_date) if start_date: kvs[field + '__gte'] = start_date if end_date: kvs[field + '__lte'] = end_date + timedelta(days=1) # 包含当前 return self.filter(**kvs) def has_location(self): return self.filter(longitude__isnull=False, latitude__isnull=False) def unread(self): return self.filter(read=False)# views.py# 返回未读的报警记录alarm_list = models.Alarm.objects.unread()# 返回2016年9月12日到21日的报警记录alarm_list = models.Alarm.objects.period_date(field='create_time', start_time='2016-09-12', end_time='2016-09-21')# 返回2016年9月26日以前的报警记录alarm_list = models.Alarm.objects.period_date(field='create_time', end_time='2016-09-26')#返回2016年9月26日以前的未读报警记录alarm_list = models.Device.objects.period_date(field='create_time', end_time='2016-09-26').unread()AttributeError: '_QuerySet' object has no attribute 'unread' 在最后一个查询中出现异常，因为这两个方法定义在models.Manager上，返回的却是models.QuerySet实例。这时非常希望自定义的方法能够级联调用，下面的几种方法可以解决这个问题。 3.2.2 使用QuerySet的方法使用查询集上的 as_manager()函数创建新的管理器 将自定义的方法定义从models.Manager移到models.QuerySet 123456789101112class AlarmQuerySet(models.QuerySet): def period_date(self, field, start_date=None, end_date=None, fmt='%Y-%m-%d'): # 省略具体代码 pass def has_location(self): return self.filter(longitude__isnull=False, latitude__isnull=False) def unread(self): return self.filter(read=False)class Alarm(models.Model): ... objects = AlarmQuerySet.as_manager() 这时代码alarm_list = models.Device.objects.period_date(field=&#39;create_time&#39;, end_time=&#39;2016-09-26&#39;).unread()就能够返回正确的结果。 3.2.3 继承Manager和QuerySet使用管理器上的from_queryset(queryset_class)函数创建新的管理器在使用django认证用户上一方面需要继承 django.contrib.auth.models.BaseUserManager，另一方面又希望能够自定义函数，这时可以使用这种方式。 123456789101112class UserQuerySet(models.QuerySet): def no_login_in_days(self, days): start_time = timezone.now() - timedelta(days=days) return self.filter(last_login_time__ge=start_time) def no_activity_in_days(self, days): start_time = timezone.now() - timedelta(days=days) return self.filter(last_activity_time__ge=start_time)MyUserManager = BaseUserManager.from_queryset(UserQuerySet)class MyUser(AbstractBaseUser): objects = MyUserManager() 当直接调用django.db.models.Manager.from_queryset方法，其等效于第二种方法，即以下两行等效。 1234# 使用as_manager函数objects = AlarmQuerySet.as_manager()# 使用from_queryset函数objects = models.Manager.from_queryset(AlarmQuerySet) 3.3 managers模块实践随着业务逻辑越来越复杂，需要编写更多的自定义管理器，通常的做法是单独创建一个名称为managers的模块，封装所有数据操作。 1234567891011121314151617181920212223242526from django.db import modelsfrom django.contrib.auth.models import BaseUserManager__all__ = ['AxxManager', 'BxxManager', 'UserManager'] # 外部模块只能引用XxxManager类class BaseQuerySet(models.QuerySet): def common_method_for_all_models(self): passclass AxxQuerySet(BaseQuerySet): passAxxManager = models.Manager().from_queryset(AxxQuerySet)class BxxQuerySet(BaseQuerySet): passBxxManager = models.Manager().from_queryset(BxxQuerySet)class UserQuerySet(BaseQuerySet): passclass UserManager(BaseUserManager.from_queryset(UserQuerySet)): def create_user(self, username, password=None, **kwargs): pass 为避免模块循环导入的问题 需要使用django.apps.apps.get_model函数获取模型类对象，不能直接使用 from models import Xxxx managers模块一般只能被models模块引用，其他模块应当不能引用 3.4 其他覆盖get函数异常 在获取对象函数会抛出ObjectDoesNotExist异常，在这种情况下我们需要使用try-catch捕捉异常，会出现大量重复的代码。这时我们可以用下的代码实现封装。 123456789class BaseManager(models.Manager): def get_object(self, **kwargs): try: return self.get(**kwargs) except models.ObjectDoesNotExist: return None# 以下方式访问device = models.objects.get_object(serial='0FFFFFFF66DDF13F') 访问request变量 按照MVC分离的实践，不应该直接访问request，只能通过参数传递方式。 4 迁移4.1 开发流程迁移是将模型代码的变化应用到数据库，可以认为是一个数据库模式的版本管理系统。 在Django1.7之前的版本第三方库South提供了类似的功能。 迁移通常可以按照下列步骤循环进行。 1 编写 models 模块代码 2 模型迁移：执行 python manage.py makemigrations，在APP.migrations包生成迁移模块文件。 3 数据迁移：如果需要数据迁移，按照一定的格式编写迁移文件。 3 应用迁移：执行 python manage.py migrate，将2、3步迁移文件所实现的数据库变化应用到数据库。 Django Migration分为模式迁移（Schema migration）和数据迁移（Data Migration）。 模式迁移：包括表结构修改，对应于 SQL的 CREATE TABLE ALTER TABLE和 DROP TABLE，可以由Django自动生成。 数据迁移：包括数据记录修改，对应于SQL的 INSERT TO DELETE和 UPDATE等语句,需要开发者自己编写。 无论是模式迁移还是数据迁移，迁移模块都具有几个特点： 每个迁移文件是一个Python模块，位于应用目录migrations包下，代表了一次迁移 每个迁移包含一个名为Migration的迁移类，该类继承自 django.db.migrations.Migration dependencies 属性表示需要依赖的迁移模块名称 operations 属性表示一系列依次进行的迁移操作，这些都定义在 django.db.migrations.operations模块中。 12345from django.db import migrationsclass Migration(migrations.Migration): dependencies = [] operations = [] 4.2 数据迁移下面的例子实现了将设备的longitude latitude和address三个字段复制到报警记录表中，以便查询位置时无需外接操作。 所有的操作被操作 migrations.RunPython 类中，要注意的是需要 django.apps.get_model 函数引用模型类。 1234567891011121314151617181920from __future__ import unicode_literalsfrom django.db import migrations, modelsdef create_address_for_alarm(apps, scheme_editor): AlarmClass = apps.get_model('hdc', 'Alarm') for alarm in AlarmClass.objects.all(): alarm.longitude = alarm.device.longitude alarm.latitude = alarm.device.latitude alarm.address = alarm.device.address alarm.save()class Migration(migrations.Migration): dependencies = [ ('hdc', '0002_alarm_address'), ] operations = [ migrations.RunPython(create_address_for_alarm), ] 5 参考资料 QuerySet API reference | Django documentation | Django Django aggregation, group by day Filtering on annotations in Django Building a higher-level query API: the right way to use Django’s ORM - DabApps, Brighton, UK Django Migrations - A Primer - Real Python Django Custom Model Manager Chaining - Hunter Ford]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic安卓构建]]></title>
    <url>%2F2016%2F10%2F29%2Fionic-build-android%2F</url>
    <content type="text"><![CDATA[本文描述了ionic项目构建Android安装包的主要步骤。 1 环境配置1.1 添加Android平台执行 ionic platform add android 即可 1.2 Java路径配置1PATH=path\to\bin\ 1.3 Android环境配置1ANDROID_HOME=你的SDK目录 将 %ANDROID_HOME%\tools\;%ANDROID_HOME%\platform_tools\ 加到PATH变量后面。 2 Android自动签名2.1 配置release-signing.properties文件 在platforms\android目录新建名为release-signing.properties的文件，文件内容如下 1234storeFile=path/to/keystorekeyAlias=your key aliasstorePassword=your store passwordkeyPassword=your key password 备注：在windows下storeFile文件路径应使用Unix下的目录分隔符 /。 3 编译使用 ionic build --release android 编译即可，在\platforms\android\build\outputs\apk出现android-release.apk文件即是已签名的安装包。 4 注意事项在升级到ionic2时，使用 ionic build --release android 可能会出现 ✗ You cannot run iOS unless you are on Mac OSX.的错误，可改为 ionic build android --release 即可。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的起点]]></title>
    <url>%2F2016%2F10%2F28%2Ffirst-post%2F</url>
    <content type="text"><![CDATA[你说有一日总会名扬天下实现你抱负 2016年10月28日，KgBlog重新启用，由之前的 Pelican 改用 hexo 构建，按照官方文档和相关资料将博客基本搭建完成。 当然还有许多事情还没有完成。 继续迁移之前的文章 添加多说评论 添加文章分享 使用自定义域名]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用DaoCloud部署Django项目]]></title>
    <url>%2F2016%2F07%2F23%2Fdaocloud-django-deploy%2F</url>
    <content type="text"><![CDATA[本文介绍了在DaoCloud平台部署Django项目的方法。 1 DaoCloud云平台关于DaoCloud云平台。https://www.daocloud.io/ DaoCloud 为用户提供了 Docker 镜像的自动构建和自动发布功能，当用户完成了 Dockerfile 和 daocloud.yml 文件的编写后，将应用代码推送到第三方代码托管平台上，将其与 DaoCloud 绑定后，在每次修改（commit）后，并将其推送到代码托管平台上，DaoCloud 会检测到代码的变动，并根据 Dockerfile 和 daocloud.yml 进行相应的构建和测试；当触发规定的构建事件（如 tag）时，DaoCloud 会将其进行镜像构建，并推送到相对应的所有生产环节中。 2 Django项目配置项目总布局如下： 123456789101112131415161718192021- wcp_platform/ - admin.py - forms.py - models.py - views.py- wcp/ - daocloud_settings.py - daocloud_wsgi.py - settings.py - test_settings.py - urls.py - wsgi.py- fixtures/ - user.json- static/- template/- Dockerfile- daocloud.yml- docker-entrypoint.sh- manage.py- requirements.txt 3 基于daocloud的配置3.1 daocloud_settings模块daocloud_settings模块重写了数据库配置（这里使用了mysql服务）和wsgi配置模块。 1234567891011121314from __future__ import unicode_literalsfrom .settings import *DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: os.environ[&apos;MYSQL_INSTANCE_NAME&apos;], &apos;USER&apos;: os.environ[&apos;MYSQL_USERNAME&apos;], &apos;PASSWORD&apos;: os.environ[&apos;MYSQL_PASSWORD&apos;], &apos;HOST&apos;: os.environ[&apos;MYSQL_PORT_3306_TCP_ADDR&apos;], &apos;PORT&apos;: os.environ[&apos;MYSQL_PORT_3306_TCP_PORT&apos;], &#125;&#125;WSGI_APPLICATION = wcp.daocloud_wsgi.application&apos; 3.2 daocloud_wsgi模块daocloud_wsgi.py模块设置了环境变量。 12345from __future__ import unicode_literalsimport osfrom django.core.wsgi import get_wsgi_applicationos.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;wcp.daocloud_settings&quot;)application = get_wsgi_application() 3.3 Dockerfile12345678910FROM daocloud.io/python:2.7ADD requirements.txt /tmp/requirements.txtRUN pip install -r /tmp/requirements.txtRUN mkdir /codeWORKDIR /codeCOPY . /codeCOPY docker-entrypoint.sh docker-entrypoint.shRUN chmod +x docker-entrypoint.shEXPOSE 8080CMD /code/docker-entrypoint.sh 具体流程 安装依赖库 拷贝项目代码 修改docker-entrypoint.sh权限为可执行 开放端口 执行docker-entrypoint.sh 3.4 启动脚本123ython /code/manage.py migrate --settings=wcp.daocloud_settings --noinputpython /code/manage.py collectstatic -- settings=wcp.daocloud_settings --noinput/usr/local/bin/gunicorn wcp.daocloud_wsgi:application -w 2 -b :8080 --env DJANGO_SETTINGS_MODULE=&apos;wcp.daocloud_settings&apos; 启动流程 创建数据表 收集静态文件 使用gunicorn启动Django项目 3.5 持续集成：daocloud.yml1234image: daocloud/ci-python:2.7script: - pip install -r requirements.txt - python manage.py test --settings=wcp.test_settings]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>DaoCloud</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动发送动弹到开源中国]]></title>
    <url>%2F2016%2F05%2F17%2Fosc-tweet-publish%2F</url>
    <content type="text"><![CDATA[自动发送动弹到开源中国。 登录系统，密码使用sha1算法加密。 获取用户信息，包括user_code和user_id。 发送动弹。 代码仅在Python3有效。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# coding=utf8from __future__ import unicode_literalsimport hashlibfrom datetime import datetimeimport reimport requestsclass OSCRobot: HEADERS = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.72 Safari/537.36' &#125; def __init__(self, *, username, password, user_code=None, user_id=None): self.username = username self.password = password self.user_code = user_code self.user_id = user_id self.client = requests.session() self.client.headers = self.HEADERS def login(self, **kwargs): if not (self.user_id and self.user_code): self._login(**kwargs) def _login(self, **kwargs): data = &#123; 'email': self.username, 'pwd': hashlib.sha1(self.password.encode('utf8')).hexdigest() &#125; has_login = False login_rsp = self.client.post('https://www.oschina.net/action/user/hash_login', data) if login_rsp.status_code == 200: home_rsp = self.client.get('https://www.oschina.net/') if home_rsp.status_code == 200: text = home_rsp.text m_regx = re.search(r":bind=\"user_code\"\svalue='(?P&lt;user_code&gt;[a-zA-Z0-9]+)'", text) if m_regx: self.user_code = m_regx.group('user_code') m_regx = re.search(r":bind=\"user\"\svalue='(?P&lt;user_id&gt;\d+)'", text) if m_regx: self.user_id = m_regx.group('user_id') has_login = True else: print('[Fail] No user id found!') else: print('[Fail] No user code found!') else: print('[Fail] Request home page fail with status code &#123;&#125;'.format(home_rsp.status_code)) else: print('[Fail] Login fail with status_code &#123;&#125;'.format(login_rsp.status_code)) if has_login: print('[Success] Login success! User info') else: print('[Fail] fail to login!') return has_login def publish_tweet(self, msg, **kwargs): post_data = &#123; 'user_code': self.user_code, 'user': self.user_id, 'msg': msg &#125; rsp = self.client.post('https://www.oschina.net/action/tweet/pub', post_data) if 200 &lt;= rsp.status_code &lt; 300: print('[Success] Push tweet success!') else: print('[Fail] Fail to push tweet!')def main(): robot = OSCRobot( username='YOUR USERNAME', password='YOUR PASSWORD' ) robot.login() robot.publish_tweet('Hello everyone! The current time is &#123;&#125;'.format(datetime.now().strftime('%Y-%m-%d %H:%M:%S')))if __name__ == '__main__': main()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>开源中国</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python打包工具]]></title>
    <url>%2F2016%2F04%2F23%2Fpython-package%2F</url>
    <content type="text"><![CDATA[本文介绍了py2exe、cx_freeze和PyInstaller这三种Python打包工具的使用方法。 1 Python打包工具目前在windows平台上将Python程序打包成exe文件主要有三个工具。 py2exe http://www.py2exe.org/ cx_freeze http://cx-freeze.sourceforge.net/ PyInstaller http://pythonhosted.org/PyInstaller/ 今天将一个Tkinter写的界面程序打包成exe文件，三个工具都试了一遍，感觉PyInstaller会比较好用一些。 2 py2exe2.1 下载安装从这里https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/ 选择python版本和计算机位数对应的exe文件，双击即可安装。 2.2 启动脚本写一个setup_py2exe.py文件 123456789101112from distutils.core import setupimport py2exeoptions = &#123;'py2exe': &#123;'compressed': 1, 'optimize': 2, 'bundle_files': 1, &#125;&#125;setup(name='App', author='kinegratii', version='1.0.0', options=options, windows=[&#123;"script": "app.py"&#125;], zipfile=None ) 2.3 命令执行python setup_py2exe.py py2exe即可，dist目录就是最后生成的结果。 2.4 Q&amp;Aimport py2exe import py2exe这个语句要保留，因为用PyCharm自动格式化的时候总会把这个语句优化掉。 UnicodeDecodeError异常 之前加了from __future__ import unicode_literals这个语句，会报UnicodeDecodeError: &#39;utf8&#39; codec can&#39;t decode byte 0xd1 in position 3: invalid continuation byte lxml库 程序报的异常是ImportError: No module named lxml._elementpath，但按照网上的说法加了includes参数可以解决。 12345options=&#123; 'py2exe': &#123; 'includes': ['lxml.etree', 'lxml._elementpath', 'gzip'], &#125;&#125; TypeError: expected string or buffer 这个异常是docx这个库出现的。找了很久还没有什么头绪。 3 cx_freeze3.1 pip安装执行pip命令即可安装 1pip install cx_Freeze 3.2 启动脚本setup_cx.py文件如下 12345678910111213141516171819from __future__ import unicode_literalsimport sysfrom cx_Freeze import setup, Executablebase = Noneif sys.platform == "win32": base = "Win32GUI"includeFiles = [ (r"D:\py\tcl\tcl8.5", "tcl"), (r"D:\py\tcl\tk8.5", "tk")]setup( name="App", version="1.0", description="A demo app", options=&#123;"build_exe": &#123;"include_files": includeFiles, &#125;&#125;, executables=[Executable("app.py", base=base, includes=['lxml', 'lxml.tree', 'lxml._namepath'])]) 3.3 命令执行命令python setup_cx.py build，dist下的exe.开头的文件夹（名字跟具体环境有关，比如我的是exe.win32-2.7）就是最后的生成的文件夹。 3.4 Q&amp;Alxml 也需要明确包含lxml._elementpath docx 也出现了和py2exe一样的异常。 4 PyInstaller4.1 pip安装执行pip安装 1pip install pyinstaller 安装成功后在python的目录下\Scripts文件夹多出pyinstaller.exe、pyinstaller.exe.manifest、pyinstaller-script.py等几个文件。 4.2 命令方式构建把Scripts目录加到系统的环境变量中，cd到脚本所在的目录，然后执行下面的命令。 1pyinstaller app.py -F -w --clean app.py 脚本文件 几个选项含义 -F 打包为单一文件，和打包为一个文件夹相对，默认为后者 -w 窗口程序，与控制台相对 –clean 每次清理中间产生的构建文件 生成的相关文件包括 app.spec 配置文件 build文件夹 构建中产生的中间文件 dist/app文件夹 这里的文件都是运行所需要的 4.3 启动脚本方式命令行带太多参数的话，每次都要输入，比较麻烦，可以统统写在一个py脚本中。 PyInstaller也是一个标准的Python包，提供了PyInstaller.main.run这个方法。 4.2节中等效的python脚本如下 1234if __name__ == '__main__': from PyInstaller.main import run params=[app.py', '-F', '-w', '--clean'] run(params) 用Python解释器执行这个脚本就可以了。 4.4 Q&amp;Alxml 可以解决lxml包含的问题，无需明确指定 调试 由于用了没有控制台的-w方式，如果程序启动有错的话，只会弹出app return -1的对话框，没有具体异常信息。可以先去掉-w，用控制台进行调试，所有的异常和程序中的print函数就显示在控制台上，方便调试。 单exe资源文件路径问题 这个问题应该只要是最后打包成单个exe都会出现的问题。描述如下 最后打包的文件结构如下 1234- XxxApp - app.exe - data - wpa.db 程序中用下面语句引用wpa.db文件，会出现文件打不开的情况 12BASE_DIR = os.path.abspath(os.path.dirname(__file__))DB_FILE = os.path.join(BASE_DIR,&apos;data&apos;, &apos;wpa.db&apos;) 调试打印出BASE_DIR，发现路径不是XxxApp，而是在用户目录下的某一个位置，类似如下 1c:\Users\kinegratii\AppData&apos;Local\Temp\_MEI11~1\data\wpa.db 这是因为在单文件模式中运行程序的时候先将文件解压到sys._MEIPASS指向的目录下，所以引用资源文件就需要添加os.path.join(sys._MEIPASS,filename)， 第一种方法，具体判断程序当前模式。 1234if getattr(sys, 'frozen', False): BASE_DIR = sys._MEIPASS else: BASE_DIR = os.path.dirname(__file__) 第二种，就是将 __file__ 改为 sys.args[0]，即 1BASE_DIR = os.path.abspath(os.path.dirname(sys.argv[0])) 这样打印的路径就是正确的了，原因在于__file__和sys.args[0]有点区别。 __file__ is the name of the current file, which may be different from the main script if you are inside a module or if you start a script using execfile() rather than by invoking python scriptname.py. __file__ is generally your safer bet. 来自 http://stackoverflow.com/a/5851608 icon图标无法显示问题 使用icon选项即可添加图标，但有时候发现资源管理器的图标可以显示，但运行程序后任务栏上的图标却无法显示。关于这个问题 。 在不同情况下（比如资源管理器文件列表前面的图标、桌面、开始菜单等）需要不一样尺寸的图标。如果尺寸不合适的话，可能出现有的地方显示正确有的显示不正确的情况。最后几个地方都要检查一遍。 解决方案 应该准备四张不同尺寸（具体尺寸参见 http://stackoverflow.com/questions/3236115/which-icon-sizes-should-my-windows-applications-icon-include ）的png文件用png2icon脚本把它们合成一张icon图标文件即可 5 参考资料 py2exe lxml error http://stackoverflow.com/a/5309733 Creating an Executable from a Python Script | Matt Borgersonhttps://mborgerson.com/creating-an-executable-from-a-python-script pyinstaller打包pyqt文件 - dcb3688 - 博客园http://www.cnblogs.com/dcb3688/p/4211390.html 使用pyinstaller打包python程序 - 魏哲的空间https://blog.weizhe.net/?p=412]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytz东八区6分钟问题]]></title>
    <url>%2F2015%2F11%2F12%2Fpython-pytz-6-minutes%2F</url>
    <content type="text"><![CDATA[本文介绍了pytz库中 Asia/Shanghai时区相差6分钟的问题。 之前也一直没有注意到这个问题，最近的项目需要同时显示DTU设备时间和服务器时间，才发现设备时间总是少6-7分钟。在项目中，两者解析成datetime对象的使用方法不一样： 服务器用的是Django框架，使用了django.utils.timezone.now函数解析服务器当前时间 DTU则是自己通过构造函数创建的，时区用的是pytz.timezone(‘Asia/Shanghai’) 首先在一篇文章《用datetime和pytz来转换时区》中说可以用台北时间（Asia/Taipei），试验下发现台北时间也有6分钟的问题。为了测试通过临时强制加上了6分钟，才勉强通过测试，然而这不是长久之计。 晚上下班时回家用“pytz 6分钟”搜索发现了《python中pytz,东8区,6分钟问题 - 老楠老楠》这篇文章。根据文章的描述，用localize函数就可以了。 使用datetime直接构造时间的时候，设置时区是没有北京时间的，一般来说习惯了linux的同志都会默认用上海时间来代替，这里却有一个问题，如果要进行时区转换，上海时间比北京时间差6分钟。。。 比如： 12tz = pytz.timezone(&apos;Asia/Shanghai&apos;)t = datetime.datetime(2015, 9, 5, 9, 0, 0, 0, tzinfo=tz) 这样打印出来得到的时间是： 12015-09-07 09:00:00+08:06 在django框架中，貌似from django.utils.timezone import localtime的这个localtime会修正那6分钟，这问题就来了，要自己在程序里构造时间，并且跟用这个localtime转化的时间对比的时候巨麻烦。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>pytz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[djcelery实践]]></title>
    <url>%2F2015%2F10%2F22%2Fdjcelery-practice%2F</url>
    <content type="text"><![CDATA[Celery是一个异步任务队列/基于分布式消息传递的作业队列。Celery通过消息（message）进行通信，使用代理（broker）在客户端和工作执行者之间进行交互。当开始一个任务时，客户端发送消息到队列并由代理将其发往响应的工作执行者处。。djcelery是其和Django框架一个很方便使用的第三方包。 1 环境配置1.1 安装ERLang 首先是到ERLang官网去下载ERlang可执行文件 地址：http://www.erlang.org/download.html 然后安装ERLang。 然后设置ERLang的环境变量。 在环境变量中加入 ERL_HOME = erlang安装目录 在path中添加 %ERL_HOME%\bin 1.2 安装rabbitmq从http://www.rabbitmq.com/releases/rabbitmq-server/v3.1.5/rabbitmq-server-3.1.5.exe下载rabbitmq-server 并安装。 点击开始菜单中的 rabbitmq-start ，rabbitmq-server就启动了，在管理工具-服务中可以看到相关信息的。 1.3 安装Djcelery和大多数Python第三方包一样，用 pip安装celery和djcelery两个包。djcelery依赖于djcelery，所以只要执行pip install djcelery命令即可。 2 配置Djcelery主要步骤 在settings配置相关参数 定义任务 执行任务，可以在程序中调用执行，也可交给后台周期性执行 2.1 基本配置下面是Djcelery的有关配置，定义在Django项目的settings模块内。 12345678910111213141516171819202122232425262728293031323334353637#... ...INSTALLED_APPS = ( 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.sites', 'django.contrib.messages', 'django.contrib.staticfiles', # Uncomment the next line to enable the admin: 'django.contrib.admin', # Uncomment the next line to enable admin documentation: # 'django.contrib.admindocs', 'djcelery', #添加djcelery 'mrs_app', #自己的APP)# ... ....# 配置djcelery相关参数，ResultStore默认存储在数据库可不必重写 ，import djcelerydjcelery.setup_loader()BROKER_URL = 'amqp://guest:guest@localhost:5672//'#任务定义所在的模块CELERY_IMPORTS = ('mrs_app.my_celery.tasks', )# 使用和Django一样的时区CELERY_TIMEZONE = TIME_ZONE#以上为基本配置，以下为周期性任务定义，以celerybeat_开头的 CELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler'#CELERYBEAT_SCHEDULE = &#123;# 'add-every-3-minutes': &#123;# 'task': 'mrs_app.my_celery.tasks.monthly_reading_task',# 'schedule': timedelta(minutes=3)# &#125;,#&#125; 2.2 定义任务有两种格式 类定义：一个继承了celery.app.task的类并实现了run方法 函数定义：@task装饰的函数 通过实现task相关方法可以实现更多的逻辑，比如成功回调、错误处理、重试机制等，以下是最基本的定义方式。 123456789101112131415161718#mrs_app.my_celery.tasks.pyfrom celery import task```python#第一种，函数方式 @task(name='monthly_reading')def monthly_reading_task(): task_obj = MonthlyReading(debug=False) task_obj.start()#第二种，类定义class MonthlyReadingTask(Task): name='monthly_reading' def run(*args, **kwargs): task_obj = MonthlyReading(debug=False) task_obj.start() 2.3 启动 启动 python manage.py celery worker -l info 如果有定时任务的话，还需要启动心跳 另开一个cmd窗口 python manage.py celery beat （windows下-B选项不可用） 3 执行任务3.1 直接调用自己在代码中的调用，支持延迟/同步/异步调用，可参考task类定义，例子见参考资料的《使用django+celery+RabbitMQ实现异步执行》。 3.2 周期性调用这种由djcelery调用，所以需要在settings.CELERYBEAT_SCHEDULER设置一个调度器，这里使用数据库。 djcelery提供了一些Model（定义在djcelery/models.py文件） 说明： 任务和定时任务的区别：定时任务 = 任务 + intervalschedule/crontabschedule 。两个定时任务可以执行同一个任务。 任务没有相应的Model，用字符串表示，即periodictask模型的task字段 定时任务有相应的Model即periodictask。 djcelery在初始化中主要完成两件： 在settings.CELERY_IMPORTS定义下的模块搜索所有任务。这个对数据库没有任何改变，只是用Admin添加定时任务时periodictask.task字段变成选择框，列出了所有定义的任务。 从settings.CELERYBEAT_SCHEDULE创建定时任务，这个会创建数据记录，相当于celery_models.PeriodicTask.objects.create(..)语句。 3.3 创建定时任务通过它提供的Model Query API来操作，同平常的数据库查询一样。 12345from djcelery import models as celery_modelscelery_models.PeriodicTask.objects.create(...)celery_models.PeriodicTask.ojects.get(name='add').... djcelery提供了admin管理界面，访问http://localhost:8000/admin/djcelery/ 即可，在这里可以对定时任务进行增删改查，具体和Django admin一样。 注：当我们修改任务的设置后，比如关闭、更改时间后不用重启celery服务等。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python IP归属地查询]]></title>
    <url>%2F2015%2F08%2F30%2Fpython-ip-query%2F</url>
    <content type="text"><![CDATA[基于Python3.2 + tkinter + 淘宝IP API的IP归属地查询。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from tkinter import *import reimport urllibimport urllib.requestimport jsonitem = ('country','area','region','city','isp')itemVar = ('国家','地区','省','市','运营商')class MWindow(Frame): def __init__(self): Frame.__init__(self) self.master.title('IPSearch') self.master.geometry('700x400') self.pack(side = TOP,expand = YES,fill = BOTH) ioPut = &#123;&#125; ioPut['ip_input'] = StringVar() ioPut['result_ouput'] = StringVar() res = &#123;&#125; for vx in item: res[vx] = StringVar() # top Frame topF = self.createFrame(self,TOP) inL = self.createLabel(topF,TOP,'请输入IP地址：') ipE = self.createEntry(topF,TOP,ioPut['ip_input']) resL = self.createLabel(topF,TOP,'查询结果：') resE = self.createEntry(topF,TOP,ioPut['result_ouput']) #mid Frame midF = self.createFrame(self,TOP) i = 0 l = len(item) while i &lt; l: L = self.createLabel(midF,LEFT,itemVar[i]) E = self.createEntry(midF,LEFT,res[item[i]]) i = i + 1 #bottom Frame botF = self.createFrame(self,TOP) searchB = Button(botF,text = 'search', command = lambda ioPut = ioPut,res = res:self.IpSearch(ioPut,res)) searchB.pack(side = TOP,expand = YES,fill = BOTH) def createFrame(self,parent,side): f = Frame(parent) f.pack(side = side,expand = YES,fill = BOTH) return f def createLabel(self,parent,side,text): l = Label(parent,text = text) l.pack(side = side,expand = YES) return l def createEntry(self,parent,side,textvariable): e = Entry(parent,relief = SUNKEN,textvariable = textvariable,width = 15) e.pack(side = side,expand = NO) return e def IpSearch(self,ioPut,res): ipRex = '((?:(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d)))\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))))' ip = ioPut['ip_input'].get() tmp = re.findall(re.compile(ipRex),ip) if not tmp: ioPut['result_ouput'].set('ip格式错误，请重新输入') return reponseData = IpS().searchByTaobao(ip) data = json.loads(reponseData) if data['code'] == 0: ioPut['result_ouput'].set('该IP所在位置如下') else: ioPut['result_ouput'].set('找不到相关信息') d = data['data'] for vx in item: res[vx].set(d[vx])class IpS(): def __init__(self): self.apiUrlTaobao = 'http://ip.taobao.com/service/getIpInfo.php?ip=' def searchByTaobao(self,ip): headers = ('User-Agent','Mozilla/5.0 (Windows NT 5.1; rv:14.0) Gecko/20100101 Firefox/14.0.1') opener = urllib.request.build_opener() opener.addheaders = [headers] data = opener.open(self.apiUrlTaobao+ip).read() data = data.decode('UTF-8') return dataif __name__ == '__main__': MWindow().mainloop() 效果图]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
